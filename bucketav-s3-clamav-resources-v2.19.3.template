Description: bucketAV powered by ClamAV - Antivirus protection for Amazon S3 (dedicated
  VPC; scanners run in private subnets)
AWSTemplateFormatVersion: '2010-09-09'
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
    - Label:
        default: Required Parameters
      Parameters:
      - KeyName
      - InfrastructureAlarmsEmail
    - Label:
        default: Scan Parameters
      Parameters:
      - DeleteInfectedFiles
      - TagFiles
      - TagKey
      - ReportCleanFiles
      - ScanDelayInSeconds
      - Governance
      - EnableCache
      - AdditionalDatabaseUrls
    - Label:
        default: VPC Parameters
      Parameters:
      - VpcCidrBlock
      - VpcSubnetCidrBits
      - SSHIngressCidrIp
      - FlowLogRetentionInDays
    - Label:
        default: Auto Scaling Group Parameters
      Parameters:
      - AutoScalingMinSize
      - AutoScalingMaxSize
      - CapacityStrategy
    - Label:
        default: EC2 Parameters
      Parameters:
      - InstanceType
      - LogsRetentionInDays
      - SystemsManagerAccess
    - Label:
        default: Permissions Parameters
      Parameters:
      - ManagedPolicyArns
      - AWSAccountRestriction
      - AWSOrganizationRestriction
      - S3BucketRestriction
      - S3ObjectRestriction
      - KMSKeyRestriction
      - PermissionsBoundary
    - Label:
        default: Deprecated, will be removed in v3; please use add-ons instead (https://bucketav.com/add-ons/).
      Parameters:
      - SecurityHubIntegration
      - OpsCenterIntegration
      - CloudWatchIntegration
Parameters:
  DeleteInfectedFiles:
    Type: String
    Default: 'true'
    AllowedValues:
    - 'true'
    - 'false'
    Description: Automatically delete infected files.
  ReportCleanFiles:
    Type: String
    Default: 'true'
    AllowedValues:
    - 'true'
    - 'false'
    Description: Report clean files to the SNS Findings Topic (recommended for better
      visibility).
  TagFiles:
    Type: String
    Default: 'true'
    AllowedValues:
    - 'true'
    - 'false'
    Description: Tag S3 object upon successful scan accordingly with values of "clean",
      "infected", or "no" (infected only works if DeleteInfectedFiles != true) using
      the tag key specified by TagKey.
  TagKey:
    Type: String
    Default: bucketav
    Description: S3 object tag key used to specify values of "clean", "infected",
      or "no".
  AutoScalingMinSize:
    Type: Number
    Default: 1
    ConstraintDescription: Must be >= 0
    Description: Minimum number of EC2 instances scanning files (in production, we
      recommend 2 for high availability).
    MinValue: 0
  AutoScalingMaxSize:
    Type: Number
    Default: 1
    ConstraintDescription: Must be >= 1
    Description: Maximum number of EC2 instances scanning files (in production, we
      recommend at least 2 for high availability).
    MinValue: 1
  KeyName:
    Type: AWS::EC2::KeyPair::KeyName
    Description: 'Name of the EC2 key pair to log in via SSH (username: ec2-user).'
  LogsRetentionInDays:
    Type: Number
    Default: 14
    AllowedValues:
    - 1
    - 3
    - 5
    - 7
    - 14
    - 30
    - 60
    - 90
    - 120
    - 150
    - 180
    - 365
    - 400
    - 545
    - 731
    - 1827
    - 3653
    Description: Specifies the number of days you want to retain log events.
  SystemsManagerAccess:
    Type: String
    Default: 'false'
    AllowedValues:
    - 'true'
    - 'false'
    Description: Enable AWS Systems Manager Session Manager to connect to the EC2
      instances. To fully enable SSM, add arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      to the ManagedPolicyArns configuration parameter as well.
  AWSAccountRestriction:
    Type: CommaDelimitedList
    Default: ''
    Description: Optional allowlist of all the AWS accounts that send S3 Notifications
      (e.g., 111111111111,222222222222,333333333333; only required in Multi-Account
      setups).
  AWSOrganizationRestriction:
    Type: CommaDelimitedList
    Default: ''
    Description: Optional allowlist of all the AWS organizations that send S3 Notifications
      (e.g., o-1111111111,o-2222222222,o-3333333333; only required in Multi-Account
      setups).
  S3BucketRestriction:
    Type: CommaDelimitedList
    Default: '*'
    Description: Restrict access to specific S3 buckets (e.g. arn:aws:s3:::bucket-a,arn:aws:s3:::bucket-b
      or * to allow access to all S3 buckets).
  S3ObjectRestriction:
    Type: CommaDelimitedList
    Default: '*'
    Description: Restrict access to specific S3 objects (e.g. arn:aws:s3:::bucket-a/*,arn:aws:s3:::bucket-b/*
      or * to allow access to all S3 objects).
  KMSKeyRestriction:
    Type: CommaDelimitedList
    Default: '*'
    Description: Restrict access to specific KMS keys (e.g. arn:aws:kms:us-east-1:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab,arn:aws:kms:us-east-1:111122223333:key/0987dcba-09fe-87dc-65ba-ab0987654321
      or * to allow access to all KMS keys).
  PermissionsBoundary:
    Type: String
    Default: ''
    Description: Optional IAM policy ARN that will be used as the permissions boundary
      for all roles.
  CapacityStrategy:
    Type: String
    Default: SpotWithoutAlternativeInstanceTypeWithOnDemandFallback
    AllowedValues:
    - SpotWithOnDemandFallback
    - OnDemandOnly
    - SpotOnly
    - SpotOnlyWithoutAlternativeInstanceType
    - SpotWithoutAlternativeInstanceTypeWithOnDemandFallback
    Description: Take advantage of unused EC2 capacity in the AWS cloud by launching
      spot instances that are up to 90% cheaper than on-demand prices. Keep in mind
      that spot instances can be interrupted at any time and are replaced automatically!
  ManagedPolicyArns:
    Type: String
    Default: ''
    Description: Optional comma-delimited list of IAM managed policy ARNs to attach
      to the IAM role of the EC2 instances.
  ScanDelayInSeconds:
    Type: Number
    Default: 0
    Description: Delay the scanning of objects by 0-900 seconds.
    MaxValue: 900
    MinValue: 0
  InfrastructureAlarmsEmail:
    Type: String
    Default: ''
    Description: Optional but strongly recommended email address receiving infrastructure
      alarms (for more than one email address, please subscribe to the Infrastructure
      Alarms SNS topic after stack creation).
  Governance:
    Type: String
    Default: 'true'
    AllowedValues:
    - 'true'
    - 'false'
    Description: Enable governance checks.
  SSHIngressCidrIp:
    Type: String
    Default: ''
    Description: Optional ingress rule allows SSH access from this IP address range
      usually from a peered VPC (e.g., 172.31.0.0/16).
  VpcCidrBlock:
    Type: String
    Default: 10.0.0.0/16
    Description: The IPv4 network range for the VPC, in CIDR notation (e.g., 10.0.0.0/16).
  VpcSubnetCidrBits:
    Type: Number
    Default: 12
    Description: The number of subnet bits for the CIDR (e.g., a value 8 will create
      a CIDR with a mask of /24).
    MaxValue: 14
    MinValue: 6
  FlowLogRetentionInDays:
    Type: Number
    Default: 14
    AllowedValues:
    - 0
    - 1
    - 3
    - 5
    - 7
    - 14
    - 30
    - 60
    - 90
    - 120
    - 150
    - 180
    - 365
    - 400
    - 545
    - 731
    - 1827
    - 3653
    Description: Specifies the number of days you want to retain VPC Flow Log events
      (set to 0 to disable).
  SecurityHubIntegration:
    Type: String
    Default: 'false'
    AllowedValues:
    - 'true'
    - 'false'
    Description: Deprecated, will be removed in v3; please use the Security Hub integration
      add-on instead (https://bucketav.com/add-ons/security-hub/).
  OpsCenterIntegration:
    Type: String
    Default: 'false'
    AllowedValues:
    - 'true'
    - 'false'
    Description: Deprecated, will be removed in v3; please use the OpsCenter integration
      add-on instead (https://bucketav.com/add-ons/ops-center/).
  CloudWatchIntegration:
    Type: String
    Default: 'false'
    AllowedValues:
    - 'true'
    - 'false'
    Description: Deprecated, will be removed in v3; this is now on by default.
  InstanceType:
    Type: String
    Default: m5.large
    AllowedValues:
    - t3a.small
    - t3a.medium
    - t3a.large
    - t3a.xlarge
    - t3a.2xlarge
    - t3.small
    - t3.medium
    - t3.large
    - t3.xlarge
    - t3.2xlarge
    - m7a.medium
    - m7a.large
    - m7a.xlarge
    - m7a.2xlarge
    - m7a.4xlarge
    - m7a.8xlarge
    - m7a.12xlarge
    - m7a.16xlarge
    - m7a.24xlarge
    - m7a.32xlarge
    - m7a.48xlarge
    - m7i.large
    - m7i.xlarge
    - m7i.2xlarge
    - m7i.4xlarge
    - m7i.8xlarge
    - m7i.12xlarge
    - m7i.16xlarge
    - m7i.24xlarge
    - m7i.48xlarge
    - m6a.large
    - m6a.xlarge
    - m6a.2xlarge
    - m6a.4xlarge
    - m6a.8xlarge
    - m6a.12xlarge
    - m6a.16xlarge
    - m6a.24xlarge
    - m6a.32xlarge
    - m6a.48xlarge
    - m6i.large
    - m6i.xlarge
    - m6i.2xlarge
    - m6i.4xlarge
    - m6i.8xlarge
    - m6i.12xlarge
    - m6i.16xlarge
    - m6i.24xlarge
    - m6i.32xlarge
    - m5a.large
    - m5a.xlarge
    - m5a.2xlarge
    - m5a.4xlarge
    - m5a.8xlarge
    - m5a.12xlarge
    - m5a.16xlarge
    - m5a.24xlarge
    - m5.large
    - m5.xlarge
    - m5.2xlarge
    - m5.4xlarge
    - m5.8xlarge
    - m5.12xlarge
    - m5.16xlarge
    - m5.24xlarge
    - m4.large
    - m4.xlarge
    - m4.2xlarge
    - m4.4xlarge
    - m4.10xlarge
    - m4.16xlarge
    - c7a.medium
    - c7a.large
    - c7a.xlarge
    - c7a.2xlarge
    - c7a.4xlarge
    - c7a.8xlarge
    - c7a.12xlarge
    - c7a.16xlarge
    - c7a.24xlarge
    - c7a.32xlarge
    - c7a.48xlarge
    - c7i.large
    - c7i.xlarge
    - c7i.2xlarge
    - c7i.4xlarge
    - c7i.8xlarge
    - c7i.12xlarge
    - c7i.16xlarge
    - c7i.24xlarge
    - c7i.48xlarge
    - c6a.large
    - c6a.xlarge
    - c6a.2xlarge
    - c6a.4xlarge
    - c6a.8xlarge
    - c6a.12xlarge
    - c6a.16xlarge
    - c6a.24xlarge
    - c6a.32xlarge
    - c6a.48xlarge
    - c6i.large
    - c6i.xlarge
    - c6i.2xlarge
    - c6i.4xlarge
    - c6i.8xlarge
    - c6i.12xlarge
    - c6i.16xlarge
    - c6i.24xlarge
    - c6i.32xlarge
    - c5a.large
    - c5a.xlarge
    - c5a.2xlarge
    - c5a.4xlarge
    - c5a.8xlarge
    - c5a.12xlarge
    - c5a.16xlarge
    - c5a.24xlarge
    - c5.large
    - c5.xlarge
    - c5.2xlarge
    - c5.4xlarge
    - c5.9xlarge
    - c5.12xlarge
    - c5.18xlarge
    - c5.24xlarge
    Description: Specifies the instance type of the EC2 instance (low performance
      for t3a.small and t3.small)
  EnableCache:
    Type: String
    Default: 'true'
    AllowedValues:
    - 'true'
    - 'false'
    Description: Enable cache checks for hash sums of scanned files (disable only
      during performance tests).
  AdditionalDatabaseUrls:
    Type: String
    Default: ''
    Description: Optional comma-delimited list of ClamAV database files available
      via http(s).
Conditions:
  HasDeleteInfectedFiles: !Equals [!Ref 'DeleteInfectedFiles', 'true']
  HasTagFiles: !Equals [!Ref 'TagFiles', 'true']
  HasSystemsManagerAccess: !Equals [!Ref 'SystemsManagerAccess', 'true']
  HasAWSAccountRestriction: !Not [!Equals [!Join ['', !Ref 'AWSAccountRestriction'],
      '']]
  HasAWSOrganizationRestriction: !Not [!Equals [!Join ['', !Ref 'AWSOrganizationRestriction'],
      '']]
  HasPermissionsBoundary: !Not [!Equals [!Ref 'PermissionsBoundary', '']]
  HasAlternativeInstanceType: !Or [!Equals [!Ref 'CapacityStrategy', SpotWithOnDemandFallback],
    !Equals [!Ref 'CapacityStrategy', SpotOnly]]
  HasOnDemandFallback: !Or [!Equals [!Ref 'CapacityStrategy', SpotWithOnDemandFallback],
    !Equals [!Ref 'CapacityStrategy', SpotWithoutAlternativeInstanceTypeWithOnDemandFallback]]
  HasManagedPolicyArns: !Not [!Equals [!Ref 'ManagedPolicyArns', '']]
  HasInfrastructureAlarmsEmail: !Not [!Equals [!Ref 'InfrastructureAlarmsEmail', '']]
  HasGovernance: !Equals [!Ref 'Governance', 'true']
  HasCrossAccount: !Or [!Not [!Equals [!Join [',', !Ref 'AWSAccountRestriction'],
        '']], !Not [!Equals [!Join [',', !Ref 'AWSOrganizationRestriction'], '']]]
  HasSSHIngressCidrIp: !Not [!Equals [!Ref 'SSHIngressCidrIp', '']]
  HasFlowLogs: !Not [!Equals [!Ref 'FlowLogRetentionInDays', '0']]
  HasSecurityHubIntegration: !Equals [!Ref 'SecurityHubIntegration', 'true']
  HasOpsCenterIntegration: !Equals [!Ref 'OpsCenterIntegration', 'true']
  HasRegionCaWest1: !Equals [!Ref 'AWS::Region', ca-west-1]
  HasAutoScalingMinSizeZero: !Equals [!Ref 'AutoScalingMinSize', 0]
Mappings:
  CapacityStrategyMap:
    SpotWithOnDemandFallback:
      OnDemandBaseCapacity: 0
      OnDemandPercentageAboveBaseCapacity: 0
    SpotWithoutAlternativeInstanceTypeWithOnDemandFallback:
      OnDemandBaseCapacity: 0
      OnDemandPercentageAboveBaseCapacity: 0
    SpotOnly:
      OnDemandBaseCapacity: 0
      OnDemandPercentageAboveBaseCapacity: 0
    SpotOnlyWithoutAlternativeInstanceType:
      OnDemandBaseCapacity: 0
      OnDemandPercentageAboveBaseCapacity: 0
    OnDemandOnly:
      OnDemandBaseCapacity: 0
      OnDemandPercentageAboveBaseCapacity: 100
  ManagedPrefixListMap:
    ap-south-2:
      PrefixListId: pl-8da045e4
    ap-south-1:
      PrefixListId: pl-78a54011
    eu-south-1:
      PrefixListId: pl-daaa4fb3
    eu-south-2:
      PrefixListId: pl-64a5400d
    me-central-1:
      PrefixListId: pl-1fbc5976
    il-central-1:
      PrefixListId: pl-8fa045e6
    ca-central-1:
      PrefixListId: pl-7da54014
    eu-central-1:
      PrefixListId: pl-6ea54007
    eu-central-2:
      PrefixListId: pl-9fa045f6
    us-west-1:
      PrefixListId: pl-6ba54002
    us-west-2:
      PrefixListId: pl-68a54001
    af-south-1:
      PrefixListId: pl-a3ac49ca
    eu-north-1:
      PrefixListId: pl-c3aa4faa
    eu-west-3:
      PrefixListId: pl-23ad484a
    eu-west-2:
      PrefixListId: pl-7ca54015
    eu-west-1:
      PrefixListId: pl-6da54004
    ap-northeast-3:
      PrefixListId: pl-a4a540cd
    ap-northeast-2:
      PrefixListId: pl-78a54011
    me-south-1:
      PrefixListId: pl-85a045ec
    ap-northeast-1:
      PrefixListId: pl-61a54008
    sa-east-1:
      PrefixListId: pl-6aa54003
    ap-east-1:
      PrefixListId: pl-64a5400d
    ca-west-1:
      PrefixListId: pl-94a643fd
    ap-southeast-1:
      PrefixListId: pl-6fa54006
    ap-southeast-2:
      PrefixListId: pl-6ca54005
    ap-southeast-3:
      PrefixListId: pl-64a7420d
    ap-southeast-4:
      PrefixListId: pl-d0a84db9
    us-east-1:
      PrefixListId: pl-63a5400a
    us-east-2:
      PrefixListId: pl-7ba54012
  ManagedPrefixListDynamoDBMap:
    ap-south-2:
      PrefixListId: pl-e6b0558f
    ap-south-1:
      PrefixListId: pl-66a7420f
    eu-south-1:
      PrefixListId: pl-ccb451a5
    eu-south-2:
      PrefixListId: pl-68a74201
    me-central-1:
      PrefixListId: pl-1ebc5977
    il-central-1:
      PrefixListId: pl-6ea74207
    ca-central-1:
      PrefixListId: pl-4ea54027
    eu-central-1:
      PrefixListId: pl-66a5400f
    eu-central-2:
      PrefixListId: pl-9da643f4
    us-west-1:
      PrefixListId: pl-6ea54007
    us-west-2:
      PrefixListId: pl-00a54069
    af-south-1:
      PrefixListId: pl-d6ae4bbf
    eu-north-1:
      PrefixListId: pl-adae4bc4
    eu-west-3:
      PrefixListId: pl-abb451c2
    eu-west-2:
      PrefixListId: pl-b3a742da
    eu-west-1:
      PrefixListId: pl-6fa54006
    ap-northeast-3:
      PrefixListId: pl-47a6432e
    ap-northeast-2:
      PrefixListId: pl-48a54021
    me-south-1:
      PrefixListId: pl-c9b451a0
    ap-northeast-1:
      PrefixListId: pl-78a54011
    sa-east-1:
      PrefixListId: pl-60a54009
    ap-east-1:
      PrefixListId: pl-c9b451a0
    ca-west-1:
      PrefixListId: pl-73a5401a
    ap-southeast-1:
      PrefixListId: pl-67a5400e
    ap-southeast-2:
      PrefixListId: pl-62a5400b
    ap-southeast-3:
      PrefixListId: pl-67a5400e
    ap-southeast-4:
      PrefixListId: pl-04be5b6d
    us-east-1:
      PrefixListId: pl-02cd2c6b
    us-east-2:
      PrefixListId: pl-4ca54025
  RegionMap:
    af-south-1:
      AMI: ami-07abb4e4ef27f54b4
    ap-east-1:
      AMI: ami-05b9fe6faf234a45d
    ap-northeast-1:
      AMI: ami-026f7a06b5aee3f57
    ap-northeast-2:
      AMI: ami-0de17c50b8a5fe9a0
    ap-northeast-3:
      AMI: ami-05be769157eb38a0d
    ap-south-1:
      AMI: ami-0a7e93ed82ef54b49
    ap-south-2:
      AMI: ami-04062ef783709cbdf
    ap-southeast-1:
      AMI: ami-0d1846ad4c2a666e3
    ap-southeast-2:
      AMI: ami-055872bb1d3966cff
    ap-southeast-3:
      AMI: ami-00d5172362611546a
    ap-southeast-4:
      AMI: ami-058641f3733564965
    ca-central-1:
      AMI: ami-0be3b41e9561807aa
    ca-west-1:
      AMI: ami-027c143ca9637bd93
    eu-central-1:
      AMI: ami-05602ca1ff638710c
    eu-central-2:
      AMI: ami-02c61bbf79a86ce2a
    eu-north-1:
      AMI: ami-0fb43683fc7a23a81
    eu-south-1:
      AMI: ami-03246db7e28181f44
    eu-south-2:
      AMI: ami-0db4db0cc748a8a1d
    eu-west-1:
      AMI: ami-0305ee795a49d954d
    eu-west-2:
      AMI: ami-0faf3fd664c11f83d
    eu-west-3:
      AMI: ami-0f793e3ca21f1e194
    il-central-1:
      AMI: ami-0c2e363ea46af5fc6
    me-central-1:
      AMI: ami-07c5e33d0c87ac4c3
    me-south-1:
      AMI: ami-0f92e0f2c1bf63c09
    sa-east-1:
      AMI: ami-025cfaa088ef0fa48
    us-east-1:
      AMI: ami-0a8753a59fb05d9e4
    us-east-2:
      AMI: ami-092f899841c3ee87b
    us-west-1:
      AMI: ami-03e73a154379e276b
    us-west-2:
      AMI: ami-0ebc5cdd9c1169e7b
  InstanceTypeMap:
    t3a.small:
      AlternativeInstanceType: t3.small
    t3a.medium:
      AlternativeInstanceType: t3.medium
    t3a.large:
      AlternativeInstanceType: t3.large
    t3a.xlarge:
      AlternativeInstanceType: t3.xlarge
    t3a.2xlarge:
      AlternativeInstanceType: t3.2xlarge
    t3.small:
      AlternativeInstanceType: t3a.small
    t3.medium:
      AlternativeInstanceType: t3a.medium
    t3.large:
      AlternativeInstanceType: t3a.large
    t3.xlarge:
      AlternativeInstanceType: t3a.xlarge
    t3.2xlarge:
      AlternativeInstanceType: t3a.2xlarge
    m7a.medium:
      AlternativeInstanceType: t3.medium
    m7a.large:
      AlternativeInstanceType: m5.large
    m7a.xlarge:
      AlternativeInstanceType: m5.xlarge
    m7a.2xlarge:
      AlternativeInstanceType: m5.2xlarge
    m7a.4xlarge:
      AlternativeInstanceType: m5.4xlarge
    m7a.8xlarge:
      AlternativeInstanceType: m5.8xlarge
    m7a.12xlarge:
      AlternativeInstanceType: m5.12xlarge
    m7a.16xlarge:
      AlternativeInstanceType: m5.16xlarge
    m7a.24xlarge:
      AlternativeInstanceType: m5.24xlarge
    m7a.32xlarge:
      AlternativeInstanceType: m5.24xlarge
    m7a.48xlarge:
      AlternativeInstanceType: m7i.48xlarge
    m7i.large:
      AlternativeInstanceType: m5.large
    m7i.xlarge:
      AlternativeInstanceType: m5.xlarge
    m7i.2xlarge:
      AlternativeInstanceType: m5.2xlarge
    m7i.4xlarge:
      AlternativeInstanceType: m5.4xlarge
    m7i.8xlarge:
      AlternativeInstanceType: m5.8xlarge
    m7i.12xlarge:
      AlternativeInstanceType: m5.12xlarge
    m7i.16xlarge:
      AlternativeInstanceType: m5.16xlarge
    m7i.24xlarge:
      AlternativeInstanceType: m5.24xlarge
    m7i.48xlarge:
      AlternativeInstanceType: m7a.48xlarge
    m6a.large:
      AlternativeInstanceType: m5.large
    m6a.xlarge:
      AlternativeInstanceType: m5.xlarge
    m6a.2xlarge:
      AlternativeInstanceType: m5.2xlarge
    m6a.4xlarge:
      AlternativeInstanceType: m5.4xlarge
    m6a.8xlarge:
      AlternativeInstanceType: m5.8xlarge
    m6a.12xlarge:
      AlternativeInstanceType: m5.12xlarge
    m6a.16xlarge:
      AlternativeInstanceType: m5.16xlarge
    m6a.24xlarge:
      AlternativeInstanceType: m5.24xlarge
    m6a.32xlarge:
      AlternativeInstanceType: m6i.32xlarge
    m6a.48xlarge:
      AlternativeInstanceType: m7a.48xlarge
    m6i.large:
      AlternativeInstanceType: m5.large
    m6i.xlarge:
      AlternativeInstanceType: m5.xlarge
    m6i.2xlarge:
      AlternativeInstanceType: m5.2xlarge
    m6i.4xlarge:
      AlternativeInstanceType: m5.4xlarge
    m6i.8xlarge:
      AlternativeInstanceType: m5.8xlarge
    m6i.12xlarge:
      AlternativeInstanceType: m5.12xlarge
    m6i.16xlarge:
      AlternativeInstanceType: m5.16xlarge
    m6i.24xlarge:
      AlternativeInstanceType: m5.24xlarge
    m6i.32xlarge:
      AlternativeInstanceType: m6a.32xlarge
    m5a.large:
      AlternativeInstanceType: m5.large
    m5a.xlarge:
      AlternativeInstanceType: m5.xlarge
    m5a.2xlarge:
      AlternativeInstanceType: m5.2xlarge
    m5a.4xlarge:
      AlternativeInstanceType: m5.4xlarge
    m5a.8xlarge:
      AlternativeInstanceType: m5.8xlarge
    m5a.12xlarge:
      AlternativeInstanceType: m5.12xlarge
    m5a.16xlarge:
      AlternativeInstanceType: m5.16xlarge
    m5a.24xlarge:
      AlternativeInstanceType: m5.24xlarge
    m5.large:
      AlternativeInstanceType: m5a.large
    m5.xlarge:
      AlternativeInstanceType: m5a.xlarge
    m5.2xlarge:
      AlternativeInstanceType: m5a.2xlarge
    m5.4xlarge:
      AlternativeInstanceType: m5a.4xlarge
    m5.8xlarge:
      AlternativeInstanceType: m5a.8xlarge
    m5.12xlarge:
      AlternativeInstanceType: m5a.12xlarge
    m5.16xlarge:
      AlternativeInstanceType: m5a.16xlarge
    m5.24xlarge:
      AlternativeInstanceType: m5a.24xlarge
    m4.large:
      AlternativeInstanceType: m5.large
    m4.xlarge:
      AlternativeInstanceType: m5.xlarge
    m4.2xlarge:
      AlternativeInstanceType: m5.2xlarge
    m4.4xlarge:
      AlternativeInstanceType: m5.4xlarge
    m4.10xlarge:
      AlternativeInstanceType: m5.8xlarge
    m4.16xlarge:
      AlternativeInstanceType: m5.16xlarge
    c7a.medium:
      AlternativeInstanceType: t3.medium
    c7a.large:
      AlternativeInstanceType: c5.large
    c7a.xlarge:
      AlternativeInstanceType: c5.xlarge
    c7a.2xlarge:
      AlternativeInstanceType: c5.2xlarge
    c7a.4xlarge:
      AlternativeInstanceType: c5.4xlarge
    c7a.8xlarge:
      AlternativeInstanceType: c5.9xlarge
    c7a.12xlarge:
      AlternativeInstanceType: c5.12xlarge
    c7a.16xlarge:
      AlternativeInstanceType: c5.18xlarge
    c7a.24xlarge:
      AlternativeInstanceType: c5.24xlarge
    c7a.32xlarge:
      AlternativeInstanceType: c6a.32xlarge
    c7a.48xlarge:
      AlternativeInstanceType: c6a.48xlarge
    c7i.large:
      AlternativeInstanceType: c5.large
    c7i.xlarge:
      AlternativeInstanceType: c5.xlarge
    c7i.2xlarge:
      AlternativeInstanceType: c5.2xlarge
    c7i.4xlarge:
      AlternativeInstanceType: c5.4xlarge
    c7i.8xlarge:
      AlternativeInstanceType: c5.9xlarge
    c7i.12xlarge:
      AlternativeInstanceType: c5.12xlarge
    c7i.16xlarge:
      AlternativeInstanceType: c5.18xlarge
    c7i.24xlarge:
      AlternativeInstanceType: c5.24xlarge
    c7i.48xlarge:
      AlternativeInstanceType: c7a.48xlarge
    c6a.large:
      AlternativeInstanceType: c5.large
    c6a.xlarge:
      AlternativeInstanceType: c5.xlarge
    c6a.2xlarge:
      AlternativeInstanceType: c5.2xlarge
    c6a.4xlarge:
      AlternativeInstanceType: c5.4xlarge
    c6a.8xlarge:
      AlternativeInstanceType: c5.9xlarge
    c6a.12xlarge:
      AlternativeInstanceType: c5.12xlarge
    c6a.16xlarge:
      AlternativeInstanceType: c5.18xlarge
    c6a.24xlarge:
      AlternativeInstanceType: c5.24xlarge
    c6a.32xlarge:
      AlternativeInstanceType: c6i.32xlarge
    c6a.48xlarge:
      AlternativeInstanceType: c7a.48xlarge
    c6i.large:
      AlternativeInstanceType: c5.large
    c6i.xlarge:
      AlternativeInstanceType: c5.xlarge
    c6i.2xlarge:
      AlternativeInstanceType: c5.2xlarge
    c6i.4xlarge:
      AlternativeInstanceType: c5.4xlarge
    c6i.8xlarge:
      AlternativeInstanceType: c5.9xlarge
    c6i.12xlarge:
      AlternativeInstanceType: c5.12xlarge
    c6i.16xlarge:
      AlternativeInstanceType: c5.18xlarge
    c6i.24xlarge:
      AlternativeInstanceType: c5.24xlarge
    c6i.32xlarge:
      AlternativeInstanceType: c6a.32xlarge
    c5a.large:
      AlternativeInstanceType: c5.large
    c5a.xlarge:
      AlternativeInstanceType: c5.xlarge
    c5a.2xlarge:
      AlternativeInstanceType: c5.2xlarge
    c5a.4xlarge:
      AlternativeInstanceType: c5.4xlarge
    c5a.8xlarge:
      AlternativeInstanceType: c5.9xlarge
    c5a.12xlarge:
      AlternativeInstanceType: c5.12xlarge
    c5a.16xlarge:
      AlternativeInstanceType: c5.18xlarge
    c5a.24xlarge:
      AlternativeInstanceType: c5.24xlarge
    c5.large:
      AlternativeInstanceType: c5a.large
    c5.xlarge:
      AlternativeInstanceType: c5a.xlarge
    c5.2xlarge:
      AlternativeInstanceType: c5a.2xlarge
    c5.4xlarge:
      AlternativeInstanceType: c5a.4xlarge
    c5.9xlarge:
      AlternativeInstanceType: c5a.8xlarge
    c5.12xlarge:
      AlternativeInstanceType: c5a.12xlarge
    c5.18xlarge:
      AlternativeInstanceType: c5a.16xlarge
    c5.24xlarge:
      AlternativeInstanceType: c5a.24xlarge
Resources:
  ServiceDiscoveryOrganizationId:
    Type: AWS::SSM::Parameter
    Properties:
      Description: bucketAV managed value. DO NOT CHANGE!
      Name: !Join ['', [/bucketAV/, !Ref 'AWS::StackName', /OrganizationId]]
      Type: String
      Value: INIT
    Condition: HasCrossAccount
  InfrastructureAlarmsTopic:
    Type: AWS::SNS::Topic
    Properties:
      Tags:
      - Key: bucketav:cloudformation:logical-id
        Value: InfrastructureAlarmsTopic
      - Key: bucketav:cloudformation:stack-id
        Value: !Ref 'AWS::StackId'
      - Key: bucketav:cloudformation:stack-name
        Value: !Ref 'AWS::StackName'
  InfrastructureAlarmsSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      Endpoint: !Ref 'InfrastructureAlarmsEmail'
      Protocol: email
      TopicArn: !Ref 'InfrastructureAlarmsTopic'
    Condition: HasInfrastructureAlarmsEmail
  FindingsTopic:
    Type: AWS::SNS::Topic
    Properties:
      Tags:
      - Key: bucketav:cloudformation:logical-id
        Value: FindingsTopic
      - Key: bucketav:cloudformation:stack-id
        Value: !Ref 'AWS::StackId'
      - Key: bucketav:cloudformation:stack-name
        Value: !Ref 'AWS::StackName'
  DeadLetterQueue:
    Type: AWS::SQS::Queue
    Properties:
      MessageRetentionPeriod: 1209600
      SqsManagedSseEnabled: true
      Tags:
      - Key: bucketav:cloudformation:logical-id
        Value: DeadLetterQueue
      - Key: bucketav:cloudformation:stack-id
        Value: !Ref 'AWS::StackId'
      - Key: bucketav:cloudformation:stack-name
        Value: !Ref 'AWS::StackName'
  ScanQueue:
    Type: AWS::SQS::Queue
    Properties:
      DelaySeconds: !Ref 'ScanDelayInSeconds'
      MessageRetentionPeriod: 1209600
      RedrivePolicy:
        deadLetterTargetArn: !GetAtt [DeadLetterQueue, Arn]
        maxReceiveCount: 3
      SqsManagedSseEnabled: true
      Tags:
      - Key: bucketav:cloudformation:logical-id
        Value: ScanQueue
      - Key: bucketav:cloudformation:stack-id
        Value: !Ref 'AWS::StackId'
      - Key: bucketav:cloudformation:stack-name
        Value: !Ref 'AWS::StackName'
      VisibilityTimeout: 300
  ScanQueuePolicy:
    Type: AWS::SQS::QueuePolicy
    Properties:
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - s3.amazonaws.com
            - sns.amazonaws.com
            - events.amazonaws.com
          Action: sqs:SendMessage
          Resource: !GetAtt [ScanQueue, Arn]
          Condition:
            StringEquals:
              aws:SourceAccount: !Ref 'AWS::AccountId'
        - !If [HasAWSAccountRestriction, {Effect: Allow, Principal: {Service: [s3.amazonaws.com,
                sns.amazonaws.com, events.amazonaws.com]}, Action: 'sqs:SendMessage',
            Resource: !GetAtt [ScanQueue, Arn], Condition: {StringEquals: {'aws:SourceAccount': !Ref 'AWSAccountRestriction'}}},
          !Ref 'AWS::NoValue']
        - !If [HasAWSOrganizationRestriction, {Effect: Allow, Principal: {Service: [
                s3.amazonaws.com, sns.amazonaws.com, events.amazonaws.com]}, Action: 'sqs:SendMessage',
            Resource: !GetAtt [ScanQueue, Arn], Condition: {StringEquals: {'aws:SourceOrgID': !Ref 'AWSOrganizationRestriction'}}},
          !Ref 'AWS::NoValue']
      Queues:
      - !Ref 'ScanQueue'
  DeadLetterQueueAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmActions:
      - !Ref 'InfrastructureAlarmsTopic'
      AlarmDescription: Dead letter queue contains messages. Some scan jobs were dropped.
        Please follow https://bucketav.com/help/operations/monitoring-alerting.html#deadletterqueuealarm
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
      - Name: QueueName
        Value: !GetAtt [DeadLetterQueue, QueueName]
      EvaluationPeriods: 1
      MetricName: ApproximateNumberOfMessagesVisible
      Namespace: AWS/SQS
      Period: 60
      Statistic: Sum
      Threshold: 1
      TreatMissingData: notBreaching
  ScanQueueOldMessagesAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmActions:
      - !Ref 'InfrastructureAlarmsTopic'
      AlarmDescription: Scan queue contains messages older than 12 hours. Please follow
        https://bucketav.com/help/operations/monitoring-alerting.html#scanqueueoldmessagesalarm
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
      - Name: QueueName
        Value: !GetAtt [ScanQueue, QueueName]
      EvaluationPeriods: 1
      MetricName: ApproximateAgeOfOldestMessage
      Namespace: AWS/SQS
      Period: 60
      Statistic: Maximum
      Threshold: 43200
      TreatMissingData: notBreaching
  AccountConnectionTopic:
    Type: AWS::SNS::Topic
    Properties:
      Tags:
      - Key: bucketav:cloudformation:logical-id
        Value: AccountConnectionTopic
      - Key: bucketav:cloudformation:stack-id
        Value: !Ref 'AWS::StackId'
      - Key: bucketav:cloudformation:stack-name
        Value: !Ref 'AWS::StackName'
      TopicName: !Join ['', [!Ref 'AWS::StackName', -AccountConnectionTopic]]
    Condition: HasCrossAccount
  AccountConnectionTopicPolicy:
    Type: AWS::SNS::TopicPolicy
    Properties:
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Sid: '1'
          Effect: Allow
          Principal:
            Service: events.amazonaws.com
          Action: sns:Publish
          Resource: !Ref 'AccountConnectionTopic'
        - !If [HasAWSAccountRestriction, {Sid: '10', Effect: Allow, Principal: '*',
            Action: 'sns:Publish', Resource: !Ref 'AccountConnectionTopic', Condition: {
              StringEquals: {'aws:PrincipalAccount': !Ref 'AWSAccountRestriction'}}},
          !Ref 'AWS::NoValue']
        - !If [HasAWSOrganizationRestriction, {Sid: '20', Effect: Allow, Principal: '*',
            Action: 'sns:Publish', Resource: !Ref 'AccountConnectionTopic', Condition: {
              StringEquals: {'aws:PrincipalOrgID': !Ref 'AWSOrganizationRestriction'}}},
          !Ref 'AWS::NoValue']
      Topics:
      - !Ref 'AccountConnectionTopic'
    Condition: HasCrossAccount
  AccountConnectionTable:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
      - AttributeName: account_connection_id
        AttributeType: S
      BillingMode: PAY_PER_REQUEST
      KeySchema:
      - AttributeName: account_connection_id
        KeyType: HASH
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      SSESpecification:
        SSEEnabled: true
      TableName: !Join ['', [!Ref 'AWS::StackName', -AccountConnection]]
    Condition: HasCrossAccount
  BucketCacheTable:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
      - AttributeName: bucket_name
        AttributeType: S
      BillingMode: PAY_PER_REQUEST
      KeySchema:
      - AttributeName: bucket_name
        KeyType: HASH
      SSESpecification:
        SSEEnabled: true
      TableName: !Join ['', [!Ref 'AWS::StackName', -BucketCache]]
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
    Condition: HasCrossAccount
  AccountConnectionLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
      PermissionsBoundary: !If [HasPermissionsBoundary, !Ref 'PermissionsBoundary',
        !Ref 'AWS::NoValue']
      Policies:
      - PolicyDocument:
          Statement:
          - Effect: Allow
            Action:
            - dynamodb:GetItem
            - dynamodb:PutItem
            - dynamodb:UpdateItem
            - dynamodb:DeleteItem
            Resource: !GetAtt [AccountConnectionTable, Arn]
          - Effect: Allow
            Action: dynamodb:GetItem
            Resource: !GetAtt [AccountConnectionTable, Arn]
          - Effect: Allow
            Action: dynamodb:PutItem
            Resource: !GetAtt [BucketCacheTable, Arn]
          - Effect: Allow
            Action: ssm:GetParametersByPath
            Resource: !Join ['', ['arn:', !Ref 'AWS::Partition', ':ssm:', !Ref 'AWS::Region',
                ':', !Ref 'AWS::AccountId', ':parameter/bucketAV/', !Ref 'AWS::StackName',
                /AddOn/scheduled-bucket-scan/*]]
          - Effect: Allow
            Action:
            - cloudformation:DescribeStacks
            - s3:ListAllMyBuckets
            - s3:GetBucketLocation
            - s3:GetBucketNotification
            - sns:ListSubscriptionsByTopic
            - events:ListRuleNamesByTarget
            - events:DescribeRule
            - organizations:DescribeOrganization
            Resource: '*'
          - Effect: Allow
            Action: events:DescribeEventBus
            Resource: !Join ['', ['arn:', !Ref 'AWS::Partition', ':events:', !Ref 'AWS::Region',
                ':', !Ref 'AWS::AccountId', ':event-bus/default']]
          - Effect: Allow
            Action: sts:AssumeRole
            Resource: !Join ['', ['arn:', !Ref 'AWS::Partition', ':iam::*:role/',
                !Ref 'AWS::StackName', -AccountConnection]]
          - Effect: Allow
            Action: sns:Publish
            Resource: !GetAtt [InfrastructureAlarmsTopic, TopicArn]
          - Effect: Allow
            Action: ssm:GetParameter
            Resource: !Join ['', ['arn:', !Ref 'AWS::Partition', ':ssm:', !Ref 'AWS::Region',
                ':', !Ref 'AWS::AccountId', ':parameter', !Ref 'ServiceDiscoveryOrganizationId']]
        PolicyName: main
    Condition: HasCrossAccount
  AccountConnectionLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: "var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n\
          var __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp =\
          \ Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n\
          \  for (var name in all)\n    __defProp(target, name, { get: all[name],\
          \ enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) =>\
          \ {\n  if (from && typeof from === \"object\" || typeof from === \"function\"\
          ) {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to,\
          \ key) && key !== except)\n        __defProp(to, key, { get: () => from[key],\
          \ enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n\
          \  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({},\
          \ \"__esModule\", { value: true }), mod);\n\n// lambda/account-connection.js\n\
          var account_connection_exports = {};\n__export(account_connection_exports,\
          \ {\n  handler: () => handler\n});\nmodule.exports = __toCommonJS(account_connection_exports);\n\
          var import_client_dynamodb3 = require(\"@aws-sdk/client-dynamodb\");\nvar\
          \ import_client_sns3 = require(\"@aws-sdk/client-sns\");\nvar import_client_organizations2\
          \ = require(\"@aws-sdk/client-organizations\");\nvar import_credential_providers3\
          \ = require(\"@aws-sdk/credential-providers\");\n\n// lambda/lib.js\nvar\
          \ import_client_cloudformation = require(\"@aws-sdk/client-cloudformation\"\
          );\nvar import_client_s3 = require(\"@aws-sdk/client-s3\");\nvar import_client_sns\
          \ = require(\"@aws-sdk/client-sns\");\nvar import_client_eventbridge = require(\"\
          @aws-sdk/client-eventbridge\");\nvar import_client_dynamodb = require(\"\
          @aws-sdk/client-dynamodb\");\nvar import_client_s32 = require(\"@aws-sdk/client-s3\"\
          );\nvar import_client_ssm = require(\"@aws-sdk/client-ssm\");\nvar import_client_secrets_manager\
          \ = require(\"@aws-sdk/client-secrets-manager\");\nvar import_client_organizations\
          \ = require(\"@aws-sdk/client-organizations\");\nvar import_credential_providers\
          \ = require(\"@aws-sdk/credential-providers\");\n\n// lambda/node_modules/@smithy/types/dist-es/auth/auth.js\n\
          var HttpAuthLocation;\n(function(HttpAuthLocation2) {\n  HttpAuthLocation2[\"\
          HEADER\"] = \"header\";\n  HttpAuthLocation2[\"QUERY\"] = \"query\";\n})(HttpAuthLocation\
          \ || (HttpAuthLocation = {}));\n\n// lambda/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js\n\
          var HttpApiKeyAuthLocation;\n(function(HttpApiKeyAuthLocation2) {\n  HttpApiKeyAuthLocation2[\"\
          HEADER\"] = \"header\";\n  HttpApiKeyAuthLocation2[\"QUERY\"] = \"query\"\
          ;\n})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));\n\n// lambda/node_modules/@smithy/types/dist-es/endpoint.js\n\
          var EndpointURLScheme;\n(function(EndpointURLScheme2) {\n  EndpointURLScheme2[\"\
          HTTP\"] = \"http\";\n  EndpointURLScheme2[\"HTTPS\"] = \"https\";\n})(EndpointURLScheme\
          \ || (EndpointURLScheme = {}));\n\n// lambda/node_modules/@smithy/types/dist-es/extensions/checksum.js\n\
          var AlgorithmId;\n(function(AlgorithmId2) {\n  AlgorithmId2[\"MD5\"] = \"\
          md5\";\n  AlgorithmId2[\"CRC32\"] = \"crc32\";\n  AlgorithmId2[\"CRC32C\"\
          ] = \"crc32c\";\n  AlgorithmId2[\"SHA1\"] = \"sha1\";\n  AlgorithmId2[\"\
          SHA256\"] = \"sha256\";\n})(AlgorithmId || (AlgorithmId = {}));\n\n// lambda/node_modules/@smithy/types/dist-es/http.js\n\
          var FieldPosition;\n(function(FieldPosition2) {\n  FieldPosition2[FieldPosition2[\"\
          HEADER\"] = 0] = \"HEADER\";\n  FieldPosition2[FieldPosition2[\"TRAILER\"\
          ] = 1] = \"TRAILER\";\n})(FieldPosition || (FieldPosition = {}));\n\n//\
          \ lambda/node_modules/@smithy/types/dist-es/profile.js\nvar IniSectionType;\n\
          (function(IniSectionType2) {\n  IniSectionType2[\"PROFILE\"] = \"profile\"\
          ;\n  IniSectionType2[\"SSO_SESSION\"] = \"sso-session\";\n  IniSectionType2[\"\
          SERVICES\"] = \"services\";\n})(IniSectionType || (IniSectionType = {}));\n\
          \n// lambda/node_modules/@smithy/types/dist-es/transfer.js\nvar RequestHandlerProtocol;\n\
          (function(RequestHandlerProtocol2) {\n  RequestHandlerProtocol2[\"HTTP_0_9\"\
          ] = \"http/0.9\";\n  RequestHandlerProtocol2[\"HTTP_1_0\"] = \"http/1.0\"\
          ;\n  RequestHandlerProtocol2[\"TDS_8_0\"] = \"tds/8.0\";\n})(RequestHandlerProtocol\
          \ || (RequestHandlerProtocol = {}));\n\n// lambda/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js\n\
          var import_fs = require(\"fs\");\nvar { readFile } = import_fs.promises;\n\
          \n// lambda/node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js\n\
          var import_fs2 = require(\"fs\");\nvar { readFile: readFile2 } = import_fs2.promises;\n\
          \n// lambda/node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js\n\
          var serializerMiddlewareOption = {\n  name: \"serializerMiddleware\",\n\
          \  step: \"serialize\",\n  tags: [\"SERIALIZER\"],\n  override: true\n};\n\
          \n// lambda/node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js\n\
          var endpointMiddlewareOptions = {\n  step: \"serialize\",\n  tags: [\"ENDPOINT_PARAMETERS\"\
          , \"ENDPOINT_V2\", \"ENDPOINT\"],\n  name: \"endpointV2Middleware\",\n \
          \ override: true,\n  relation: \"before\",\n  toMiddleware: serializerMiddlewareOption.name\n\
          };\n\n// lambda/node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemeEndpointRuleSetPlugin.js\n\
          var httpAuthSchemeEndpointRuleSetMiddlewareOptions = {\n  step: \"serialize\"\
          ,\n  tags: [\"HTTP_AUTH_SCHEME\"],\n  name: \"httpAuthSchemeMiddleware\"\
          ,\n  override: true,\n  relation: \"before\",\n  toMiddleware: endpointMiddlewareOptions.name\n\
          };\n\n// lambda/node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemePlugin.js\n\
          var httpAuthSchemeMiddlewareOptions = {\n  step: \"serialize\",\n  tags:\
          \ [\"HTTP_AUTH_SCHEME\"],\n  name: \"httpAuthSchemeMiddleware\",\n  override:\
          \ true,\n  relation: \"before\",\n  toMiddleware: serializerMiddlewareOption.name\n\
          };\n\n// lambda/node_modules/@smithy/util-retry/dist-es/config.js\nvar RETRY_MODES;\n\
          (function(RETRY_MODES2) {\n  RETRY_MODES2[\"STANDARD\"] = \"standard\";\n\
          \  RETRY_MODES2[\"ADAPTIVE\"] = \"adaptive\";\n})(RETRY_MODES || (RETRY_MODES\
          \ = {}));\nvar DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;\n\n// lambda/node_modules/@smithy/util-retry/dist-es/constants.js\n\
          var MAXIMUM_RETRY_DELAY = 20 * 1e3;\n\n// lambda/node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-pool.js\n\
          var NodeHttp2ConnectionPool = class {\n  constructor(sessions) {\n    this.sessions\
          \ = [];\n    this.sessions = sessions ?? [];\n  }\n  poll() {\n    if (this.sessions.length\
          \ > 0) {\n      return this.sessions.shift();\n    }\n  }\n  offerLast(session)\
          \ {\n    this.sessions.push(session);\n  }\n  contains(session) {\n    return\
          \ this.sessions.includes(session);\n  }\n  remove(session) {\n    this.sessions\
          \ = this.sessions.filter((s) => s !== session);\n  }\n  [Symbol.iterator]()\
          \ {\n    return this.sessions[Symbol.iterator]();\n  }\n  destroy(connection)\
          \ {\n    for (const session of this.sessions) {\n      if (session === connection)\
          \ {\n        if (!session.destroyed) {\n          session.destroy();\n \
          \       }\n      }\n    }\n  }\n};\n\n// lambda/node_modules/@smithy/smithy-client/dist-es/parse-utils.js\n\
          var MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));\n\n// lambda/node_modules/@smithy/smithy-client/dist-es/date-utils.js\n\
          var RFC3339 = new RegExp(/^(\\d{4})-(\\d{2})-(\\d{2})[tT](\\d{2}):(\\d{2}):(\\\
          d{2})(?:\\.(\\d+))?[zZ]$/);\nvar RFC3339_WITH_OFFSET = new RegExp(/^(\\\
          d{4})-(\\d{2})-(\\d{2})[tT](\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))?(([-+]\\\
          d{2}\\:\\d{2})|[zZ])$/);\nvar IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),\
          \ (\\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\\d{4}) (\\\
          d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? GMT$/);\nvar RFC_850_DATE = new\
          \ RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday),\
          \ (\\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\\d{2}) (\\\
          d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? GMT$/);\nvar ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)\
          \ (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\\d{2}) (\\\
          d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? (\\d{4})$/);\nvar FIFTY_YEARS_IN_MILLIS\
          \ = 50 * 365 * 24 * 60 * 60 * 1e3;\n\n// lambda/node_modules/@smithy/smithy-client/dist-es/lazy-json.js\n\
          var StringWrapper = function() {\n  const Class = Object.getPrototypeOf(this).constructor;\n\
          \  const Constructor = Function.bind.apply(String, [null, ...arguments]);\n\
          \  const instance = new Constructor();\n  Object.setPrototypeOf(instance,\
          \ Class.prototype);\n  return instance;\n};\nStringWrapper.prototype = Object.create(String.prototype,\
          \ {\n  constructor: {\n    value: StringWrapper,\n    enumerable: false,\n\
          \    writable: true,\n    configurable: true\n  }\n});\nObject.setPrototypeOf(StringWrapper,\
          \ String);\n\n// lambda/node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js\n\
          var retryMiddlewareOptions = {\n  name: \"retryMiddleware\",\n  tags: [\"\
          RETRY\"],\n  step: \"finalizeRequest\",\n  priority: \"high\",\n  override:\
          \ true\n};\n\n// lambda/node_modules/@smithy/core/dist-es/middleware-http-signing/getHttpSigningMiddleware.js\n\
          var httpSigningMiddlewareOptions = {\n  step: \"finalizeRequest\",\n  tags:\
          \ [\"HTTP_SIGNING\"],\n  name: \"httpSigningMiddleware\",\n  aliases: [\"\
          apiKeyMiddleware\", \"tokenMiddleware\", \"awsAuthMiddleware\"],\n  override:\
          \ true,\n  relation: \"after\",\n  toMiddleware: retryMiddlewareOptions.name\n\
          };\n\n// lambda/node_modules/@smithy/core/dist-es/util-identity-and-auth/memoizeIdentityProvider.js\n\
          var createIsIdentityExpiredFunction = (expirationMs) => (identity) => doesIdentityRequireRefresh(identity)\
          \ && identity.expiration.getTime() - Date.now() < expirationMs;\nvar EXPIRATION_MS\
          \ = 3e5;\nvar isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);\n\
          var doesIdentityRequireRefresh = (identity) => identity.expiration !== void\
          \ 0;\n\n// lambda/node_modules/@smithy/core/dist-es/pagination/createPaginator.js\n\
          var makePagedClientRequest = async (CommandCtor, client, input, ...args)\
          \ => {\n  return await client.send(new CommandCtor(input), ...args);\n};\n\
          function createPaginator(ClientCtor, CommandCtor, inputTokenName, outputTokenName,\
          \ pageSizeTokenName) {\n  return async function* paginateOperation(config,\
          \ input, ...additionalArguments) {\n    let token = config.startingToken\
          \ || void 0;\n    let hasNext = true;\n    let page;\n    while (hasNext)\
          \ {\n      input[inputTokenName] = token;\n      if (pageSizeTokenName)\
          \ {\n        input[pageSizeTokenName] = input[pageSizeTokenName] ?? config.pageSize;\n\
          \      }\n      if (config.client instanceof ClientCtor) {\n        page\
          \ = await makePagedClientRequest(CommandCtor, config.client, input, ...additionalArguments);\n\
          \      } else {\n        throw new Error(`Invalid client, expected instance\
          \ of ${ClientCtor.name}`);\n      }\n      yield page;\n      const prevToken\
          \ = token;\n      token = get(page, outputTokenName);\n      hasNext = !!(token\
          \ && (!config.stopOnSameToken || token !== prevToken));\n    }\n    return\
          \ void 0;\n  };\n}\nvar get = (fromObject, path) => {\n  let cursor = fromObject;\n\
          \  const pathComponents = path.split(\".\");\n  for (const step of pathComponents)\
          \ {\n    if (!cursor || typeof cursor !== \"object\") {\n      return void\
          \ 0;\n    }\n    cursor = cursor[step];\n  }\n  return cursor;\n};\n\n//\
          \ lambda/lib.js\nasync function fetchOrganizationId(organizations) {\n \
          \ try {\n    const { Organization } = await organizations.send(new import_client_organizations.DescribeOrganizationCommand({}));\n\
          \    return Organization.Id;\n  } catch (err) {\n    if (err.name === \"\
          AWSOrganizationsNotInUseException\") {\n      return void 0;\n    } else\
          \ {\n      throw err;\n    }\n  }\n}\nasync function fetchCachedOrganizationId(ssm2,\
          \ coreStackName) {\n  const data = await ssm2.send(new import_client_ssm.GetParameterCommand({\n\
          \    Name: `/bucketAV/${coreStackName}/OrganizationId`\n  }));\n  if (data.Parameter.Value\
          \ === \"INIT\" || data.Parameter.Value === \"NONE\") {\n    return void\
          \ 0;\n  }\n  return data.Parameter.Value;\n}\nfunction mapBucketLocationData(data)\
          \ {\n  if (data.LocationConstraint === void 0 || data.LocationConstraint\
          \ === null || data.LocationConstraint === \"\") {\n    return \"us-east-1\"\
          ;\n  }\n  if (data.LocationConstraint === \"EU\") {\n    return \"eu-west-1\"\
          ;\n  }\n  return data.LocationConstraint;\n}\nfunction includesBucket(scheduledStack,\
          \ bucketName) {\n  let excludeFilterExpression = \"^$\";\n  if (scheduledStack.params.ExcludeBucketNameFilter)\
          \ {\n    excludeFilterExpression = \"^\" + scheduledStack.params.ExcludeBucketNameFilter.replaceAll(\"\
          .\", \".\").replaceAll(\"-\", \"-\").replaceAll(\"*\", \".*\").replaceAll(\"\
          ,\", \"$|^\") + \"$\";\n  }\n  if (bucketName.match(new RegExp(excludeFilterExpression)))\
          \ {\n    return false;\n  }\n  if (scheduledStack.params.BucketName.includes(\"\
          *\")) {\n    const filterExpression = \"^\" + scheduledStack.params.BucketName.replaceAll(\"\
          .\", \".\").replaceAll(\"-\", \"-\").replaceAll(\"*\", \".*\").replaceAll(\"\
          ,\", \"$|^\") + \"$\";\n    return bucketName.match(new RegExp(filterExpression))\
          \ !== null;\n  } else {\n    return scheduledStack.params.BucketName.split(\"\
          ,\").includes(bucketName);\n  }\n}\nfunction hasBucket(scheduledStack, bucketName)\
          \ {\n  if (scheduledStack.params.BucketName === bucketName && (scheduledStack.params.ExcludeBucketNameFilter\
          \ === \"\" || !(\"ExcludeBucketNameFilter\" in scheduledStack.params)))\
          \ {\n    return true;\n  }\n  return false;\n}\nvar paginateListRuleNamesByTarget\
          \ = createPaginator(import_client_eventbridge.EventBridgeClient, import_client_eventbridge.ListRuleNamesByTargetCommand,\
          \ \"NextToken\", \"NextToken\", \"Limit\");\nasync function checkEventBridgeRules(eventbridge,\
          \ ruleNames, bucketName) {\n  const rules = await Promise.all(ruleNames.map((ruleName)\
          \ => eventbridge.send(new import_client_eventbridge.DescribeRuleCommand({\
          \ Name: ruleName }))));\n  return rules.filter((rule) => rule.State ===\
          \ \"ENABLED\" && rule.EventPattern).map((rule) => JSON.parse(rule.EventPattern)).find((pattern)\
          \ => pattern.source.includes(\"aws.s3\") && pattern[\"detail-type\"].includes(\"\
          Object Created\") && (pattern?.detail?.bucket?.name?.includes(bucketName)\
          \ || pattern?.detail?.bucket?.name === void 0)) !== void 0;\n}\nasync function\
          \ enrichBucket(s3, sns2, eventbridge, coreEventbridge, partition, region,\
          \ accountId, organizationId, coreAccountId, coreStackName, scanQueueArn,\
          \ scheduledStacks, bucketName) {\n  const bucket = await s3.send(new import_client_s3.GetBucketLocationCommand({\
          \ Bucket: bucketName })).then((data) => ({\n    name: bucketName,\n    region:\
          \ mapBucketLocationData(data),\n    accountId,\n    organizationId\n  })).catch((err)\
          \ => ({\n    name: bucketName,\n    region: void 0,\n    accountId,\n  \
          \  organizationId,\n    errorMessage: `Can not get region for bucket ${bucketName}:\
          \ ${err.name}`\n  }));\n  if (bucket.region === region || bucket.region\
          \ === void 0) {\n    let realtimeEnabled = false;\n    let realtimeEventNotificationEnablePossible\
          \ = bucket.region !== void 0;\n    let realtimeEventNotificationDisablePossible\
          \ = false;\n    let scheduledEnabled = false;\n    let scheduledStackDisablePossible\
          \ = false;\n    let scheduledStackId = void 0;\n    try {\n      const notificationData\
          \ = await s3.send(new import_client_s3.GetBucketNotificationConfigurationCommand({\
          \ Bucket: bucket.name, ExpectedBucketOwner: accountId }));\n      if (notificationData?.QueueConfigurations?.find((config)\
          \ => config.QueueArn === scanQueueArn && config.Events.includes(\"s3:ObjectCreated:*\"\
          )) !== void 0) {\n        realtimeEnabled = true;\n        realtimeEventNotificationDisablePossible\
          \ = true;\n      }\n      if (Array.isArray(notificationData?.TopicConfigurations))\
          \ {\n        await Promise.all(notificationData.TopicConfigurations.filter((config)\
          \ => config.Events.includes(\"s3:ObjectCreated:*\")).map(async (config)\
          \ => {\n          const paginatorListSubscriptionsByTopic = await (0, import_client_sns.paginateListSubscriptionsByTopic)({\
          \ client: sns2, pageSize: 50 }, { TopicArn: config.TopicArn });\n      \
          \    for await (const page of paginatorListSubscriptionsByTopic) {\n   \
          \         if (page.Subscriptions.find((subscription) => subscription.Protocol\
          \ === \"sqs\" && subscription.Endpoint === scanQueueArn) !== void 0) {\n\
          \              realtimeEnabled = true;\n            }\n          }\n   \
          \     }));\n      }\n      if (notificationData?.EventBridgeConfiguration)\
          \ {\n        if (accountId !== coreAccountId) {\n          let crossAccoutRule\
          \ = false;\n          const paginatorListRuleNamesByTargetDefaultBus = await\
          \ paginateListRuleNamesByTarget({ client: eventbridge, pageSize: 10 }, {\
          \ TargetArn: `arn:${partition}:events:${region}:${coreAccountId}:event-bus/default`\
          \ });\n          for await (const page of paginatorListRuleNamesByTargetDefaultBus)\
          \ {\n            if (await checkEventBridgeRules(eventbridge, page.RuleNames,\
          \ bucket.name) === true) {\n              crossAccoutRule = true;\n    \
          \        }\n          }\n          const { Policy: defaultBusPolicyJson\
          \ } = await coreEventbridge.send(new import_client_eventbridge.DescribeEventBusCommand({\n\
          \            Name: \"default\"\n          }));\n          if (defaultBusPolicyJson\
          \ !== void 0) {\n            const defaultBusPolicy = JSON.parse(defaultBusPolicyJson);\n\
          \            if (defaultBusPolicy.Statement.find((s) => s?.Effect === \"\
          Allow\" && s?.Action === \"events:PutEvents\" && (s?.Principal?.AWS ===\
          \ accountId || s?.Principal === \"*\" && s?.Condition?.StringEquals[\"aws:PrincipalOrgID\"\
          ] === organizationId)) !== void 0) {\n              if (crossAccoutRule\
          \ === true) {\n                realtimeEnabled = true;\n              }\n\
          \            }\n          }\n        }\n        const paginatorListRuleNamesByTargetScanQueue\
          \ = await paginateListRuleNamesByTarget({ client: coreEventbridge, pageSize:\
          \ 10 }, { TargetArn: scanQueueArn });\n        for await (const page of\
          \ paginatorListRuleNamesByTargetScanQueue) {\n          if (await checkEventBridgeRules(coreEventbridge,\
          \ page.RuleNames, bucket.name) === true) {\n            realtimeEnabled\
          \ = true;\n          }\n        }\n      }\n      if (notificationData?.TopicConfigurations?.find((config)\
          \ => config.Events.filter((event) => event.startsWith(\"s3:ObjectCreated:\"\
          )).length > 0)) {\n        realtimeEventNotificationEnablePossible = false;\n\
          \      }\n      if (notificationData?.QueueConfigurations?.find((config)\
          \ => config.Events.filter((event) => event.startsWith(\"s3:ObjectCreated:\"\
          )).length > 0)) {\n        realtimeEventNotificationEnablePossible = false;\n\
          \      }\n      if (notificationData?.LambdaFunctionConfigurations?.find((config)\
          \ => config.Events.filter((event) => event.startsWith(\"s3:ObjectCreated:\"\
          )).length > 0)) {\n        realtimeEventNotificationEnablePossible = false;\n\
          \      }\n      if (notificationData?.EventBridgeConfiguration !== void\
          \ 0) {\n        realtimeEventNotificationEnablePossible = false;\n     \
          \ }\n    } catch (err) {\n      console.log(err);\n      bucket.errorMessage\
          \ = `Can not get details for bucket ${bucket.name}: ${err.name}`;\n    \
          \  realtimeEventNotificationEnablePossible = false;\n    }\n    const scheduledStacksIncludesBucket\
          \ = scheduledStacks.stacks.filter((scheduledStack) => includesBucket(scheduledStack,\
          \ bucket.name));\n    if (scheduledStacksIncludesBucket.length > 0) {\n\
          \      scheduledEnabled = true;\n      scheduledStackId = scheduledStacksIncludesBucket[0].id;\n\
          \    }\n    const scheduledStacksHasBucket = scheduledStacks.stacks.filter((scheduledStack)\
          \ => hasBucket(scheduledStack, bucket.name));\n    if (scheduledStacksHasBucket.length\
          \ === 1) {\n      scheduledEnabled = true;\n      scheduledStackDisablePossible\
          \ = true;\n      scheduledStackId = scheduledStacksHasBucket[0].id;\n  \
          \  }\n    return {\n      ...bucket,\n      realtimeEnabled,\n      realtimeEventNotificationEnablePossible,\n\
          \      realtimeEventNotificationDisablePossible,\n      scheduledEnabled,\n\
          \      scheduledStackDisablePossible,\n      scheduledStackId\n    };\n\
          \  } else {\n    return null;\n  }\n}\nasync function getScheduledStacks(ssm2,\
          \ cloudformation2, coreStackName) {\n  const paginatorGetParametersByPath\
          \ = await (0, import_client_ssm.paginateGetParametersByPath)({ client: ssm2\
          \ }, { Recursive: true, Path: `/bucketAV/${coreStackName}/AddOn/scheduled-bucket-scan/`\
          \ });\n  const stacks = [];\n  for await (const page of paginatorGetParametersByPath)\
          \ {\n    const scheduledStackNames = page.Parameters.filter((p) => p.Name.endsWith(\"\
          /Version\")).map((p) => p.Name.split(\"/\")[5]);\n    const describeStacksDataList\
          \ = await Promise.all(scheduledStackNames.map((stackName) => cloudformation2.send(new\
          \ import_client_cloudformation.DescribeStacksCommand({ StackName: stackName\
          \ }))));\n    describeStacksDataList.forEach((describeStacksData) => {\n\
          \      const stack = {\n        name: describeStacksData.Stacks[0].StackName,\n\
          \        id: describeStacksData.Stacks[0].StackId,\n        params: describeStacksData.Stacks[0].Parameters?.reduce((acc,\
          \ param) => {\n          acc[param.ParameterKey] = param.ParameterValue;\n\
          \          return acc;\n        }, {}) || {},\n        outputs: describeStacksData.Stacks[0].Outputs?.reduce((acc,\
          \ output) => {\n          acc[output.OutputKey] = output.OutputValue;\n\
          \          return acc;\n        }, {}) || {}\n      };\n      if (stack.params.BucketAVStackName\
          \ === coreStackName && stack.outputs.AddOn === \"scheduled-bucket-scan\"\
          ) {\n        stacks.push(stack);\n      }\n    });\n  }\n  return {\n  \
          \  stacks\n  };\n}\nasync function listBuckets(s3, ssm2, cloudformation2,\
          \ sns2, eventbridge, coreEventbridge, partition, region, accountId, organizationId,\
          \ coreAccountId, coreStackName, scanQueueArn) {\n  const listBucketsData\
          \ = await s3.send(new import_client_s3.ListBucketsCommand({}));\n  const\
          \ scheduledStacks = await getScheduledStacks(ssm2, cloudformation2, coreStackName);\n\
          \  const buckets = await Promise.all(listBucketsData.Buckets.map((bucket)\
          \ => enrichBucket(s3, sns2, eventbridge, coreEventbridge, partition, region,\
          \ accountId, organizationId, coreAccountId, coreStackName, scanQueueArn,\
          \ scheduledStacks, bucket.Name)));\n  return buckets.filter((bucket) =>\
          \ bucket !== null);\n}\nfunction generateAccountConnectionId(partition,\
          \ region, accountId) {\n  return `${partition}:${region}:${accountId}`;\n\
          }\nvar MAX_S3_COPY_SIZE = 5 * 1024 * 1024 * 1024;\nfunction generateRoleArn(partition,\
          \ accountId, roleName) {\n  return `arn:${partition}:iam::${accountId}:role/${roleName}`;\n\
          }\nfunction generateRoleArnFromItem(accountConnectionItem) {\n  return generateRoleArn(accountConnectionItem.partition.S,\
          \ accountConnectionItem.account_id.S, accountConnectionItem.role_name.S);\n\
          }\nfunction generateExternalId(stackId) {\n  return stackId.split(\"/\"\
          )[2];\n}\nfunction generateExternalIdFromItem(accountConnectionItem) {\n\
          \  return generateExternalId(accountConnectionItem.stack_id.S);\n}\nasync\
          \ function cfnCustomResourceSuccess(event, physicalResourceId, optionalData)\
          \ {\n  const response = await fetch(event.ResponseURL, {\n    method: \"\
          PUT\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n \
          \   },\n    body: JSON.stringify({\n      Status: \"SUCCESS\",\n      PhysicalResourceId:\
          \ physicalResourceId,\n      StackId: event.StackId,\n      RequestId: event.RequestId,\n\
          \      LogicalResourceId: event.LogicalResourceId,\n      ...optionalData\
          \ !== void 0 && { Data: optionalData }\n    })\n  });\n  if (response.status\
          \ !== 200) {\n    console.log(\"response status\", response.status);\n \
          \   console.log(\"response\", await response.text());\n    throw new Error(\"\
          unexpected status code\");\n  }\n}\nasync function cfnCustomResourceFailed(event,\
          \ physicalResourceId, optionalReason) {\n  const response = await fetch(event.ResponseURL,\
          \ {\n    method: \"PUT\",\n    headers: {\n      \"Content-Type\": \"application/json\"\
          \n    },\n    body: JSON.stringify({\n      Status: \"FAILED\",\n      ...optionalReason\
          \ !== void 0 && { Reason: optionalReason },\n      PhysicalResourceId: physicalResourceId,\n\
          \      StackId: event.StackId,\n      RequestId: event.RequestId,\n    \
          \  LogicalResourceId: event.LogicalResourceId\n    })\n  });\n  if (response.status\
          \ !== 200) {\n    console.log(\"response status\", response.status);\n \
          \   console.log(\"response\", await response.text());\n    throw new Error(\"\
          unexpected status code\");\n  }\n}\n\n// lambda/refresh-bucket-cache.js\n\
          var import_client_dynamodb2 = require(\"@aws-sdk/client-dynamodb\");\nvar\
          \ import_client_cloudformation2 = require(\"@aws-sdk/client-cloudformation\"\
          );\nvar import_client_ssm2 = require(\"@aws-sdk/client-ssm\");\nvar import_client_sns2\
          \ = require(\"@aws-sdk/client-sns\");\nvar import_client_eventbridge2 =\
          \ require(\"@aws-sdk/client-eventbridge\");\nvar import_client_s33 = require(\"\
          @aws-sdk/client-s3\");\nvar import_credential_providers2 = require(\"@aws-sdk/credential-providers\"\
          );\nvar TTL_IN_SECONDS = 3600;\nvar ssm = new import_client_ssm2.SSMClient({\
          \ apiVersion: \"2014-11-06\" });\nvar cloudformation = new import_client_cloudformation2.CloudFormationClient({\
          \ apiVersion: \"2006-03-01\", maxAttempts: 10 });\nvar dynamodb = new import_client_dynamodb2.DynamoDBClient({\
          \ apiVersion: \"2012-08-10\" });\nasync function cacheBucket(partition,\
          \ region, accountId, { accountConnectionId, roleArn, externalId }, ttl,\
          \ bucket) {\n  const bucketCacheItem = {\n    bucket_name: { S: bucket.name\
          \ },\n    bucket_account_id: { S: bucket.accountId },\n    bucket_realtime_enabled:\
          \ { BOOL: bucket.realtimeEnabled },\n    bucket_realtime_event_notification_disable_possible:\
          \ { BOOL: bucket.realtimeEventNotificationDisablePossible },\n    bucket_realtime_event_notification_enable_possible:\
          \ { BOOL: bucket.realtimeEventNotificationEnablePossible },\n    bucket_scheduled_enabled:\
          \ { BOOL: bucket.scheduledEnabled },\n    bucket_scheduled_stack_disable_possible:\
          \ { BOOL: bucket.scheduledStackDisablePossible },\n    partition: { S: partition\
          \ },\n    region: { S: region },\n    account_id: { S: accountId },\n  \
          \  ttl: { N: ttl.toString() }\n  };\n  if (bucket.organizationId !== void\
          \ 0) {\n    bucketCacheItem.bucket_organization_id = { S: bucket.organizationId\
          \ };\n  }\n  if (accountConnectionId !== void 0) {\n    bucketCacheItem.account_connection_id\
          \ = { S: accountConnectionId };\n    bucketCacheItem.role_arn = { S: roleArn\
          \ };\n    bucketCacheItem.external_id = { S: externalId };\n  }\n  if (bucket.errorMessage\
          \ !== void 0) {\n    bucketCacheItem.bucket_error_message = { S: bucket.errorMessage\
          \ };\n  }\n  if (bucket.region !== void 0) {\n    bucketCacheItem.bucket_region\
          \ = { S: bucket.region };\n  }\n  if (bucket.scheduledStackId !== void 0)\
          \ {\n    bucketCacheItem.bucket_scheduled_stack_id = { S: bucket.scheduledStackId\
          \ };\n  }\n  await dynamodb.send(new import_client_dynamodb2.PutItemCommand({\n\
          \    TableName: `${process.env.CORE_STACK_NAME}-BucketCache`,\n    Item:\
          \ bucketCacheItem\n  }));\n}\nfunction getCredentials(accountConnectionId,\
          \ roleArn, externalId) {\n  if (accountConnectionId !== void 0 && roleArn\
          \ !== void 0 && externalId !== void 0) {\n    return (0, import_credential_providers2.fromTemporaryCredentials)({\n\
          \      params: {\n        RoleArn: roleArn,\n        ExternalId: externalId,\n\
          \        RoleSessionName: \"bucketav\",\n        DurationSeconds: 3600\n\
          \      }\n    });\n  } else {\n    return (0, import_credential_providers2.fromNodeProviderChain)();\n\
          \  }\n}\nfunction generateTtl() {\n  return Math.floor(Date.now() / 1e3)\
          \ + TTL_IN_SECONDS;\n}\nasync function refreshAccount2(partition, region,\
          \ accountId, { accountConnectionId, roleArn, externalId, organizationId\
          \ }, ttl, coreAccountId, coreStackName, scanQueueArn) {\n  const credentials\
          \ = getCredentials(accountConnectionId, roleArn, externalId);\n  const s3\
          \ = new import_client_s33.S3Client({ apiVersion: \"2006-03-01\", credentials\
          \ });\n  const sns2 = new import_client_sns2.SNSClient({ apiVersion: \"\
          2010-03-31\", credentials });\n  const eventbridge = new import_client_eventbridge2.EventBridgeClient({\
          \ apiVersion: \"2015-10-07\", credentials });\n  const coreEventbridge =\
          \ new import_client_eventbridge2.EventBridgeClient({ apiVersion: \"2015-10-07\"\
          \ });\n  const buckets = await listBuckets(s3, ssm, cloudformation, sns2,\
          \ eventbridge, coreEventbridge, partition, region, accountId, organizationId,\
          \ coreAccountId, coreStackName, scanQueueArn);\n  for (const bucket of buckets)\
          \ {\n    await cacheBucket(partition, region, accountId, { accountConnectionId,\
          \ roleArn, externalId }, ttl, bucket);\n  }\n}\nasync function refreshAccount(partition,\
          \ region, accountId, coreAccountId, coreStackName, scanQueueArn) {\n  const\
          \ accountConnectionId = generateAccountConnectionId(partition, region, accountId);\n\
          \  const accountConnectionData = await dynamodb.send(new import_client_dynamodb2.GetItemCommand({\n\
          \    TableName: `${coreStackName}-AccountConnection`,\n    Key: {\n    \
          \  account_connection_id: { S: accountConnectionId }\n    },\n    ConsistentRead:\
          \ true\n  }));\n  let accountConnection = {};\n  if (accountConnectionData.Item\
          \ !== void 0) {\n    const roleArn = generateRoleArnFromItem(accountConnectionData.Item);\n\
          \    const externalId = generateExternalIdFromItem(accountConnectionData.Item);\n\
          \    accountConnection.accountConnectionId = accountConnectionId;\n    accountConnection.roleArn\
          \ = roleArn;\n    accountConnection.externalId = externalId;\n    accountConnection.organizationId\
          \ = accountConnectionData.Item.organization_id?.S;\n  } else {\n    accountConnection.organizationId\
          \ = await fetchCachedOrganizationId(ssm, coreStackName);\n  }\n  return\
          \ refreshAccount2(partition, region, accountId, accountConnection, generateTtl(),\
          \ coreAccountId, coreStackName, scanQueueArn);\n}\n\n// lambda/account-connection.js\n\
          var dynamodb2 = new import_client_dynamodb3.DynamoDBClient({ apiVersion:\
          \ \"2012-08-10\" });\nvar sns = new import_client_sns3.SNSClient({ apiVersion:\
          \ \"2010-03-31\" });\nasync function handler(event, context) {\n  const\
          \ now = Date.now();\n  console.log(`Invoke: ${JSON.stringify(event)} ${JSON.stringify(context)}`);\n\
          \  for (const record of event.Records) {\n    if (record.Sns.Type === \"\
          Notification\") {\n      const message = JSON.parse(record.Sns.Message);\n\
          \      if (\"action\" in message) {\n        if (message.action === \"ping\"\
          ) {\n          const accountConnectionId = generateAccountConnectionId(message.partition,\
          \ message.region, message.accountId);\n          const accountConnectionData\
          \ = await dynamodb2.send(new import_client_dynamodb3.GetItemCommand({\n\
          \            TableName: `${process.env.CORE_STACK_NAME}-AccountConnection`,\n\
          \            Key: {\n              account_connection_id: { S: accountConnectionId\
          \ }\n            },\n            ConsistentRead: true\n          }));\n\
          \          if (accountConnectionData.Item === void 0) {\n            throw\
          \ new Error(\"account connection not found\");\n          }\n          const\
          \ credentials = (0, import_credential_providers3.fromTemporaryCredentials)({\n\
          \            params: {\n              RoleArn: generateRoleArnFromItem(accountConnectionData.Item),\n\
          \              ExternalId: generateExternalIdFromItem(accountConnectionData.Item),\n\
          \              RoleSessionName: \"bucketav\",\n              DurationSeconds:\
          \ 3600\n            }\n          });\n          const organizations = new\
          \ import_client_organizations2.OrganizationsClient({ apiVersion: \"2016-11-28\"\
          , credentials });\n          const organizationId = await fetchOrganizationId(organizations);\n\
          \          const expressionAttributeValues = {\n            \":now\": {\
          \ N: now.toString() }\n          };\n          let updateExpression = \"\
          SET pinged_at=:now\";\n          if (accountConnectionData.Item.organization_id?.S\
          \ !== organizationId) {\n            if (organizationId === void 0) {\n\
          \              updateExpression += \" REMOVE organization_id\";\n      \
          \      } else {\n              updateExpression += \", organization_id=:organizationId\"\
          ;\n              expressionAttributeValues[\":organizationId\"] = { S: organizationId\
          \ };\n            }\n          }\n          await dynamodb2.send(new import_client_dynamodb3.UpdateItemCommand({\n\
          \            TableName: `${process.env.CORE_STACK_NAME}-AccountConnection`,\n\
          \            Key: {\n              account_connection_id: { S: accountConnectionId\
          \ }\n            },\n            UpdateExpression: updateExpression,\n \
          \           ExpressionAttributeValues: expressionAttributeValues,\n    \
          \        ConditionExpression: \"attribute_exists(account_connection_id)\"\
          \n          }));\n          if (accountConnectionData.Item.organization_id?.S\
          \ !== organizationId) {\n            await refreshAccount(accountConnectionData.Item.partition.S,\
          \ accountConnectionData.Item.region.S, accountConnectionData.Item.account_id.S,\
          \ process.env.AWS_ACCOUNT_ID, process.env.CORE_STACK_NAME, process.env.SCAN_QUEUE_ARN);\n\
          \          }\n        } else if (message.action === \"refreshAccount\")\
          \ {\n          await refreshAccount(message.partition, message.region, message.accountId,\
          \ process.env.AWS_ACCOUNT_ID, process.env.CORE_STACK_NAME, process.env.SCAN_QUEUE_ARN);\n\
          \        } else {\n          throw new Error(\"Unsupported action\");\n\
          \        }\n      } else if (\"RequestType\" in message) {\n        try\
          \ {\n          if (message.RequestType === \"Create\") {\n            if\
          \ (process.env.AWS_PARTITION === message.ResourceProperties.Partition &&\
          \ process.env.AWS_ACCOUNT_ID === message.ResourceProperties.AccountId) {\n\
          \              throw new Error(\"No need to connect the bucketAV account\
          \ to itself\");\n            } else {\n              const credentials =\
          \ (0, import_credential_providers3.fromTemporaryCredentials)({\n       \
          \         params: {\n                  RoleArn: generateRoleArn(message.ResourceProperties.Partition,\
          \ message.ResourceProperties.AccountId, message.ResourceProperties.RoleName),\n\
          \                  ExternalId: generateExternalId(message.ResourceProperties.StackId),\n\
          \                  RoleSessionName: \"bucketav\",\n                  DurationSeconds:\
          \ 3600\n                }\n              });\n              const organizations\
          \ = new import_client_organizations2.OrganizationsClient({ apiVersion: \"\
          2016-11-28\", credentials });\n              const organizationId = await\
          \ fetchOrganizationId(organizations);\n              await dynamodb2.send(new\
          \ import_client_dynamodb3.PutItemCommand({\n                TableName: `${process.env.CORE_STACK_NAME}-AccountConnection`,\n\
          \                Item: {\n                  account_connection_id: { S:\
          \ generateAccountConnectionId(message.ResourceProperties.Partition, message.ResourceProperties.Region,\
          \ message.ResourceProperties.AccountId) },\n                  partition:\
          \ { S: message.ResourceProperties.Partition },\n                  region:\
          \ { S: message.ResourceProperties.Region },\n                  account_id:\
          \ { S: message.ResourceProperties.AccountId },\n                  ...organizationId\
          \ !== void 0 && { organization_id: { S: organizationId } },\n          \
          \        stack_id: { S: message.ResourceProperties.StackId },\n        \
          \          stack_name: { S: message.ResourceProperties.StackName },\n  \
          \                stack_version: { S: message.ResourceProperties.StackVersion\
          \ },\n                  role_name: { S: message.ResourceProperties.RoleName\
          \ },\n                  created_at: { N: now.toString() },\n           \
          \       updated_at: { N: now.toString() },\n                  pinged_at:\
          \ { N: now.toString() }\n                }\n              }));\n       \
          \       await refreshAccount(message.ResourceProperties.Partition, message.ResourceProperties.Region,\
          \ message.ResourceProperties.AccountId, process.env.AWS_ACCOUNT_ID, process.env.CORE_STACK_NAME,\
          \ process.env.SCAN_QUEUE_ARN);\n            }\n          } else if (message.RequestType\
          \ === \"Update\") {\n            const id = generateAccountConnectionId(message.ResourceProperties.Partition,\
          \ message.ResourceProperties.Region, message.ResourceProperties.AccountId);\n\
          \            const oldId = generateAccountConnectionId(message.OldResourceProperties.Partition,\
          \ message.OldResourceProperties.Region, message.OldResourceProperties.AccountId);\n\
          \            if (id !== oldId) {\n              throw new Error(\"unexpected\
          \ id change during update\");\n            }\n            await dynamodb2.send(new\
          \ import_client_dynamodb3.UpdateItemCommand({\n              TableName:\
          \ `${process.env.CORE_STACK_NAME}-AccountConnection`,\n              Key:\
          \ {\n                account_connection_id: { S: id }\n              },\n\
          \              UpdateExpression: \"SET stack_version=:stack_version, role_name=:role_name,\
          \ updated_at=:now\",\n              ExpressionAttributeValues: {\n     \
          \           \":now\": { N: now.toString() },\n                \":stack_version\"\
          : { S: message.ResourceProperties.StackVersion },\n                \":role_name\"\
          : { S: message.ResourceProperties.RoleName }\n              },\n       \
          \       ConditionExpression: \"attribute_exists(account_connection_id)\"\
          \n            }));\n            await refreshAccount(message.ResourceProperties.Partition,\
          \ message.ResourceProperties.Region, message.ResourceProperties.AccountId,\
          \ process.env.AWS_ACCOUNT_ID, process.env.CORE_STACK_NAME, process.env.SCAN_QUEUE_ARN);\n\
          \          } else if (message.RequestType === \"Delete\") {\n          \
          \  await dynamodb2.send(new import_client_dynamodb3.DeleteItemCommand({\n\
          \              TableName: `${process.env.CORE_STACK_NAME}-AccountConnection`,\n\
          \              Key: {\n                account_connection_id: { S: generateAccountConnectionId(message.ResourceProperties.Partition,\
          \ message.ResourceProperties.Region, message.ResourceProperties.AccountId)\
          \ }\n              }\n            }));\n          } else {\n           \
          \ throw new Error(\"Unsupported RequestType\");\n          }\n         \
          \ await cfnCustomResourceSuccess(message, message.ResourceProperties.StackId);\n\
          \        } catch (err) {\n          await cfnCustomResourceFailed(message,\
          \ message.ResourceProperties.StackId);\n          throw err;\n        }\n\
          \      } else if (message.source === \"aws.cloudwatch\") {\n        await\
          \ sns.send(new import_client_sns3.PublishCommand({\n          TopicArn:\
          \ process.env.INFRASTRUCTURE_ALARMS_TOPIC_ARN,\n          Message: JSON.stringify(message)\n\
          \        }));\n      } else {\n        throw new Error(\"Unsupported message\"\
          );\n      }\n    } else {\n      throw new Error(\"Unsupported SNS Type\"\
          );\n    }\n  }\n}\n// Annotate the CommonJS export names for ESM import\
          \ in node:\n0 && (module.exports = {\n  handler\n});\n"
      Environment:
        Variables:
          CORE_STACK_NAME: !Ref 'AWS::StackName'
          SCAN_QUEUE_ARN: !GetAtt [ScanQueue, Arn]
          AWS_PARTITION: !Ref 'AWS::Partition'
          AWS_ACCOUNT_ID: !Ref 'AWS::AccountId'
          INFRASTRUCTURE_ALARMS_TOPIC_ARN: !GetAtt [InfrastructureAlarmsTopic, TopicArn]
      Handler: index.handler
      MemorySize: 1769
      Role: !GetAtt [AccountConnectionLambdaRole, Arn]
      Runtime: nodejs20.x
      Timeout: 900
    Condition: HasCrossAccount
  AccountConnectionLambdaErrorsAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmActions:
      - !Ref 'InfrastructureAlarmsTopic'
      AlarmDescription: !Join ['', ['bucketAV Account Connection failed. Check logs
            of AWS Lambda Function ', !Ref 'AccountConnectionLambdaFunction', '!']]
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
      - Name: FunctionName
        Value: !Ref 'AccountConnectionLambdaFunction'
      EvaluationPeriods: 1
      MetricName: Errors
      Namespace: AWS/Lambda
      Period: 60
      Statistic: Sum
      Threshold: 1
      TreatMissingData: notBreaching
    Condition: HasCrossAccount
  AccountConnectionLambdaThrottlesAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmActions:
      - !Ref 'InfrastructureAlarmsTopic'
      AlarmDescription: bucketAV Account Connection throttled.
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
      - Name: FunctionName
        Value: !Ref 'AccountConnectionLambdaFunction'
      EvaluationPeriods: 1
      MetricName: Throttles
      Namespace: AWS/Lambda
      Period: 60
      Statistic: Sum
      Threshold: 1
      TreatMissingData: notBreaching
    Condition: HasCrossAccount
  LambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join ['', [/aws/lambda/, !Ref 'AccountConnectionLambdaFunction']]
      RetentionInDays: !Ref 'LogsRetentionInDays'
    Condition: HasCrossAccount
  AccountConnectionLambdaPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Statement:
        - Effect: Allow
          Action:
          - logs:CreateLogStream
          - logs:PutLogEvents
          Resource: !GetAtt [LambdaLogGroup, Arn]
      PolicyName: logs
      Roles:
      - !Ref 'AccountConnectionLambdaRole'
    Condition: HasCrossAccount
  AccountConnectionLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref 'AccountConnectionLambdaFunction'
      Principal: sns.amazonaws.com
      SourceArn: !Ref 'AccountConnectionTopic'
    Condition: HasCrossAccount
  AccountConnectionTopicSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      Endpoint: !GetAtt [AccountConnectionLambdaFunction, Arn]
      Protocol: lambda
      TopicArn: !Ref 'AccountConnectionTopic'
    DependsOn:
    - AccountConnectionLambdaPermission
    - AccountConnectionLambdaPolicy
    Condition: HasCrossAccount
  RefreshServiceDiscoveryLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
      PermissionsBoundary: !If [HasPermissionsBoundary, !Ref 'PermissionsBoundary',
        !Ref 'AWS::NoValue']
      Policies:
      - PolicyDocument:
          Statement:
          - Effect: Allow
            Action:
            - ssm:GetParameter
            - ssm:PutParameter
            Resource: !Join ['', ['arn:', !Ref 'AWS::Partition', ':ssm:', !Ref 'AWS::Region',
                ':', !Ref 'AWS::AccountId', ':parameter', !Ref 'ServiceDiscoveryOrganizationId']]
          - Effect: Allow
            Action: organizations:DescribeOrganization
            Resource: '*'
        PolicyName: lambda
    Condition: HasCrossAccount
  RefreshServiceDiscoveryLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: "var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n\
          var __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp =\
          \ Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n\
          \  for (var name in all)\n    __defProp(target, name, { get: all[name],\
          \ enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) =>\
          \ {\n  if (from && typeof from === \"object\" || typeof from === \"function\"\
          ) {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to,\
          \ key) && key !== except)\n        __defProp(to, key, { get: () => from[key],\
          \ enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n\
          \  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({},\
          \ \"__esModule\", { value: true }), mod);\n\n// lambda/refresh-service-discovery.js\n\
          var refresh_service_discovery_exports = {};\n__export(refresh_service_discovery_exports,\
          \ {\n  handler: () => handler\n});\nmodule.exports = __toCommonJS(refresh_service_discovery_exports);\n\
          var import_client_organizations2 = require(\"@aws-sdk/client-organizations\"\
          );\nvar import_client_ssm2 = require(\"@aws-sdk/client-ssm\");\n\n// lambda/lib.js\n\
          var import_client_cloudformation = require(\"@aws-sdk/client-cloudformation\"\
          );\nvar import_client_s3 = require(\"@aws-sdk/client-s3\");\nvar import_client_sns\
          \ = require(\"@aws-sdk/client-sns\");\nvar import_client_eventbridge = require(\"\
          @aws-sdk/client-eventbridge\");\nvar import_client_dynamodb = require(\"\
          @aws-sdk/client-dynamodb\");\nvar import_client_s32 = require(\"@aws-sdk/client-s3\"\
          );\nvar import_client_ssm = require(\"@aws-sdk/client-ssm\");\nvar import_client_secrets_manager\
          \ = require(\"@aws-sdk/client-secrets-manager\");\nvar import_client_organizations\
          \ = require(\"@aws-sdk/client-organizations\");\nvar import_credential_providers\
          \ = require(\"@aws-sdk/credential-providers\");\n\n// lambda/node_modules/@smithy/types/dist-es/auth/auth.js\n\
          var HttpAuthLocation;\n(function(HttpAuthLocation2) {\n  HttpAuthLocation2[\"\
          HEADER\"] = \"header\";\n  HttpAuthLocation2[\"QUERY\"] = \"query\";\n})(HttpAuthLocation\
          \ || (HttpAuthLocation = {}));\n\n// lambda/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js\n\
          var HttpApiKeyAuthLocation;\n(function(HttpApiKeyAuthLocation2) {\n  HttpApiKeyAuthLocation2[\"\
          HEADER\"] = \"header\";\n  HttpApiKeyAuthLocation2[\"QUERY\"] = \"query\"\
          ;\n})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));\n\n// lambda/node_modules/@smithy/types/dist-es/endpoint.js\n\
          var EndpointURLScheme;\n(function(EndpointURLScheme2) {\n  EndpointURLScheme2[\"\
          HTTP\"] = \"http\";\n  EndpointURLScheme2[\"HTTPS\"] = \"https\";\n})(EndpointURLScheme\
          \ || (EndpointURLScheme = {}));\n\n// lambda/node_modules/@smithy/types/dist-es/extensions/checksum.js\n\
          var AlgorithmId;\n(function(AlgorithmId2) {\n  AlgorithmId2[\"MD5\"] = \"\
          md5\";\n  AlgorithmId2[\"CRC32\"] = \"crc32\";\n  AlgorithmId2[\"CRC32C\"\
          ] = \"crc32c\";\n  AlgorithmId2[\"SHA1\"] = \"sha1\";\n  AlgorithmId2[\"\
          SHA256\"] = \"sha256\";\n})(AlgorithmId || (AlgorithmId = {}));\n\n// lambda/node_modules/@smithy/types/dist-es/http.js\n\
          var FieldPosition;\n(function(FieldPosition2) {\n  FieldPosition2[FieldPosition2[\"\
          HEADER\"] = 0] = \"HEADER\";\n  FieldPosition2[FieldPosition2[\"TRAILER\"\
          ] = 1] = \"TRAILER\";\n})(FieldPosition || (FieldPosition = {}));\n\n//\
          \ lambda/node_modules/@smithy/types/dist-es/profile.js\nvar IniSectionType;\n\
          (function(IniSectionType2) {\n  IniSectionType2[\"PROFILE\"] = \"profile\"\
          ;\n  IniSectionType2[\"SSO_SESSION\"] = \"sso-session\";\n  IniSectionType2[\"\
          SERVICES\"] = \"services\";\n})(IniSectionType || (IniSectionType = {}));\n\
          \n// lambda/node_modules/@smithy/types/dist-es/transfer.js\nvar RequestHandlerProtocol;\n\
          (function(RequestHandlerProtocol2) {\n  RequestHandlerProtocol2[\"HTTP_0_9\"\
          ] = \"http/0.9\";\n  RequestHandlerProtocol2[\"HTTP_1_0\"] = \"http/1.0\"\
          ;\n  RequestHandlerProtocol2[\"TDS_8_0\"] = \"tds/8.0\";\n})(RequestHandlerProtocol\
          \ || (RequestHandlerProtocol = {}));\n\n// lambda/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js\n\
          var import_fs = require(\"fs\");\nvar { readFile } = import_fs.promises;\n\
          \n// lambda/node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js\n\
          var import_fs2 = require(\"fs\");\nvar { readFile: readFile2 } = import_fs2.promises;\n\
          \n// lambda/node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js\n\
          var serializerMiddlewareOption = {\n  name: \"serializerMiddleware\",\n\
          \  step: \"serialize\",\n  tags: [\"SERIALIZER\"],\n  override: true\n};\n\
          \n// lambda/node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js\n\
          var endpointMiddlewareOptions = {\n  step: \"serialize\",\n  tags: [\"ENDPOINT_PARAMETERS\"\
          , \"ENDPOINT_V2\", \"ENDPOINT\"],\n  name: \"endpointV2Middleware\",\n \
          \ override: true,\n  relation: \"before\",\n  toMiddleware: serializerMiddlewareOption.name\n\
          };\n\n// lambda/node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemeEndpointRuleSetPlugin.js\n\
          var httpAuthSchemeEndpointRuleSetMiddlewareOptions = {\n  step: \"serialize\"\
          ,\n  tags: [\"HTTP_AUTH_SCHEME\"],\n  name: \"httpAuthSchemeMiddleware\"\
          ,\n  override: true,\n  relation: \"before\",\n  toMiddleware: endpointMiddlewareOptions.name\n\
          };\n\n// lambda/node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemePlugin.js\n\
          var httpAuthSchemeMiddlewareOptions = {\n  step: \"serialize\",\n  tags:\
          \ [\"HTTP_AUTH_SCHEME\"],\n  name: \"httpAuthSchemeMiddleware\",\n  override:\
          \ true,\n  relation: \"before\",\n  toMiddleware: serializerMiddlewareOption.name\n\
          };\n\n// lambda/node_modules/@smithy/util-retry/dist-es/config.js\nvar RETRY_MODES;\n\
          (function(RETRY_MODES2) {\n  RETRY_MODES2[\"STANDARD\"] = \"standard\";\n\
          \  RETRY_MODES2[\"ADAPTIVE\"] = \"adaptive\";\n})(RETRY_MODES || (RETRY_MODES\
          \ = {}));\nvar DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;\n\n// lambda/node_modules/@smithy/util-retry/dist-es/constants.js\n\
          var MAXIMUM_RETRY_DELAY = 20 * 1e3;\n\n// lambda/node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-pool.js\n\
          var NodeHttp2ConnectionPool = class {\n  constructor(sessions) {\n    this.sessions\
          \ = [];\n    this.sessions = sessions ?? [];\n  }\n  poll() {\n    if (this.sessions.length\
          \ > 0) {\n      return this.sessions.shift();\n    }\n  }\n  offerLast(session)\
          \ {\n    this.sessions.push(session);\n  }\n  contains(session) {\n    return\
          \ this.sessions.includes(session);\n  }\n  remove(session) {\n    this.sessions\
          \ = this.sessions.filter((s) => s !== session);\n  }\n  [Symbol.iterator]()\
          \ {\n    return this.sessions[Symbol.iterator]();\n  }\n  destroy(connection)\
          \ {\n    for (const session of this.sessions) {\n      if (session === connection)\
          \ {\n        if (!session.destroyed) {\n          session.destroy();\n \
          \       }\n      }\n    }\n  }\n};\n\n// lambda/node_modules/@smithy/smithy-client/dist-es/parse-utils.js\n\
          var MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));\n\n// lambda/node_modules/@smithy/smithy-client/dist-es/date-utils.js\n\
          var RFC3339 = new RegExp(/^(\\d{4})-(\\d{2})-(\\d{2})[tT](\\d{2}):(\\d{2}):(\\\
          d{2})(?:\\.(\\d+))?[zZ]$/);\nvar RFC3339_WITH_OFFSET = new RegExp(/^(\\\
          d{4})-(\\d{2})-(\\d{2})[tT](\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))?(([-+]\\\
          d{2}\\:\\d{2})|[zZ])$/);\nvar IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),\
          \ (\\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\\d{4}) (\\\
          d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? GMT$/);\nvar RFC_850_DATE = new\
          \ RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday),\
          \ (\\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\\d{2}) (\\\
          d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? GMT$/);\nvar ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)\
          \ (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\\d{2}) (\\\
          d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? (\\d{4})$/);\nvar FIFTY_YEARS_IN_MILLIS\
          \ = 50 * 365 * 24 * 60 * 60 * 1e3;\n\n// lambda/node_modules/@smithy/smithy-client/dist-es/lazy-json.js\n\
          var StringWrapper = function() {\n  const Class = Object.getPrototypeOf(this).constructor;\n\
          \  const Constructor = Function.bind.apply(String, [null, ...arguments]);\n\
          \  const instance = new Constructor();\n  Object.setPrototypeOf(instance,\
          \ Class.prototype);\n  return instance;\n};\nStringWrapper.prototype = Object.create(String.prototype,\
          \ {\n  constructor: {\n    value: StringWrapper,\n    enumerable: false,\n\
          \    writable: true,\n    configurable: true\n  }\n});\nObject.setPrototypeOf(StringWrapper,\
          \ String);\n\n// lambda/node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js\n\
          var retryMiddlewareOptions = {\n  name: \"retryMiddleware\",\n  tags: [\"\
          RETRY\"],\n  step: \"finalizeRequest\",\n  priority: \"high\",\n  override:\
          \ true\n};\n\n// lambda/node_modules/@smithy/core/dist-es/middleware-http-signing/getHttpSigningMiddleware.js\n\
          var httpSigningMiddlewareOptions = {\n  step: \"finalizeRequest\",\n  tags:\
          \ [\"HTTP_SIGNING\"],\n  name: \"httpSigningMiddleware\",\n  aliases: [\"\
          apiKeyMiddleware\", \"tokenMiddleware\", \"awsAuthMiddleware\"],\n  override:\
          \ true,\n  relation: \"after\",\n  toMiddleware: retryMiddlewareOptions.name\n\
          };\n\n// lambda/node_modules/@smithy/core/dist-es/util-identity-and-auth/memoizeIdentityProvider.js\n\
          var createIsIdentityExpiredFunction = (expirationMs) => (identity) => doesIdentityRequireRefresh(identity)\
          \ && identity.expiration.getTime() - Date.now() < expirationMs;\nvar EXPIRATION_MS\
          \ = 3e5;\nvar isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);\n\
          var doesIdentityRequireRefresh = (identity) => identity.expiration !== void\
          \ 0;\n\n// lambda/node_modules/@smithy/core/dist-es/pagination/createPaginator.js\n\
          var makePagedClientRequest = async (CommandCtor, client, input, ...args)\
          \ => {\n  return await client.send(new CommandCtor(input), ...args);\n};\n\
          function createPaginator(ClientCtor, CommandCtor, inputTokenName, outputTokenName,\
          \ pageSizeTokenName) {\n  return async function* paginateOperation(config,\
          \ input, ...additionalArguments) {\n    let token = config.startingToken\
          \ || void 0;\n    let hasNext = true;\n    let page;\n    while (hasNext)\
          \ {\n      input[inputTokenName] = token;\n      if (pageSizeTokenName)\
          \ {\n        input[pageSizeTokenName] = input[pageSizeTokenName] ?? config.pageSize;\n\
          \      }\n      if (config.client instanceof ClientCtor) {\n        page\
          \ = await makePagedClientRequest(CommandCtor, config.client, input, ...additionalArguments);\n\
          \      } else {\n        throw new Error(`Invalid client, expected instance\
          \ of ${ClientCtor.name}`);\n      }\n      yield page;\n      const prevToken\
          \ = token;\n      token = get(page, outputTokenName);\n      hasNext = !!(token\
          \ && (!config.stopOnSameToken || token !== prevToken));\n    }\n    return\
          \ void 0;\n  };\n}\nvar get = (fromObject, path) => {\n  let cursor = fromObject;\n\
          \  const pathComponents = path.split(\".\");\n  for (const step of pathComponents)\
          \ {\n    if (!cursor || typeof cursor !== \"object\") {\n      return void\
          \ 0;\n    }\n    cursor = cursor[step];\n  }\n  return cursor;\n};\n\n//\
          \ lambda/lib.js\nasync function fetchOrganizationId(organizations2) {\n\
          \  try {\n    const { Organization } = await organizations2.send(new import_client_organizations.DescribeOrganizationCommand({}));\n\
          \    return Organization.Id;\n  } catch (err) {\n    if (err.name === \"\
          AWSOrganizationsNotInUseException\") {\n      return void 0;\n    } else\
          \ {\n      throw err;\n    }\n  }\n}\nvar paginateListRuleNamesByTarget\
          \ = createPaginator(import_client_eventbridge.EventBridgeClient, import_client_eventbridge.ListRuleNamesByTargetCommand,\
          \ \"NextToken\", \"NextToken\", \"Limit\");\nvar MAX_S3_COPY_SIZE = 5 *\
          \ 1024 * 1024 * 1024;\nasync function cfnCustomResourceSuccess(event, physicalResourceId,\
          \ optionalData) {\n  const response = await fetch(event.ResponseURL, {\n\
          \    method: \"PUT\",\n    headers: {\n      \"Content-Type\": \"application/json\"\
          \n    },\n    body: JSON.stringify({\n      Status: \"SUCCESS\",\n     \
          \ PhysicalResourceId: physicalResourceId,\n      StackId: event.StackId,\n\
          \      RequestId: event.RequestId,\n      LogicalResourceId: event.LogicalResourceId,\n\
          \      ...optionalData !== void 0 && { Data: optionalData }\n    })\n  });\n\
          \  if (response.status !== 200) {\n    console.log(\"response status\",\
          \ response.status);\n    console.log(\"response\", await response.text());\n\
          \    throw new Error(\"unexpected status code\");\n  }\n}\nasync function\
          \ cfnCustomResourceFailed(event, physicalResourceId, optionalReason) {\n\
          \  const response = await fetch(event.ResponseURL, {\n    method: \"PUT\"\
          ,\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n\
          \    body: JSON.stringify({\n      Status: \"FAILED\",\n      ...optionalReason\
          \ !== void 0 && { Reason: optionalReason },\n      PhysicalResourceId: physicalResourceId,\n\
          \      StackId: event.StackId,\n      RequestId: event.RequestId,\n    \
          \  LogicalResourceId: event.LogicalResourceId\n    })\n  });\n  if (response.status\
          \ !== 200) {\n    console.log(\"response status\", response.status);\n \
          \   console.log(\"response\", await response.text());\n    throw new Error(\"\
          unexpected status code\");\n  }\n}\n\n// lambda/refresh-service-discovery.js\n\
          var organizations = new import_client_organizations2.OrganizationsClient({\
          \ apiVersion: \"2016-11-28\" });\nvar ssm = new import_client_ssm2.SSMClient({\
          \ apiVersion: \"2014-11-06\" });\nasync function refresh() {\n  const organizationId\
          \ = await fetchOrganizationId(organizations);\n  const newValue = organizationId\
          \ === void 0 ? \"NONE\" : organizationId;\n  const { Parameter: { Value:\
          \ oldValue } } = await ssm.send(new import_client_ssm2.GetParameterCommand({\n\
          \    Name: `/bucketAV/${process.env.CORE_STACK_NAME}/OrganizationId`\n \
          \ }));\n  if (oldValue !== newValue) {\n    await ssm.send(new import_client_ssm2.PutParameterCommand({\n\
          \      Name: `/bucketAV/${process.env.CORE_STACK_NAME}/OrganizationId`,\n\
          \      Value: newValue,\n      Overwrite: true\n    }));\n  }\n}\nasync\
          \ function handler(event, context) {\n  console.log(`Invoke: ${JSON.stringify(event)}\
          \ ${JSON.stringify(context)}`);\n  if (\"RequestType\" in event) {\n   \
          \ if (event.RequestType === \"Create\" || event.RequestType === \"Update\"\
          ) {\n      try {\n        await refresh();\n        await cfnCustomResourceSuccess(event,\
          \ process.env.CORE_STACK_NAME, {});\n      } catch (err) {\n        await\
          \ cfnCustomResourceFailed(event, process.env.CORE_STACK_NAME, err.message);\n\
          \      }\n    } else if (event.RequestType === \"Delete\") {\n      await\
          \ cfnCustomResourceSuccess(event, process.env.CORE_STACK_NAME, {});\n  \
          \  } else {\n      throw new Error(\"unsupported request type\");\n    }\n\
          \  } else {\n    await refresh();\n  }\n}\n// Annotate the CommonJS export\
          \ names for ESM import in node:\n0 && (module.exports = {\n  handler\n});\n"
      Environment:
        Variables:
          CORE_STACK_NAME: !Ref 'AWS::StackName'
      Handler: index.handler
      MemorySize: 1769
      Role: !GetAtt [RefreshServiceDiscoveryLambdaRole, Arn]
      Runtime: nodejs20.x
      Timeout: 300
    Condition: HasCrossAccount
  RefreshServiceDiscoveryLambdaErrorsAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmActions:
      - !Ref 'InfrastructureAlarmsTopic'
      AlarmDescription: !Join ['', ['bucketAV Governance check failed. Check logs
            of AWS Lambda Function ', !Ref 'RefreshServiceDiscoveryLambdaFunction',
          '!']]
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
      - Name: FunctionName
        Value: !Ref 'RefreshServiceDiscoveryLambdaFunction'
      EvaluationPeriods: 1
      MetricName: Errors
      Namespace: AWS/Lambda
      Period: 60
      Statistic: Sum
      Threshold: 1
      TreatMissingData: notBreaching
    Condition: HasCrossAccount
  RefreshServiceDiscoveryLambdaThrottlesAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmActions:
      - !Ref 'InfrastructureAlarmsTopic'
      AlarmDescription: bucketAV Governance check throttled.
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
      - Name: FunctionName
        Value: !Ref 'RefreshServiceDiscoveryLambdaFunction'
      EvaluationPeriods: 1
      MetricName: Throttles
      Namespace: AWS/Lambda
      Period: 60
      Statistic: Sum
      Threshold: 1
      TreatMissingData: notBreaching
    Condition: HasCrossAccount
  RefreshServiceDiscoveryLambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join ['', [/aws/lambda/, !Ref 'RefreshServiceDiscoveryLambdaFunction']]
      RetentionInDays: !Ref 'LogsRetentionInDays'
    Condition: HasCrossAccount
  RefreshServiceDiscoveryLambdaPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Statement:
        - Effect: Allow
          Action:
          - logs:CreateLogStream
          - logs:PutLogEvents
          Resource: !GetAtt [RefreshServiceDiscoveryLambdaLogGroup, Arn]
      PolicyName: logs
      Roles:
      - !Ref 'RefreshServiceDiscoveryLambdaRole'
    Condition: HasCrossAccount
  RefreshServiceDiscoveryLambdaCron:
    Type: AWS::Events::Rule
    Properties:
      ScheduleExpression: rate(1 day)
      Targets:
      - Arn: !GetAtt [RefreshServiceDiscoveryLambdaFunction, Arn]
        Id: lambda
    DependsOn:
    - RefreshServiceDiscoveryLambdaPolicy
    Condition: HasCrossAccount
  RefreshServiceDiscoveryLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref 'RefreshServiceDiscoveryLambdaFunction'
      Principal: events.amazonaws.com
      SourceArn: !GetAtt [RefreshServiceDiscoveryLambdaCron, Arn]
    Condition: HasCrossAccount
  RefreshServiceDiscovery:
    Type: Custom::RefreshServiceDiscovery
    Properties:
      ServiceToken: !GetAtt [RefreshServiceDiscoveryLambdaFunction, Arn]
      Version: 2.0.0
    DependsOn:
    - RefreshServiceDiscoveryLambdaPolicy
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Condition: HasCrossAccount
  RefreshBucketCacheRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
      PermissionsBoundary: !If [HasPermissionsBoundary, !Ref 'PermissionsBoundary',
        !Ref 'AWS::NoValue']
      Policies:
      - PolicyDocument:
          Statement:
          - Effect: Allow
            Action: dynamodb:PutItem
            Resource: !GetAtt [BucketCacheTable, Arn]
          - Effect: Allow
            Action: dynamodb:Scan
            Resource: !GetAtt [AccountConnectionTable, Arn]
          - Effect: Allow
            Action: ssm:GetParametersByPath
            Resource: !Join ['', ['arn:', !Ref 'AWS::Partition', ':ssm:', !Ref 'AWS::Region',
                ':', !Ref 'AWS::AccountId', ':parameter/bucketAV/', !Ref 'AWS::StackName',
                /AddOn/scheduled-bucket-scan/*]]
          - Effect: Allow
            Action:
            - cloudformation:DescribeStacks
            - s3:ListAllMyBuckets
            - s3:GetBucketLocation
            - s3:GetBucketNotification
            - sns:ListSubscriptionsByTopic
            - events:ListRuleNamesByTarget
            - events:DescribeRule
            Resource: '*'
          - Effect: Allow
            Action: ssm:GetParameter
            Resource: !Join ['', ['arn:', !Ref 'AWS::Partition', ':ssm:', !Ref 'AWS::Region',
                ':', !Ref 'AWS::AccountId', ':parameter', !Ref 'ServiceDiscoveryOrganizationId']]
          - Effect: Allow
            Action: events:DescribeEventBus
            Resource: !Join ['', ['arn:', !Ref 'AWS::Partition', ':events:', !Ref 'AWS::Region',
                ':', !Ref 'AWS::AccountId', ':event-bus/default']]
          - Effect: Allow
            Action: sts:AssumeRole
            Resource: !Join ['', ['arn:', !Ref 'AWS::Partition', ':iam::*:role/',
                !Ref 'AWS::StackName', -AccountConnection]]
        PolicyName: main
    Condition: HasCrossAccount
  RefreshBucketCacheFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: "var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n\
          var __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp =\
          \ Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n\
          \  for (var name in all)\n    __defProp(target, name, { get: all[name],\
          \ enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) =>\
          \ {\n  if (from && typeof from === \"object\" || typeof from === \"function\"\
          ) {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to,\
          \ key) && key !== except)\n        __defProp(to, key, { get: () => from[key],\
          \ enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n\
          \  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({},\
          \ \"__esModule\", { value: true }), mod);\n\n// lambda/refresh-bucket-cache.js\n\
          var refresh_bucket_cache_exports = {};\n__export(refresh_bucket_cache_exports,\
          \ {\n  handler: () => handler,\n  refreshAccount: () => refreshAccount,\n\
          \  refreshBucket: () => refreshBucket\n});\nmodule.exports = __toCommonJS(refresh_bucket_cache_exports);\n\
          var import_client_dynamodb2 = require(\"@aws-sdk/client-dynamodb\");\nvar\
          \ import_client_cloudformation2 = require(\"@aws-sdk/client-cloudformation\"\
          );\nvar import_client_ssm2 = require(\"@aws-sdk/client-ssm\");\nvar import_client_sns2\
          \ = require(\"@aws-sdk/client-sns\");\nvar import_client_eventbridge2 =\
          \ require(\"@aws-sdk/client-eventbridge\");\nvar import_client_s33 = require(\"\
          @aws-sdk/client-s3\");\nvar import_credential_providers2 = require(\"@aws-sdk/credential-providers\"\
          );\n\n// lambda/lib.js\nvar import_client_cloudformation = require(\"@aws-sdk/client-cloudformation\"\
          );\nvar import_client_s3 = require(\"@aws-sdk/client-s3\");\nvar import_client_sns\
          \ = require(\"@aws-sdk/client-sns\");\nvar import_client_eventbridge = require(\"\
          @aws-sdk/client-eventbridge\");\nvar import_client_dynamodb = require(\"\
          @aws-sdk/client-dynamodb\");\nvar import_client_s32 = require(\"@aws-sdk/client-s3\"\
          );\nvar import_client_ssm = require(\"@aws-sdk/client-ssm\");\nvar import_client_secrets_manager\
          \ = require(\"@aws-sdk/client-secrets-manager\");\nvar import_client_organizations\
          \ = require(\"@aws-sdk/client-organizations\");\nvar import_credential_providers\
          \ = require(\"@aws-sdk/credential-providers\");\n\n// lambda/node_modules/@smithy/types/dist-es/auth/auth.js\n\
          var HttpAuthLocation;\n(function(HttpAuthLocation2) {\n  HttpAuthLocation2[\"\
          HEADER\"] = \"header\";\n  HttpAuthLocation2[\"QUERY\"] = \"query\";\n})(HttpAuthLocation\
          \ || (HttpAuthLocation = {}));\n\n// lambda/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js\n\
          var HttpApiKeyAuthLocation;\n(function(HttpApiKeyAuthLocation2) {\n  HttpApiKeyAuthLocation2[\"\
          HEADER\"] = \"header\";\n  HttpApiKeyAuthLocation2[\"QUERY\"] = \"query\"\
          ;\n})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));\n\n// lambda/node_modules/@smithy/types/dist-es/endpoint.js\n\
          var EndpointURLScheme;\n(function(EndpointURLScheme2) {\n  EndpointURLScheme2[\"\
          HTTP\"] = \"http\";\n  EndpointURLScheme2[\"HTTPS\"] = \"https\";\n})(EndpointURLScheme\
          \ || (EndpointURLScheme = {}));\n\n// lambda/node_modules/@smithy/types/dist-es/extensions/checksum.js\n\
          var AlgorithmId;\n(function(AlgorithmId2) {\n  AlgorithmId2[\"MD5\"] = \"\
          md5\";\n  AlgorithmId2[\"CRC32\"] = \"crc32\";\n  AlgorithmId2[\"CRC32C\"\
          ] = \"crc32c\";\n  AlgorithmId2[\"SHA1\"] = \"sha1\";\n  AlgorithmId2[\"\
          SHA256\"] = \"sha256\";\n})(AlgorithmId || (AlgorithmId = {}));\n\n// lambda/node_modules/@smithy/types/dist-es/http.js\n\
          var FieldPosition;\n(function(FieldPosition2) {\n  FieldPosition2[FieldPosition2[\"\
          HEADER\"] = 0] = \"HEADER\";\n  FieldPosition2[FieldPosition2[\"TRAILER\"\
          ] = 1] = \"TRAILER\";\n})(FieldPosition || (FieldPosition = {}));\n\n//\
          \ lambda/node_modules/@smithy/types/dist-es/profile.js\nvar IniSectionType;\n\
          (function(IniSectionType2) {\n  IniSectionType2[\"PROFILE\"] = \"profile\"\
          ;\n  IniSectionType2[\"SSO_SESSION\"] = \"sso-session\";\n  IniSectionType2[\"\
          SERVICES\"] = \"services\";\n})(IniSectionType || (IniSectionType = {}));\n\
          \n// lambda/node_modules/@smithy/types/dist-es/transfer.js\nvar RequestHandlerProtocol;\n\
          (function(RequestHandlerProtocol2) {\n  RequestHandlerProtocol2[\"HTTP_0_9\"\
          ] = \"http/0.9\";\n  RequestHandlerProtocol2[\"HTTP_1_0\"] = \"http/1.0\"\
          ;\n  RequestHandlerProtocol2[\"TDS_8_0\"] = \"tds/8.0\";\n})(RequestHandlerProtocol\
          \ || (RequestHandlerProtocol = {}));\n\n// lambda/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js\n\
          var import_fs = require(\"fs\");\nvar { readFile } = import_fs.promises;\n\
          \n// lambda/node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js\n\
          var import_fs2 = require(\"fs\");\nvar { readFile: readFile2 } = import_fs2.promises;\n\
          \n// lambda/node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js\n\
          var serializerMiddlewareOption = {\n  name: \"serializerMiddleware\",\n\
          \  step: \"serialize\",\n  tags: [\"SERIALIZER\"],\n  override: true\n};\n\
          \n// lambda/node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js\n\
          var endpointMiddlewareOptions = {\n  step: \"serialize\",\n  tags: [\"ENDPOINT_PARAMETERS\"\
          , \"ENDPOINT_V2\", \"ENDPOINT\"],\n  name: \"endpointV2Middleware\",\n \
          \ override: true,\n  relation: \"before\",\n  toMiddleware: serializerMiddlewareOption.name\n\
          };\n\n// lambda/node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemeEndpointRuleSetPlugin.js\n\
          var httpAuthSchemeEndpointRuleSetMiddlewareOptions = {\n  step: \"serialize\"\
          ,\n  tags: [\"HTTP_AUTH_SCHEME\"],\n  name: \"httpAuthSchemeMiddleware\"\
          ,\n  override: true,\n  relation: \"before\",\n  toMiddleware: endpointMiddlewareOptions.name\n\
          };\n\n// lambda/node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemePlugin.js\n\
          var httpAuthSchemeMiddlewareOptions = {\n  step: \"serialize\",\n  tags:\
          \ [\"HTTP_AUTH_SCHEME\"],\n  name: \"httpAuthSchemeMiddleware\",\n  override:\
          \ true,\n  relation: \"before\",\n  toMiddleware: serializerMiddlewareOption.name\n\
          };\n\n// lambda/node_modules/@smithy/util-retry/dist-es/config.js\nvar RETRY_MODES;\n\
          (function(RETRY_MODES2) {\n  RETRY_MODES2[\"STANDARD\"] = \"standard\";\n\
          \  RETRY_MODES2[\"ADAPTIVE\"] = \"adaptive\";\n})(RETRY_MODES || (RETRY_MODES\
          \ = {}));\nvar DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;\n\n// lambda/node_modules/@smithy/util-retry/dist-es/constants.js\n\
          var MAXIMUM_RETRY_DELAY = 20 * 1e3;\n\n// lambda/node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-pool.js\n\
          var NodeHttp2ConnectionPool = class {\n  constructor(sessions) {\n    this.sessions\
          \ = [];\n    this.sessions = sessions ?? [];\n  }\n  poll() {\n    if (this.sessions.length\
          \ > 0) {\n      return this.sessions.shift();\n    }\n  }\n  offerLast(session)\
          \ {\n    this.sessions.push(session);\n  }\n  contains(session) {\n    return\
          \ this.sessions.includes(session);\n  }\n  remove(session) {\n    this.sessions\
          \ = this.sessions.filter((s) => s !== session);\n  }\n  [Symbol.iterator]()\
          \ {\n    return this.sessions[Symbol.iterator]();\n  }\n  destroy(connection)\
          \ {\n    for (const session of this.sessions) {\n      if (session === connection)\
          \ {\n        if (!session.destroyed) {\n          session.destroy();\n \
          \       }\n      }\n    }\n  }\n};\n\n// lambda/node_modules/@smithy/smithy-client/dist-es/parse-utils.js\n\
          var MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));\n\n// lambda/node_modules/@smithy/smithy-client/dist-es/date-utils.js\n\
          var RFC3339 = new RegExp(/^(\\d{4})-(\\d{2})-(\\d{2})[tT](\\d{2}):(\\d{2}):(\\\
          d{2})(?:\\.(\\d+))?[zZ]$/);\nvar RFC3339_WITH_OFFSET = new RegExp(/^(\\\
          d{4})-(\\d{2})-(\\d{2})[tT](\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))?(([-+]\\\
          d{2}\\:\\d{2})|[zZ])$/);\nvar IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),\
          \ (\\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\\d{4}) (\\\
          d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? GMT$/);\nvar RFC_850_DATE = new\
          \ RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday),\
          \ (\\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\\d{2}) (\\\
          d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? GMT$/);\nvar ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)\
          \ (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\\d{2}) (\\\
          d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? (\\d{4})$/);\nvar FIFTY_YEARS_IN_MILLIS\
          \ = 50 * 365 * 24 * 60 * 60 * 1e3;\n\n// lambda/node_modules/@smithy/smithy-client/dist-es/lazy-json.js\n\
          var StringWrapper = function() {\n  const Class = Object.getPrototypeOf(this).constructor;\n\
          \  const Constructor = Function.bind.apply(String, [null, ...arguments]);\n\
          \  const instance = new Constructor();\n  Object.setPrototypeOf(instance,\
          \ Class.prototype);\n  return instance;\n};\nStringWrapper.prototype = Object.create(String.prototype,\
          \ {\n  constructor: {\n    value: StringWrapper,\n    enumerable: false,\n\
          \    writable: true,\n    configurable: true\n  }\n});\nObject.setPrototypeOf(StringWrapper,\
          \ String);\n\n// lambda/node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js\n\
          var retryMiddlewareOptions = {\n  name: \"retryMiddleware\",\n  tags: [\"\
          RETRY\"],\n  step: \"finalizeRequest\",\n  priority: \"high\",\n  override:\
          \ true\n};\n\n// lambda/node_modules/@smithy/core/dist-es/middleware-http-signing/getHttpSigningMiddleware.js\n\
          var httpSigningMiddlewareOptions = {\n  step: \"finalizeRequest\",\n  tags:\
          \ [\"HTTP_SIGNING\"],\n  name: \"httpSigningMiddleware\",\n  aliases: [\"\
          apiKeyMiddleware\", \"tokenMiddleware\", \"awsAuthMiddleware\"],\n  override:\
          \ true,\n  relation: \"after\",\n  toMiddleware: retryMiddlewareOptions.name\n\
          };\n\n// lambda/node_modules/@smithy/core/dist-es/util-identity-and-auth/memoizeIdentityProvider.js\n\
          var createIsIdentityExpiredFunction = (expirationMs) => (identity) => doesIdentityRequireRefresh(identity)\
          \ && identity.expiration.getTime() - Date.now() < expirationMs;\nvar EXPIRATION_MS\
          \ = 3e5;\nvar isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);\n\
          var doesIdentityRequireRefresh = (identity) => identity.expiration !== void\
          \ 0;\n\n// lambda/node_modules/@smithy/core/dist-es/pagination/createPaginator.js\n\
          var makePagedClientRequest = async (CommandCtor, client, input, ...args)\
          \ => {\n  return await client.send(new CommandCtor(input), ...args);\n};\n\
          function createPaginator(ClientCtor, CommandCtor, inputTokenName, outputTokenName,\
          \ pageSizeTokenName) {\n  return async function* paginateOperation(config,\
          \ input, ...additionalArguments) {\n    let token = config.startingToken\
          \ || void 0;\n    let hasNext = true;\n    let page;\n    while (hasNext)\
          \ {\n      input[inputTokenName] = token;\n      if (pageSizeTokenName)\
          \ {\n        input[pageSizeTokenName] = input[pageSizeTokenName] ?? config.pageSize;\n\
          \      }\n      if (config.client instanceof ClientCtor) {\n        page\
          \ = await makePagedClientRequest(CommandCtor, config.client, input, ...additionalArguments);\n\
          \      } else {\n        throw new Error(`Invalid client, expected instance\
          \ of ${ClientCtor.name}`);\n      }\n      yield page;\n      const prevToken\
          \ = token;\n      token = get(page, outputTokenName);\n      hasNext = !!(token\
          \ && (!config.stopOnSameToken || token !== prevToken));\n    }\n    return\
          \ void 0;\n  };\n}\nvar get = (fromObject, path) => {\n  let cursor = fromObject;\n\
          \  const pathComponents = path.split(\".\");\n  for (const step of pathComponents)\
          \ {\n    if (!cursor || typeof cursor !== \"object\") {\n      return void\
          \ 0;\n    }\n    cursor = cursor[step];\n  }\n  return cursor;\n};\n\n//\
          \ lambda/lib.js\nasync function fetchCachedOrganizationId(ssm2, coreStackName)\
          \ {\n  const data = await ssm2.send(new import_client_ssm.GetParameterCommand({\n\
          \    Name: `/bucketAV/${coreStackName}/OrganizationId`\n  }));\n  if (data.Parameter.Value\
          \ === \"INIT\" || data.Parameter.Value === \"NONE\") {\n    return void\
          \ 0;\n  }\n  return data.Parameter.Value;\n}\nfunction mapBucketLocationData(data)\
          \ {\n  if (data.LocationConstraint === void 0 || data.LocationConstraint\
          \ === null || data.LocationConstraint === \"\") {\n    return \"us-east-1\"\
          ;\n  }\n  if (data.LocationConstraint === \"EU\") {\n    return \"eu-west-1\"\
          ;\n  }\n  return data.LocationConstraint;\n}\nfunction includesBucket(scheduledStack,\
          \ bucketName) {\n  let excludeFilterExpression = \"^$\";\n  if (scheduledStack.params.ExcludeBucketNameFilter)\
          \ {\n    excludeFilterExpression = \"^\" + scheduledStack.params.ExcludeBucketNameFilter.replaceAll(\"\
          .\", \".\").replaceAll(\"-\", \"-\").replaceAll(\"*\", \".*\").replaceAll(\"\
          ,\", \"$|^\") + \"$\";\n  }\n  if (bucketName.match(new RegExp(excludeFilterExpression)))\
          \ {\n    return false;\n  }\n  if (scheduledStack.params.BucketName.includes(\"\
          *\")) {\n    const filterExpression = \"^\" + scheduledStack.params.BucketName.replaceAll(\"\
          .\", \".\").replaceAll(\"-\", \"-\").replaceAll(\"*\", \".*\").replaceAll(\"\
          ,\", \"$|^\") + \"$\";\n    return bucketName.match(new RegExp(filterExpression))\
          \ !== null;\n  } else {\n    return scheduledStack.params.BucketName.split(\"\
          ,\").includes(bucketName);\n  }\n}\nfunction hasBucket(scheduledStack, bucketName)\
          \ {\n  if (scheduledStack.params.BucketName === bucketName && (scheduledStack.params.ExcludeBucketNameFilter\
          \ === \"\" || !(\"ExcludeBucketNameFilter\" in scheduledStack.params)))\
          \ {\n    return true;\n  }\n  return false;\n}\nvar paginateListRuleNamesByTarget\
          \ = createPaginator(import_client_eventbridge.EventBridgeClient, import_client_eventbridge.ListRuleNamesByTargetCommand,\
          \ \"NextToken\", \"NextToken\", \"Limit\");\nasync function checkEventBridgeRules(eventbridge,\
          \ ruleNames, bucketName) {\n  const rules = await Promise.all(ruleNames.map((ruleName)\
          \ => eventbridge.send(new import_client_eventbridge.DescribeRuleCommand({\
          \ Name: ruleName }))));\n  return rules.filter((rule) => rule.State ===\
          \ \"ENABLED\" && rule.EventPattern).map((rule) => JSON.parse(rule.EventPattern)).find((pattern)\
          \ => pattern.source.includes(\"aws.s3\") && pattern[\"detail-type\"].includes(\"\
          Object Created\") && (pattern?.detail?.bucket?.name?.includes(bucketName)\
          \ || pattern?.detail?.bucket?.name === void 0)) !== void 0;\n}\nasync function\
          \ enrichBucket(s3, sns, eventbridge, coreEventbridge, partition, region,\
          \ accountId, organizationId, coreAccountId, coreStackName, scanQueueArn,\
          \ scheduledStacks, bucketName) {\n  const bucket = await s3.send(new import_client_s3.GetBucketLocationCommand({\
          \ Bucket: bucketName })).then((data) => ({\n    name: bucketName,\n    region:\
          \ mapBucketLocationData(data),\n    accountId,\n    organizationId\n  })).catch((err)\
          \ => ({\n    name: bucketName,\n    region: void 0,\n    accountId,\n  \
          \  organizationId,\n    errorMessage: `Can not get region for bucket ${bucketName}:\
          \ ${err.name}`\n  }));\n  if (bucket.region === region || bucket.region\
          \ === void 0) {\n    let realtimeEnabled = false;\n    let realtimeEventNotificationEnablePossible\
          \ = bucket.region !== void 0;\n    let realtimeEventNotificationDisablePossible\
          \ = false;\n    let scheduledEnabled = false;\n    let scheduledStackDisablePossible\
          \ = false;\n    let scheduledStackId = void 0;\n    try {\n      const notificationData\
          \ = await s3.send(new import_client_s3.GetBucketNotificationConfigurationCommand({\
          \ Bucket: bucket.name, ExpectedBucketOwner: accountId }));\n      if (notificationData?.QueueConfigurations?.find((config)\
          \ => config.QueueArn === scanQueueArn && config.Events.includes(\"s3:ObjectCreated:*\"\
          )) !== void 0) {\n        realtimeEnabled = true;\n        realtimeEventNotificationDisablePossible\
          \ = true;\n      }\n      if (Array.isArray(notificationData?.TopicConfigurations))\
          \ {\n        await Promise.all(notificationData.TopicConfigurations.filter((config)\
          \ => config.Events.includes(\"s3:ObjectCreated:*\")).map(async (config)\
          \ => {\n          const paginatorListSubscriptionsByTopic = await (0, import_client_sns.paginateListSubscriptionsByTopic)({\
          \ client: sns, pageSize: 50 }, { TopicArn: config.TopicArn });\n       \
          \   for await (const page of paginatorListSubscriptionsByTopic) {\n    \
          \        if (page.Subscriptions.find((subscription) => subscription.Protocol\
          \ === \"sqs\" && subscription.Endpoint === scanQueueArn) !== void 0) {\n\
          \              realtimeEnabled = true;\n            }\n          }\n   \
          \     }));\n      }\n      if (notificationData?.EventBridgeConfiguration)\
          \ {\n        if (accountId !== coreAccountId) {\n          let crossAccoutRule\
          \ = false;\n          const paginatorListRuleNamesByTargetDefaultBus = await\
          \ paginateListRuleNamesByTarget({ client: eventbridge, pageSize: 10 }, {\
          \ TargetArn: `arn:${partition}:events:${region}:${coreAccountId}:event-bus/default`\
          \ });\n          for await (const page of paginatorListRuleNamesByTargetDefaultBus)\
          \ {\n            if (await checkEventBridgeRules(eventbridge, page.RuleNames,\
          \ bucket.name) === true) {\n              crossAccoutRule = true;\n    \
          \        }\n          }\n          const { Policy: defaultBusPolicyJson\
          \ } = await coreEventbridge.send(new import_client_eventbridge.DescribeEventBusCommand({\n\
          \            Name: \"default\"\n          }));\n          if (defaultBusPolicyJson\
          \ !== void 0) {\n            const defaultBusPolicy = JSON.parse(defaultBusPolicyJson);\n\
          \            if (defaultBusPolicy.Statement.find((s) => s?.Effect === \"\
          Allow\" && s?.Action === \"events:PutEvents\" && (s?.Principal?.AWS ===\
          \ accountId || s?.Principal === \"*\" && s?.Condition?.StringEquals[\"aws:PrincipalOrgID\"\
          ] === organizationId)) !== void 0) {\n              if (crossAccoutRule\
          \ === true) {\n                realtimeEnabled = true;\n              }\n\
          \            }\n          }\n        }\n        const paginatorListRuleNamesByTargetScanQueue\
          \ = await paginateListRuleNamesByTarget({ client: coreEventbridge, pageSize:\
          \ 10 }, { TargetArn: scanQueueArn });\n        for await (const page of\
          \ paginatorListRuleNamesByTargetScanQueue) {\n          if (await checkEventBridgeRules(coreEventbridge,\
          \ page.RuleNames, bucket.name) === true) {\n            realtimeEnabled\
          \ = true;\n          }\n        }\n      }\n      if (notificationData?.TopicConfigurations?.find((config)\
          \ => config.Events.filter((event) => event.startsWith(\"s3:ObjectCreated:\"\
          )).length > 0)) {\n        realtimeEventNotificationEnablePossible = false;\n\
          \      }\n      if (notificationData?.QueueConfigurations?.find((config)\
          \ => config.Events.filter((event) => event.startsWith(\"s3:ObjectCreated:\"\
          )).length > 0)) {\n        realtimeEventNotificationEnablePossible = false;\n\
          \      }\n      if (notificationData?.LambdaFunctionConfigurations?.find((config)\
          \ => config.Events.filter((event) => event.startsWith(\"s3:ObjectCreated:\"\
          )).length > 0)) {\n        realtimeEventNotificationEnablePossible = false;\n\
          \      }\n      if (notificationData?.EventBridgeConfiguration !== void\
          \ 0) {\n        realtimeEventNotificationEnablePossible = false;\n     \
          \ }\n    } catch (err) {\n      console.log(err);\n      bucket.errorMessage\
          \ = `Can not get details for bucket ${bucket.name}: ${err.name}`;\n    \
          \  realtimeEventNotificationEnablePossible = false;\n    }\n    const scheduledStacksIncludesBucket\
          \ = scheduledStacks.stacks.filter((scheduledStack) => includesBucket(scheduledStack,\
          \ bucket.name));\n    if (scheduledStacksIncludesBucket.length > 0) {\n\
          \      scheduledEnabled = true;\n      scheduledStackId = scheduledStacksIncludesBucket[0].id;\n\
          \    }\n    const scheduledStacksHasBucket = scheduledStacks.stacks.filter((scheduledStack)\
          \ => hasBucket(scheduledStack, bucket.name));\n    if (scheduledStacksHasBucket.length\
          \ === 1) {\n      scheduledEnabled = true;\n      scheduledStackDisablePossible\
          \ = true;\n      scheduledStackId = scheduledStacksHasBucket[0].id;\n  \
          \  }\n    return {\n      ...bucket,\n      realtimeEnabled,\n      realtimeEventNotificationEnablePossible,\n\
          \      realtimeEventNotificationDisablePossible,\n      scheduledEnabled,\n\
          \      scheduledStackDisablePossible,\n      scheduledStackId\n    };\n\
          \  } else {\n    return null;\n  }\n}\nasync function getScheduledStacks(ssm2,\
          \ cloudformation2, coreStackName) {\n  const paginatorGetParametersByPath\
          \ = await (0, import_client_ssm.paginateGetParametersByPath)({ client: ssm2\
          \ }, { Recursive: true, Path: `/bucketAV/${coreStackName}/AddOn/scheduled-bucket-scan/`\
          \ });\n  const stacks = [];\n  for await (const page of paginatorGetParametersByPath)\
          \ {\n    const scheduledStackNames = page.Parameters.filter((p) => p.Name.endsWith(\"\
          /Version\")).map((p) => p.Name.split(\"/\")[5]);\n    const describeStacksDataList\
          \ = await Promise.all(scheduledStackNames.map((stackName) => cloudformation2.send(new\
          \ import_client_cloudformation.DescribeStacksCommand({ StackName: stackName\
          \ }))));\n    describeStacksDataList.forEach((describeStacksData) => {\n\
          \      const stack = {\n        name: describeStacksData.Stacks[0].StackName,\n\
          \        id: describeStacksData.Stacks[0].StackId,\n        params: describeStacksData.Stacks[0].Parameters?.reduce((acc,\
          \ param) => {\n          acc[param.ParameterKey] = param.ParameterValue;\n\
          \          return acc;\n        }, {}) || {},\n        outputs: describeStacksData.Stacks[0].Outputs?.reduce((acc,\
          \ output) => {\n          acc[output.OutputKey] = output.OutputValue;\n\
          \          return acc;\n        }, {}) || {}\n      };\n      if (stack.params.BucketAVStackName\
          \ === coreStackName && stack.outputs.AddOn === \"scheduled-bucket-scan\"\
          ) {\n        stacks.push(stack);\n      }\n    });\n  }\n  return {\n  \
          \  stacks\n  };\n}\nasync function getBucket(s3, ssm2, cloudformation2,\
          \ sns, eventbridge, coreEventbridge, partition, region, accountId, organizationId,\
          \ coreAccountId, coreStackName, scanQueueArn, bucketName) {\n  const scheduledStacks\
          \ = await getScheduledStacks(ssm2, cloudformation2, coreStackName);\n  const\
          \ bucket = await enrichBucket(s3, sns, eventbridge, coreEventbridge, partition,\
          \ region, accountId, organizationId, coreAccountId, coreStackName, scanQueueArn,\
          \ scheduledStacks, bucketName);\n  if (bucket === null) {\n    throw new\
          \ Error(\"bucket region does not match region\");\n  } else {\n    return\
          \ bucket;\n  }\n}\nasync function listBuckets(s3, ssm2, cloudformation2,\
          \ sns, eventbridge, coreEventbridge, partition, region, accountId, organizationId,\
          \ coreAccountId, coreStackName, scanQueueArn) {\n  const listBucketsData\
          \ = await s3.send(new import_client_s3.ListBucketsCommand({}));\n  const\
          \ scheduledStacks = await getScheduledStacks(ssm2, cloudformation2, coreStackName);\n\
          \  const buckets = await Promise.all(listBucketsData.Buckets.map((bucket)\
          \ => enrichBucket(s3, sns, eventbridge, coreEventbridge, partition, region,\
          \ accountId, organizationId, coreAccountId, coreStackName, scanQueueArn,\
          \ scheduledStacks, bucket.Name)));\n  return buckets.filter((bucket) =>\
          \ bucket !== null);\n}\nfunction generateAccountConnectionId(partition,\
          \ region, accountId) {\n  return `${partition}:${region}:${accountId}`;\n\
          }\nvar MAX_S3_COPY_SIZE = 5 * 1024 * 1024 * 1024;\nfunction generateRoleArn(partition,\
          \ accountId, roleName) {\n  return `arn:${partition}:iam::${accountId}:role/${roleName}`;\n\
          }\nfunction generateRoleArnFromItem(accountConnectionItem) {\n  return generateRoleArn(accountConnectionItem.partition.S,\
          \ accountConnectionItem.account_id.S, accountConnectionItem.role_name.S);\n\
          }\nfunction generateExternalId(stackId) {\n  return stackId.split(\"/\"\
          )[2];\n}\nfunction generateExternalIdFromItem(accountConnectionItem) {\n\
          \  return generateExternalId(accountConnectionItem.stack_id.S);\n}\nasync\
          \ function cfnCustomResourceSuccess(event, physicalResourceId, optionalData)\
          \ {\n  const response = await fetch(event.ResponseURL, {\n    method: \"\
          PUT\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n \
          \   },\n    body: JSON.stringify({\n      Status: \"SUCCESS\",\n      PhysicalResourceId:\
          \ physicalResourceId,\n      StackId: event.StackId,\n      RequestId: event.RequestId,\n\
          \      LogicalResourceId: event.LogicalResourceId,\n      ...optionalData\
          \ !== void 0 && { Data: optionalData }\n    })\n  });\n  if (response.status\
          \ !== 200) {\n    console.log(\"response status\", response.status);\n \
          \   console.log(\"response\", await response.text());\n    throw new Error(\"\
          unexpected status code\");\n  }\n}\nasync function cfnCustomResourceFailed(event,\
          \ physicalResourceId, optionalReason) {\n  const response = await fetch(event.ResponseURL,\
          \ {\n    method: \"PUT\",\n    headers: {\n      \"Content-Type\": \"application/json\"\
          \n    },\n    body: JSON.stringify({\n      Status: \"FAILED\",\n      ...optionalReason\
          \ !== void 0 && { Reason: optionalReason },\n      PhysicalResourceId: physicalResourceId,\n\
          \      StackId: event.StackId,\n      RequestId: event.RequestId,\n    \
          \  LogicalResourceId: event.LogicalResourceId\n    })\n  });\n  if (response.status\
          \ !== 200) {\n    console.log(\"response status\", response.status);\n \
          \   console.log(\"response\", await response.text());\n    throw new Error(\"\
          unexpected status code\");\n  }\n}\n\n// lambda/refresh-bucket-cache.js\n\
          var TTL_IN_SECONDS = 3600;\nvar ssm = new import_client_ssm2.SSMClient({\
          \ apiVersion: \"2014-11-06\" });\nvar cloudformation = new import_client_cloudformation2.CloudFormationClient({\
          \ apiVersion: \"2006-03-01\", maxAttempts: 10 });\nvar dynamodb = new import_client_dynamodb2.DynamoDBClient({\
          \ apiVersion: \"2012-08-10\" });\nasync function cacheBucket(partition,\
          \ region, accountId, { accountConnectionId, roleArn, externalId }, ttl,\
          \ bucket) {\n  const bucketCacheItem = {\n    bucket_name: { S: bucket.name\
          \ },\n    bucket_account_id: { S: bucket.accountId },\n    bucket_realtime_enabled:\
          \ { BOOL: bucket.realtimeEnabled },\n    bucket_realtime_event_notification_disable_possible:\
          \ { BOOL: bucket.realtimeEventNotificationDisablePossible },\n    bucket_realtime_event_notification_enable_possible:\
          \ { BOOL: bucket.realtimeEventNotificationEnablePossible },\n    bucket_scheduled_enabled:\
          \ { BOOL: bucket.scheduledEnabled },\n    bucket_scheduled_stack_disable_possible:\
          \ { BOOL: bucket.scheduledStackDisablePossible },\n    partition: { S: partition\
          \ },\n    region: { S: region },\n    account_id: { S: accountId },\n  \
          \  ttl: { N: ttl.toString() }\n  };\n  if (bucket.organizationId !== void\
          \ 0) {\n    bucketCacheItem.bucket_organization_id = { S: bucket.organizationId\
          \ };\n  }\n  if (accountConnectionId !== void 0) {\n    bucketCacheItem.account_connection_id\
          \ = { S: accountConnectionId };\n    bucketCacheItem.role_arn = { S: roleArn\
          \ };\n    bucketCacheItem.external_id = { S: externalId };\n  }\n  if (bucket.errorMessage\
          \ !== void 0) {\n    bucketCacheItem.bucket_error_message = { S: bucket.errorMessage\
          \ };\n  }\n  if (bucket.region !== void 0) {\n    bucketCacheItem.bucket_region\
          \ = { S: bucket.region };\n  }\n  if (bucket.scheduledStackId !== void 0)\
          \ {\n    bucketCacheItem.bucket_scheduled_stack_id = { S: bucket.scheduledStackId\
          \ };\n  }\n  await dynamodb.send(new import_client_dynamodb2.PutItemCommand({\n\
          \    TableName: `${process.env.CORE_STACK_NAME}-BucketCache`,\n    Item:\
          \ bucketCacheItem\n  }));\n}\nfunction getCredentials(accountConnectionId,\
          \ roleArn, externalId) {\n  if (accountConnectionId !== void 0 && roleArn\
          \ !== void 0 && externalId !== void 0) {\n    return (0, import_credential_providers2.fromTemporaryCredentials)({\n\
          \      params: {\n        RoleArn: roleArn,\n        ExternalId: externalId,\n\
          \        RoleSessionName: \"bucketav\",\n        DurationSeconds: 3600\n\
          \      }\n    });\n  } else {\n    return (0, import_credential_providers2.fromNodeProviderChain)();\n\
          \  }\n}\nfunction generateTtl() {\n  return Math.floor(Date.now() / 1e3)\
          \ + TTL_IN_SECONDS;\n}\nasync function refreshBucket(partition, region,\
          \ accountId, coreAccountId, coreStackName, scanQueueArn, bucketName) {\n\
          \  const accountConnectionId = generateAccountConnectionId(partition, region,\
          \ accountId);\n  const accountConnectionData = await dynamodb.send(new import_client_dynamodb2.GetItemCommand({\n\
          \    TableName: `${coreStackName}-AccountConnection`,\n    Key: {\n    \
          \  account_connection_id: { S: accountConnectionId }\n    },\n    ConsistentRead:\
          \ true\n  }));\n  let accountConnection = {};\n  let credentials;\n  if\
          \ (accountConnectionData.Item !== void 0) {\n    const roleArn = generateRoleArnFromItem(accountConnectionData.Item);\n\
          \    const externalId = generateExternalIdFromItem(accountConnectionData.Item);\n\
          \    credentials = getCredentials(accountConnectionId, roleArn, externalId);\n\
          \    accountConnection.accountConnectionId = accountConnectionId;\n    accountConnection.roleArn\
          \ = roleArn;\n    accountConnection.externalId = externalId;\n    accountConnection.organizationId\
          \ = accountConnectionData.Item.organization_id?.S;\n  } else {\n    accountConnection.organizationId\
          \ = await fetchCachedOrganizationId(ssm, coreStackName);\n    credentials\
          \ = getCredentials(void 0, void 0, void 0);\n  }\n  const s3 = new import_client_s33.S3Client({\
          \ apiVersion: \"2006-03-01\", credentials });\n  const sns = new import_client_sns2.SNSClient({\
          \ apiVersion: \"2010-03-31\", credentials });\n  const eventbridge = new\
          \ import_client_eventbridge2.EventBridgeClient({ apiVersion: \"2015-10-07\"\
          , credentials });\n  const coreEventbridge = new import_client_eventbridge2.EventBridgeClient({\
          \ apiVersion: \"2015-10-07\" });\n  const bucket = await getBucket(s3, ssm,\
          \ cloudformation, sns, eventbridge, coreEventbridge, partition, region,\
          \ accountId, accountConnection.organizationId, coreAccountId, coreStackName,\
          \ scanQueueArn, bucketName);\n  await cacheBucket(partition, region, accountId,\
          \ accountConnection, generateTtl(), bucket);\n}\nasync function refreshAccount2(partition,\
          \ region, accountId, { accountConnectionId, roleArn, externalId, organizationId\
          \ }, ttl, coreAccountId, coreStackName, scanQueueArn) {\n  const credentials\
          \ = getCredentials(accountConnectionId, roleArn, externalId);\n  const s3\
          \ = new import_client_s33.S3Client({ apiVersion: \"2006-03-01\", credentials\
          \ });\n  const sns = new import_client_sns2.SNSClient({ apiVersion: \"2010-03-31\"\
          , credentials });\n  const eventbridge = new import_client_eventbridge2.EventBridgeClient({\
          \ apiVersion: \"2015-10-07\", credentials });\n  const coreEventbridge =\
          \ new import_client_eventbridge2.EventBridgeClient({ apiVersion: \"2015-10-07\"\
          \ });\n  const buckets = await listBuckets(s3, ssm, cloudformation, sns,\
          \ eventbridge, coreEventbridge, partition, region, accountId, organizationId,\
          \ coreAccountId, coreStackName, scanQueueArn);\n  for (const bucket of buckets)\
          \ {\n    await cacheBucket(partition, region, accountId, { accountConnectionId,\
          \ roleArn, externalId }, ttl, bucket);\n  }\n}\nasync function refreshAccount(partition,\
          \ region, accountId, coreAccountId, coreStackName, scanQueueArn) {\n  const\
          \ accountConnectionId = generateAccountConnectionId(partition, region, accountId);\n\
          \  const accountConnectionData = await dynamodb.send(new import_client_dynamodb2.GetItemCommand({\n\
          \    TableName: `${coreStackName}-AccountConnection`,\n    Key: {\n    \
          \  account_connection_id: { S: accountConnectionId }\n    },\n    ConsistentRead:\
          \ true\n  }));\n  let accountConnection = {};\n  if (accountConnectionData.Item\
          \ !== void 0) {\n    const roleArn = generateRoleArnFromItem(accountConnectionData.Item);\n\
          \    const externalId = generateExternalIdFromItem(accountConnectionData.Item);\n\
          \    accountConnection.accountConnectionId = accountConnectionId;\n    accountConnection.roleArn\
          \ = roleArn;\n    accountConnection.externalId = externalId;\n    accountConnection.organizationId\
          \ = accountConnectionData.Item.organization_id?.S;\n  } else {\n    accountConnection.organizationId\
          \ = await fetchCachedOrganizationId(ssm, coreStackName);\n  }\n  return\
          \ refreshAccount2(partition, region, accountId, accountConnection, generateTtl(),\
          \ coreAccountId, coreStackName, scanQueueArn);\n}\nasync function refreshCoreAccount(ttl)\
          \ {\n  const organizationId = await fetchCachedOrganizationId(ssm, process.env.CORE_STACK_NAME);\n\
          \  await refreshAccount2(\"aws\", process.env.AWS_REGION, process.env.AWS_ACCOUNT_ID,\
          \ { organizationId }, ttl, process.env.AWS_ACCOUNT_ID, process.env.CORE_STACK_NAME,\
          \ process.env.SCAN_QUEUE_ARN);\n}\nasync function handler(event, context)\
          \ {\n  console.log(`Invoke: ${JSON.stringify(event)} ${JSON.stringify(context)}`);\n\
          \  const ttl = generateTtl();\n  if (\"RequestType\" in event) {\n    if\
          \ (event.RequestType === \"Create\" || event.RequestType === \"Update\"\
          ) {\n      try {\n        await refreshCoreAccount(ttl);\n        await\
          \ cfnCustomResourceSuccess(event, process.env.CORE_STACK_NAME, {});\n  \
          \    } catch (err) {\n        await cfnCustomResourceFailed(event, process.env.CORE_STACK_NAME,\
          \ err.message);\n      }\n    } else if (event.RequestType === \"Delete\"\
          ) {\n      await cfnCustomResourceSuccess(event, process.env.CORE_STACK_NAME,\
          \ {});\n    } else {\n      throw new Error(\"unsupported request type\"\
          );\n    }\n  } else {\n    if (\"eof\" in event) {\n      const scanParams\
          \ = {\n        TableName: `${process.env.CORE_STACK_NAME}-AccountConnection`,\n\
          \        Limit: 5,\n        ConsistentRead: true\n      };\n      if (\"\
          exclusiveStartKey\" in event) {\n        scanParams.ExclusiveStartKey =\
          \ event.exclusiveStartKey;\n      }\n      const scanData = await dynamodb.send(new\
          \ import_client_dynamodb2.ScanCommand(scanParams));\n      for (const accountConnectionItem\
          \ of scanData.Items) {\n        const accountConnectionId = accountConnectionItem.account_connection_id.S;\n\
          \        const roleArn = generateRoleArnFromItem(accountConnectionItem);\n\
          \        const externalId = generateExternalIdFromItem(accountConnectionItem);\n\
          \        const organizationId = accountConnectionItem.organization_id?.S;\n\
          \        await refreshAccount2(accountConnectionItem.partition.S, accountConnectionItem.region.S,\
          \ accountConnectionItem.account_id.S, { accountConnectionId, roleArn, externalId,\
          \ organizationId }, ttl, process.env.AWS_ACCOUNT_ID, process.env.CORE_STACK_NAME,\
          \ process.env.SCAN_QUEUE_ARN);\n      }\n      if (\"LastEvaluatedKey\"\
          \ in scanData) {\n        return {\n          exclusiveStartKey: scanData.LastEvaluatedKey,\n\
          \          eof: false\n        };\n      } else {\n        return {\n  \
          \        eof: true\n        };\n      }\n    } else {\n      await refreshCoreAccount(ttl);\n\
          \      return {\n        eof: false\n      };\n    }\n  }\n}\n// Annotate\
          \ the CommonJS export names for ESM import in node:\n0 && (module.exports\
          \ = {\n  handler,\n  refreshAccount,\n  refreshBucket\n});\n"
      Environment:
        Variables:
          AWS_ACCOUNT_ID: !Ref 'AWS::AccountId'
          AWS_PARTITION: !Ref 'AWS::Partition'
          CORE_STACK_NAME: !Ref 'AWS::StackName'
          SCAN_QUEUE_ARN: !GetAtt [ScanQueue, Arn]
      Handler: index.handler
      MemorySize: 1769
      Role: !GetAtt [RefreshBucketCacheRole, Arn]
      Runtime: nodejs20.x
      Timeout: 900
    Condition: HasCrossAccount
  RefreshBucketCacheLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join ['', [/aws/lambda/, !Ref 'RefreshBucketCacheFunction']]
      RetentionInDays: !Ref 'LogsRetentionInDays'
    Condition: HasCrossAccount
  RefreshBucketCachePolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Statement:
        - Effect: Allow
          Action:
          - logs:CreateLogStream
          - logs:PutLogEvents
          Resource: !GetAtt [RefreshBucketCacheLogGroup, Arn]
      PolicyName: logs
      Roles:
      - !Ref 'RefreshBucketCacheRole'
    Condition: HasCrossAccount
  RefreshBucketCacheStateMachineRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: states.amazonaws.com
          Action: sts:AssumeRole
      PermissionsBoundary: !If [HasPermissionsBoundary, !Ref 'PermissionsBoundary',
        !Ref 'AWS::NoValue']
      Policies:
      - PolicyDocument:
          Statement:
          - Effect: Allow
            Action: lambda:InvokeFunction
            Resource: !GetAtt [RefreshBucketCacheFunction, Arn]
        PolicyName: states
    Condition: HasCrossAccount
  RefreshBucketCacheStateMachine:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      Definition:
        Comment: bucketAV (refresh bucket cache).
        TimeoutSeconds: 1800
        StartAt: RefreshBucketCache
        Version: '1.0'
        States:
          RefreshBucketCache:
            Type: Task
            Resource: !GetAtt [RefreshBucketCacheFunction, Arn]
            Retry:
            - ErrorEquals:
              - States.TaskFailed
              IntervalSeconds: 2
              MaxAttempts: 10
              BackoffRate: 2
            Next: CheckEndOfPage
          CheckEndOfPage:
            Type: Choice
            Choices:
            - Variable: $.eof
              BooleanEquals: true
              Next: Done
            Default: RefreshBucketCache
          Done:
            Type: Succeed
      RoleArn: !GetAtt [RefreshBucketCacheStateMachineRole, Arn]
      StateMachineName: !Join ['', [!Ref 'AWS::StackName', -refresh-bucket-cache]]
    DependsOn:
    - RefreshBucketCachePolicy
    Condition: HasCrossAccount
  RefreshBucketCacheStateMachineAlarmExecutionsFailed:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmActions:
      - !Ref 'InfrastructureAlarmsTopic'
      AlarmDescription: !Join ['', ['Refresh bucket cache failed (state machine ',
          !Ref 'RefreshBucketCacheStateMachine', '). Please follow https://bucketav.com/help/operations/monitoring-alerting.html#refreshbucketcachestatemachinealarmexecutionsfailed']]
      ComparisonOperator: GreaterThanThreshold
      Dimensions:
      - Name: StateMachineArn
        Value: !Ref 'RefreshBucketCacheStateMachine'
      EvaluationPeriods: 1
      MetricName: ExecutionsFailed
      Namespace: AWS/States
      Period: 300
      Statistic: Sum
      Threshold: 0
      TreatMissingData: notBreaching
    Condition: HasCrossAccount
  RefreshBucketCacheStateMachineAlarmExecutionsTimedOut:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmActions:
      - !Ref 'InfrastructureAlarmsTopic'
      AlarmDescription: !Join ['', ['Refresh bucket cache timed out(state machine ',
          !Ref 'RefreshBucketCacheStateMachine', '). Please follow https://bucketav.com/help/operations/monitoring-alerting.html#refreshbucketcachestatemachinealarmexecutionstimedout']]
      ComparisonOperator: GreaterThanThreshold
      Dimensions:
      - Name: StateMachineArn
        Value: !Ref 'RefreshBucketCacheStateMachine'
      EvaluationPeriods: 1
      MetricName: ExecutionsTimedOut
      Namespace: AWS/States
      Period: 300
      Statistic: Sum
      Threshold: 0
      TreatMissingData: notBreaching
    Condition: HasCrossAccount
  RefreshBucketCacheCronRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: events.amazonaws.com
          Action: sts:AssumeRole
      PermissionsBoundary: !If [HasPermissionsBoundary, !Ref 'PermissionsBoundary',
        !Ref 'AWS::NoValue']
      Policies:
      - PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action: states:StartExecution
            Resource: !Ref 'RefreshBucketCacheStateMachine'
        PolicyName: events
    Condition: HasCrossAccount
  RefreshBucketCacheCron:
    Type: AWS::Events::Rule
    Properties:
      ScheduleExpression: rate(30 minutes)
      Targets:
      - Arn: !Ref 'RefreshBucketCacheStateMachine'
        Id: states
        Input: '{}'
        RoleArn: !GetAtt [RefreshBucketCacheCronRole, Arn]
    Condition: HasCrossAccount
  RefreshBucketCache:
    Type: Custom::RefreshBucketCache
    Properties:
      ServiceToken: !GetAtt [RefreshBucketCacheFunction, Arn]
      Version: 2.0.0
    DependsOn:
    - RefreshBucketCachePolicy
    - RefreshBucketCacheRole
    - RefreshServiceDiscovery
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Condition: HasCrossAccount
  RefreshBucketCacheRule:
    Type: AWS::Events::Rule
    Properties:
      EventPattern:
        detail-type:
        - AWS API Call via CloudTrail
        detail:
          eventSource:
          - s3.amazonaws.com
          - events.amazonaws.com
          eventName:
          - CreateBucket
          - DeleteBucket
          - PutBucketNotification
          - PutBucketNotificationConfiguration
          - PutRule
          - DeleteRule
          - PutTargets
          - RemoveTargets
          - EnableRule
          - DisableRule
          - PutPermission
          - RemovePermission
      Targets:
      - Arn: !Ref 'AccountConnectionTopic'
        Id: sns
        InputTransformer:
          InputTemplate: !Join ['', ['{"action": "refreshAccount", "partition": "',
              !Ref 'AWS::Partition', '", "region": "', !Ref 'AWS::Region', '", "accountId":
                "', !Ref 'AWS::AccountId', '"}']]
    Condition: HasCrossAccount
  SignaturesAgeAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmActions:
      - !Ref 'InfrastructureAlarmsTopic'
      AlarmDescription: Signatures are older than 7 days. Are signature updates working?
        Please follow https://bucketav.com/help/operations/monitoring-alerting.html#signaturesagealarm
      ComparisonOperator: GreaterThanThreshold
      EvaluationPeriods: 1
      MetricName: signatures_age
      Namespace: !Ref 'AWS::StackName'
      Period: 600
      Statistic: Maximum
      Threshold: 604800
      TreatMissingData: notBreaching
  Logs:
    Type: AWS::Logs::LogGroup
    Properties:
      RetentionInDays: !Ref 'LogsRetentionInDays'
  ScanIAMRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: ec2.amazonaws.com
          Action: sts:AssumeRole
      ManagedPolicyArns: !If [HasManagedPolicyArns, !Split [',', !Ref 'ManagedPolicyArns'],
        !Ref 'AWS::NoValue']
      PermissionsBoundary: !If [HasPermissionsBoundary, !Ref 'PermissionsBoundary',
        !Ref 'AWS::NoValue']
      Policies:
      - PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action: s3:GetObject*
            Resource: !Ref 'S3ObjectRestriction'
          - Effect: Allow
            Action: s3:ListBucket*
            Resource: !Ref 'S3BucketRestriction'
          - Effect: Allow
            Action: kms:Decrypt
            Resource: !Ref 'KMSKeyRestriction'
        PolicyName: s3read
      - PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - sqs:DeleteMessage
            - sqs:ReceiveMessage
            - sqs:ChangeMessageVisibility
            - sqs:ChangeMessageVisibilityBatch
            - sqs:DeleteMessageBatch
            Resource: !GetAtt [ScanQueue, Arn]
          - Effect: Allow
            Action: sns:Publish
            Resource: !Ref 'FindingsTopic'
        PolicyName: core
      - !If [HasCrossAccount, {PolicyName: crossaccount, PolicyDocument: {Version: '2012-10-17',
            Statement: [{Effect: Allow, Action: 'dynamodb:GetItem', Resource: !GetAtt [
                  BucketCacheTable, Arn]}, {Effect: Allow, Action: 'sts:AssumeRole',
                Resource: !Join ['', ['arn:', !Ref 'AWS::Partition', ':iam::*:role/',
                    !Ref 'AWS::StackName', -AccountConnection]]}]}}, !Ref 'AWS::NoValue']
      - !If [HasDeleteInfectedFiles, {PolicyName: s3deletev2, PolicyDocument: {Version: '2012-10-17',
            Statement: [{Effect: Allow, Action: 's3:DeleteObject*', Resource: !Ref 'S3ObjectRestriction'}]}},
        !Ref 'AWS::NoValue']
      - !If [HasTagFiles, {PolicyName: s3objecttagv2, PolicyDocument: {Version: '2012-10-17',
            Statement: [{Effect: Allow, Action: ['s3:GetObjectTagging', 's3:GetObjectVersionTagging',
                  's3:PutObjectTagging', 's3:PutObjectVersionTagging'], Resource: !Ref 'S3ObjectRestriction'}]}},
        !Ref 'AWS::NoValue']
      - PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action: cloudwatch:PutMetricData
            Resource: '*'
            Condition:
              StringEquals:
                cloudwatch:namespace: !Ref 'AWS::StackName'
          - Effect: Allow
            Action:
            - logs:CreateLogGroup
            - logs:CreateLogStream
            - logs:PutLogEvents
            - logs:DescribeLogStreams
            Resource: !GetAtt [Logs, Arn]
          - Effect: Allow
            Action: logs:DescribeLogGroups
            Resource: '*'
        PolicyName: cloudwatch
      - PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action: autoscaling:DescribeAutoScalingInstances
            Resource: '*'
          - Effect: Allow
            Action:
            - autoscaling:CompleteLifecycleAction
            - autoscaling:RecordLifecycleActionHeartbeat
            Resource: '*'
            Condition:
              StringEquals:
                autoscaling:ResourceTag/aws:cloudformation:stack-id: !Ref 'AWS::StackId'
        PolicyName: asg
      - !If [HasSystemsManagerAccess, {PolicyName: ssmv2, PolicyDocument: {Version: '2012-10-17',
            Statement: [{Effect: Allow, Action: ['ssm:UpdateInstanceInformation',
                  'ssm:ListAssociations', 'ssm:ListInstanceAssociations', 'ssmmessages:CreateControlChannel',
                  'ssmmessages:CreateDataChannel', 'ssmmessages:OpenControlChannel',
                  'ssmmessages:OpenDataChannel', 'ec2messages:AcknowledgeMessage',
                  'ec2messages:DeleteMessage', 'ec2messages:FailMessage', 'ec2messages:GetEndpoint',
                  'ec2messages:GetMessages', 'ec2messages:SendReply'], Resource: '*'}]}},
        !Ref 'AWS::NoValue']
  ScanInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
      - !Ref 'ScanIAMRole'
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: !Ref 'VpcCidrBlock'
      EnableDnsHostnames: true
      EnableDnsSupport: true
      InstanceTenancy: default
      Tags:
      - Key: Name
        Value: !Ref 'AWS::StackName'
  FlowLogLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      RetentionInDays: !Ref 'FlowLogRetentionInDays'
    Condition: HasFlowLogs
  FlowLogRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: vpc-flow-logs.amazonaws.com
          Action: sts:AssumeRole
      PermissionsBoundary: !If [HasPermissionsBoundary, !Ref 'PermissionsBoundary',
        !Ref 'AWS::NoValue']
      Policies:
      - PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - logs:CreateLogStream
            - logs:PutLogEvents
            - logs:DescribeLogGroups
            - logs:DescribeLogStreams
            Resource: !GetAtt [FlowLogLogGroup, Arn]
        PolicyName: flowlogs-policy
    Condition: HasFlowLogs
  FlowLog:
    Type: AWS::EC2::FlowLog
    Properties:
      DeliverLogsPermissionArn: !GetAtt [FlowLogRole, Arn]
      LogGroupName: !Ref 'FlowLogLogGroup'
      ResourceId: !Ref 'VPC'
      ResourceType: VPC
      TrafficType: ALL
    Condition: HasFlowLogs
  NetworkAclPrivate:
    Type: AWS::EC2::NetworkAcl
    Properties:
      Tags:
      - Key: Name
        Value: !Join ['', [!Ref 'AWS::StackName', ': private']]
      VpcId: !Ref 'VPC'
  SubnetAPrivate:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select [0, !GetAZs '']
      CidrBlock: !Select [1, !Cidr [!GetAtt [VPC, CidrBlock], 4, !Ref 'VpcSubnetCidrBits']]
      Tags:
      - Key: Name
        Value: !Join ['', [!Ref 'AWS::StackName', ': A private']]
      VpcId: !Ref 'VPC'
  SubnetBPrivate:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select [1, !GetAZs '']
      CidrBlock: !Select [3, !Cidr [!GetAtt [VPC, CidrBlock], 4, !Ref 'VpcSubnetCidrBits']]
      Tags:
      - Key: Name
        Value: !Join ['', [!Ref 'AWS::StackName', ': B private']]
      VpcId: !Ref 'VPC'
  RouteTableAPrivate:
    Type: AWS::EC2::RouteTable
    Properties:
      Tags:
      - Key: Name
        Value: !Join ['', [!Ref 'AWS::StackName', ': A private']]
      VpcId: !Ref 'VPC'
  RouteTableBPrivate:
    Type: AWS::EC2::RouteTable
    Properties:
      Tags:
      - Key: Name
        Value: !Join ['', [!Ref 'AWS::StackName', ': B private']]
      VpcId: !Ref 'VPC'
  RouteTableAssociationAPrivate:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref 'RouteTableAPrivate'
      SubnetId: !Ref 'SubnetAPrivate'
  RouteTableAssociationBPrivate:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref 'RouteTableBPrivate'
      SubnetId: !Ref 'SubnetBPrivate'
  SubnetNetworkAclAssociationAPrivate:
    Type: AWS::EC2::SubnetNetworkAclAssociation
    Properties:
      NetworkAclId: !Ref 'NetworkAclPrivate'
      SubnetId: !Ref 'SubnetAPrivate'
  SubnetNetworkAclAssociationBPrivate:
    Type: AWS::EC2::SubnetNetworkAclAssociation
    Properties:
      NetworkAclId: !Ref 'NetworkAclPrivate'
      SubnetId: !Ref 'SubnetBPrivate'
  NetworkAclEntryInPrivateAllowSSH:
    Type: AWS::EC2::NetworkAclEntry
    Properties:
      CidrBlock: !Ref 'SSHIngressCidrIp'
      Egress: false
      NetworkAclId: !Ref 'NetworkAclPrivate'
      PortRange:
        From: 22
        To: 22
      Protocol: 6
      RuleAction: allow
      RuleNumber: 60
    Condition: HasSSHIngressCidrIp
  NetworkAclEntryOutPrivateAllowEphemeral:
    Type: AWS::EC2::NetworkAclEntry
    Properties:
      CidrBlock: !Ref 'SSHIngressCidrIp'
      Egress: true
      NetworkAclId: !Ref 'NetworkAclPrivate'
      PortRange:
        From: 32768
        To: 65535
      Protocol: 6
      RuleAction: allow
      RuleNumber: 50
    Condition: HasSSHIngressCidrIp
  NetworkAclEntryOutPrivateAllowHTTP:
    Type: AWS::EC2::NetworkAclEntry
    Properties:
      CidrBlock: 0.0.0.0/0
      Egress: true
      NetworkAclId: !Ref 'NetworkAclPrivate'
      PortRange:
        From: 80
        To: 80
      Protocol: 6
      RuleAction: allow
      RuleNumber: 30
  NetworkAclEntryOutPrivateAllowHTTPS:
    Type: AWS::EC2::NetworkAclEntry
    Properties:
      CidrBlock: 0.0.0.0/0
      Egress: true
      NetworkAclId: !Ref 'NetworkAclPrivate'
      PortRange:
        From: 443
        To: 443
      Protocol: 6
      RuleAction: allow
      RuleNumber: 40
  NetworkAclEntryInPrivateAllowEphemeral:
    Type: AWS::EC2::NetworkAclEntry
    Properties:
      CidrBlock: 0.0.0.0/0
      Egress: false
      NetworkAclId: !Ref 'NetworkAclPrivate'
      PortRange:
        From: 32768
        To: 65535
      Protocol: 6
      RuleAction: allow
      RuleNumber: 51
  VPCEndpointForS3:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      RouteTableIds:
      - !Ref 'RouteTableAPrivate'
      - !Ref 'RouteTableBPrivate'
      ServiceName: !Join ['', [com.amazonaws., !Ref 'AWS::Region', .s3]]
      VpcId: !Ref 'VPC'
  VPCEndpointForDynamoDB:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      RouteTableIds:
      - !Ref 'RouteTableAPrivate'
      - !Ref 'RouteTableBPrivate'
      ServiceName: !Join ['', [com.amazonaws., !Ref 'AWS::Region', .dynamodb]]
      VpcId: !Ref 'VPC'
  ScanSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Join ['', [!Ref 'AWS::StackName', -scan]]
      VpcId: !Ref 'VPC'
  VPCEndpointSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Join ['', [!Ref 'AWS::StackName', -endpoint]]
      SecurityGroupEgress:
      - CidrIp: 127.0.0.1/32
        Description: Prevent default egress rule that allows egress traffic on all
          ports and IP protocols to any location.
        IpProtocol: '-1'
      SecurityGroupIngress:
      - FromPort: 443
        IpProtocol: tcp
        SourceSecurityGroupId: !Ref 'ScanSecurityGroup'
        ToPort: 443
      VpcId: !Ref 'VPC'
  VPCEndpointForSNS:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PrivateDnsEnabled: true
      SecurityGroupIds:
      - !Ref 'VPCEndpointSecurityGroup'
      ServiceName: !Join ['', [com.amazonaws., !Ref 'AWS::Region', .sns]]
      SubnetIds:
      - !Ref 'SubnetAPrivate'
      - !Ref 'SubnetBPrivate'
      VpcEndpointType: Interface
      VpcId: !Ref 'VPC'
  VPCEndpointForSQS:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PrivateDnsEnabled: true
      SecurityGroupIds:
      - !Ref 'VPCEndpointSecurityGroup'
      ServiceName: !Join ['', [com.amazonaws., !Ref 'AWS::Region', .sqs]]
      SubnetIds:
      - !Ref 'SubnetAPrivate'
      - !Ref 'SubnetBPrivate'
      VpcEndpointType: Interface
      VpcId: !Ref 'VPC'
  VPCEndpointForAutoScaling:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PrivateDnsEnabled: true
      SecurityGroupIds:
      - !Ref 'VPCEndpointSecurityGroup'
      ServiceName: !Join ['', [com.amazonaws., !Ref 'AWS::Region', .autoscaling]]
      SubnetIds:
      - !Ref 'SubnetAPrivate'
      - !Ref 'SubnetBPrivate'
      VpcEndpointType: Interface
      VpcId: !Ref 'VPC'
  VPCEndpointForCloudWatch1:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PrivateDnsEnabled: true
      SecurityGroupIds:
      - !Ref 'VPCEndpointSecurityGroup'
      ServiceName: !Join ['', [com.amazonaws., !Ref 'AWS::Region', .monitoring]]
      SubnetIds:
      - !Ref 'SubnetAPrivate'
      - !Ref 'SubnetBPrivate'
      VpcEndpointType: Interface
      VpcId: !Ref 'VPC'
  VPCEndpointForCloudWatch2:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PrivateDnsEnabled: true
      SecurityGroupIds:
      - !Ref 'VPCEndpointSecurityGroup'
      ServiceName: !Join ['', [com.amazonaws., !Ref 'AWS::Region', .logs]]
      SubnetIds:
      - !Ref 'SubnetAPrivate'
      - !Ref 'SubnetBPrivate'
      VpcEndpointType: Interface
      VpcId: !Ref 'VPC'
  VPCEndpointForCloudFormation:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PrivateDnsEnabled: true
      SecurityGroupIds:
      - !Ref 'VPCEndpointSecurityGroup'
      ServiceName: !Join ['', [com.amazonaws., !Ref 'AWS::Region', .cloudformation]]
      SubnetIds:
      - !Ref 'SubnetAPrivate'
      - !Ref 'SubnetBPrivate'
      VpcEndpointType: Interface
      VpcId: !Ref 'VPC'
  VPCEndpointForSTS:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PrivateDnsEnabled: true
      SecurityGroupIds:
      - !Ref 'VPCEndpointSecurityGroup'
      ServiceName: !Join ['', [com.amazonaws., !Ref 'AWS::Region', .sts]]
      SubnetIds:
      - !Ref 'SubnetAPrivate'
      - !Ref 'SubnetBPrivate'
      VpcEndpointType: Interface
      VpcId: !Ref 'VPC'
  VPCEndpointForSSM1:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PrivateDnsEnabled: true
      SecurityGroupIds:
      - !Ref 'VPCEndpointSecurityGroup'
      ServiceName: !Join ['', [com.amazonaws., !Ref 'AWS::Region', .ssm]]
      SubnetIds:
      - !Ref 'SubnetAPrivate'
      - !Ref 'SubnetBPrivate'
      VpcEndpointType: Interface
      VpcId: !Ref 'VPC'
  VPCEndpointForSSM2:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PrivateDnsEnabled: true
      SecurityGroupIds:
      - !Ref 'VPCEndpointSecurityGroup'
      ServiceName: !Join ['', [com.amazonaws., !Ref 'AWS::Region', .ssmmessages]]
      SubnetIds:
      - !Ref 'SubnetAPrivate'
      - !Ref 'SubnetBPrivate'
      VpcEndpointType: Interface
      VpcId: !Ref 'VPC'
  VPCEndpointForSSM3:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PrivateDnsEnabled: true
      SecurityGroupIds:
      - !Ref 'VPCEndpointSecurityGroup'
      ServiceName: !Join ['', [com.amazonaws., !Ref 'AWS::Region', .ec2messages]]
      SubnetIds:
      - !Ref 'SubnetAPrivate'
      - !Ref 'SubnetBPrivate'
      VpcEndpointType: Interface
      VpcId: !Ref 'VPC'
  ScanSecurityGroupInSSH:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      CidrIp: !Ref 'SSHIngressCidrIp'
      FromPort: 22
      GroupId: !Ref 'ScanSecurityGroup'
      IpProtocol: tcp
      ToPort: 22
    Condition: HasSSHIngressCidrIp
  ScanSecurityGroupOutVpcEndpoint:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      Description: Accessing AWS APIs (SNS, SQS, CloudWatch, ...) through VPC endpoints.
      DestinationSecurityGroupId: !Ref 'VPCEndpointSecurityGroup'
      FromPort: 443
      GroupId: !Ref 'ScanSecurityGroup'
      IpProtocol: tcp
      ToPort: 443
  ScanSecurityGroupOutS3Https:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      Description: Accessing Amazon S3 to download files, signature updates from bucketAV
        mirrors and patches from Amazon Linux repos.
      DestinationPrefixListId: !FindInMap [ManagedPrefixListMap, !Ref 'AWS::Region',
        PrefixListId]
      FromPort: 443
      GroupId: !Ref 'ScanSecurityGroup'
      IpProtocol: tcp
      ToPort: 443
  ScanSecurityGroupOutS3Http:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      Description: Accessing Amazon S3 to download patches from Amazon Linux repos.
      DestinationPrefixListId: !FindInMap [ManagedPrefixListMap, !Ref 'AWS::Region',
        PrefixListId]
      FromPort: 80
      GroupId: !Ref 'ScanSecurityGroup'
      IpProtocol: tcp
      ToPort: 80
  ScanSecurityGroupOutDynamoDBHttps:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      Description: Accessing Amazon DynamoDB to fetch information about linked AWS
        accounts and buckets.
      DestinationPrefixListId: !FindInMap [ManagedPrefixListDynamoDBMap, !Ref 'AWS::Region',
        PrefixListId]
      FromPort: 443
      GroupId: !Ref 'ScanSecurityGroup'
      IpProtocol: tcp
      ToPort: 443
  ScanLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateData:
        BlockDeviceMappings:
        - DeviceName: /dev/xvda
          Ebs:
            Encrypted: true
            VolumeSize: 32
            VolumeType: gp3
        IamInstanceProfile:
          Name: !Ref 'ScanInstanceProfile'
        ImageId: !FindInMap [RegionMap, !Ref 'AWS::Region', AMI]
        InstanceType: !Ref 'InstanceType'
        KeyName: !Ref 'KeyName'
        MetadataOptions:
          HttpTokens: required
        NetworkInterfaces:
        - AssociatePublicIpAddress: false
          DeviceIndex: 0
          Groups:
          - !Ref 'ScanSecurityGroup'
        UserData: !Base64
          Fn::Join:
          - ''
          - - '#!/bin/bash -ex

              trap ''/opt/aws/bin/cfn-signal -e 1 --stack '
            - !Ref 'AWS::StackName'
            - ' --resource ScanAutoScalingGroup --region '
            - !Ref 'AWS::Region'
            - ''' ERR

              if [[ "'
            - !Ref 'EnableCache'
            - "\" == \"false\" ]]; then\n  echo \"DisableCache yes\" >> /etc/clamd.d/scan.conf\n\
              fi\nsystemctl enable clamd@scan.service\nsystemctl start clamd@scan.service\n\
              IFS=\",\" read -r -a urls <<< \""
            - !Ref 'AdditionalDatabaseUrls'
            - '"

              for url in "${urls[@]}"; do echo "DatabaseCustomURL ${url}" >> /etc/freshclam.conf;
              done

              echo "DatabaseMirror https://bucketav-clamav-mirror-'
            - !Ref 'AWS::Region'
            - .s3.
            - !Ref 'AWS::Region'
            - '.amazonaws.com" >> /etc/freshclam.conf

              systemctl enable clamav-freshclam.service

              systemctl start clamav-freshclam.service

              cat <<"EOF" | tee /opt/bucketav/bucketav.conf > /dev/null

              mode: consumer

              platform: aws

              delete: '
            - !Ref 'DeleteInfectedFiles'
            - '

              report_clean: '
            - !Ref 'ReportCleanFiles'
            - '

              tag_files: '
            - !Ref 'TagFiles'
            - '

              tag_key: '''
            - !Ref 'TagKey'
            - '''

              region: '''
            - !Ref 'AWS::Region'
            - '''

              queue: '''
            - !Ref 'ScanQueue'
            - '''

              topic: '''
            - !Ref 'FindingsTopic'
            - '''

              stack_name: '''
            - !Ref 'AWS::StackName'
            - '''

              core_stack_name: '''
            - !Ref 'AWS::StackName'
            - '''

              cross_account: '
            - !If [HasCrossAccount, true, false]
            - '

              debug: false

              EOF

              chown ec2-user:ec2-user /opt/bucketav/bucketav.conf

              sed -e ''s/__LOG_GROUP_NAME__/'
            - !Ref 'Logs'
            - '/g'' -i /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json

              sed -e ''s/__NAMESPACE__/'
            - !Ref 'AWS::StackName'
            - '/g'' -i /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json

              systemctl enable amazon-cloudwatch-agent

              systemctl start amazon-cloudwatch-agent

              systemctl enable bucketav

              systemctl start bucketav

              if [[ "'
            - !Ref 'SystemsManagerAccess'
            - "\" == \"true\" ]]; then\n  systemctl enable amazon-ssm-agent\n  systemctl\
              \ start amazon-ssm-agent\nfi\n/opt/aws/bin/cfn-signal -e 0 --stack "
            - !Ref 'AWS::StackName'
            - ' --resource ScanAutoScalingGroup --region '
            - !Ref 'AWS::Region'
            - '

              '
  ScanAutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      CapacityRebalance: true
      LifecycleHookSpecificationList:
      - DefaultResult: CONTINUE
        HeartbeatTimeout: 432
        LifecycleHookName: bucketav_terminate_gracefully
        LifecycleTransition: autoscaling:EC2_INSTANCE_TERMINATING
      MaxSize: !Ref 'AutoScalingMaxSize'
      MetricsCollection:
      - Granularity: 1Minute
        Metrics:
        - GroupInServiceInstances
        - GroupDesiredCapacity
      MinSize: !Ref 'AutoScalingMinSize'
      MixedInstancesPolicy:
        InstancesDistribution:
          OnDemandAllocationStrategy: prioritized
          OnDemandBaseCapacity: !FindInMap [CapacityStrategyMap, !Ref 'CapacityStrategy',
            OnDemandBaseCapacity]
          OnDemandPercentageAboveBaseCapacity: !FindInMap [CapacityStrategyMap, !Ref 'CapacityStrategy',
            OnDemandPercentageAboveBaseCapacity]
          SpotAllocationStrategy: !If [HasRegionCaWest1, capacity-optimized, capacity-optimized-prioritized]
        LaunchTemplate:
          LaunchTemplateSpecification:
            LaunchTemplateId: !Ref 'ScanLaunchTemplate'
            Version: !GetAtt [ScanLaunchTemplate, LatestVersionNumber]
          Overrides:
          - InstanceType: !Ref 'InstanceType'
            WeightedCapacity: '1'
          - !If [HasAlternativeInstanceType, {InstanceType: !FindInMap [InstanceTypeMap,
                !Ref 'InstanceType', AlternativeInstanceType], WeightedCapacity: '1'},
            !Ref 'AWS::NoValue']
      Tags:
      - Key: Name
        PropagateAtLaunch: true
        Value: !Ref 'AWS::StackName'
      VPCZoneIdentifier:
      - !Ref 'SubnetAPrivate'
      - !Ref 'SubnetBPrivate'
    DependsOn:
    - NetworkAclEntryInPrivateAllowEphemeral
    - NetworkAclEntryOutPrivateAllowHTTP
    - NetworkAclEntryOutPrivateAllowHTTPS
    - VPCEndpointForAutoScaling
    - VPCEndpointForCloudFormation
    - VPCEndpointForCloudWatch1
    - VPCEndpointForCloudWatch2
    - VPCEndpointForDynamoDB
    - VPCEndpointForS3
    - VPCEndpointForSNS
    - VPCEndpointForSQS
    - VPCEndpointForSSM1
    - VPCEndpointForSSM2
    - VPCEndpointForSSM3
    - VPCEndpointForSTS
    UpdatePolicy:
      AutoScalingRollingUpdate:
        PauseTime: PT10M
        SuspendProcesses:
        - HealthCheck
        - ReplaceUnhealthy
        - AZRebalance
        - AlarmNotification
        - ScheduledActions
        WaitOnResourceSignals: true
  ScanScaleUp:
    Type: AWS::AutoScaling::ScalingPolicy
    Properties:
      AdjustmentType: ChangeInCapacity
      AutoScalingGroupName: !Ref 'ScanAutoScalingGroup'
      EstimatedInstanceWarmup: 300
      MetricAggregationType: Maximum
      PolicyType: StepScaling
      StepAdjustments:
      - MetricIntervalLowerBound: !If [HasAutoScalingMinSizeZero, 0, 10]
        MetricIntervalUpperBound: 25
        ScalingAdjustment: 1
      - MetricIntervalLowerBound: 25
        MetricIntervalUpperBound: 100
        ScalingAdjustment: 2
      - MetricIntervalLowerBound: 100
        MetricIntervalUpperBound: 400
        ScalingAdjustment: 4
      - MetricIntervalLowerBound: 400
        MetricIntervalUpperBound: 1600
        ScalingAdjustment: 8
      - MetricIntervalLowerBound: 1600
        MetricIntervalUpperBound: 6400
        ScalingAdjustment: 16
      - MetricIntervalLowerBound: 6400
        MetricIntervalUpperBound: 25600
        ScalingAdjustment: 32
      - MetricIntervalLowerBound: 25600
        ScalingAdjustment: 64
  FallbackLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateData:
        BlockDeviceMappings:
        - DeviceName: /dev/xvda
          Ebs:
            Encrypted: true
            VolumeSize: 32
            VolumeType: gp3
        IamInstanceProfile:
          Name: !Ref 'ScanInstanceProfile'
        ImageId: !FindInMap [RegionMap, !Ref 'AWS::Region', AMI]
        InstanceType: !Ref 'InstanceType'
        KeyName: !Ref 'KeyName'
        MetadataOptions:
          HttpTokens: required
        NetworkInterfaces:
        - AssociatePublicIpAddress: false
          DeviceIndex: 0
          Groups:
          - !Ref 'ScanSecurityGroup'
        UserData: !Base64
          Fn::Join:
          - ''
          - - '#!/bin/bash -ex

              trap ''/opt/aws/bin/cfn-signal -e 1 --stack '
            - !Ref 'AWS::StackName'
            - ' --resource FallbackAutoScalingGroup --region '
            - !Ref 'AWS::Region'
            - ''' ERR

              if [[ "'
            - !Ref 'EnableCache'
            - "\" == \"false\" ]]; then\n  echo \"DisableCache yes\" >> /etc/clamd.d/scan.conf\n\
              fi\nsystemctl enable clamd@scan.service\nsystemctl start clamd@scan.service\n\
              IFS=\",\" read -r -a urls <<< \""
            - !Ref 'AdditionalDatabaseUrls'
            - '"

              for url in "${urls[@]}"; do echo "DatabaseCustomURL ${url}" >> /etc/freshclam.conf;
              done

              echo "DatabaseMirror https://bucketav-clamav-mirror-'
            - !Ref 'AWS::Region'
            - .s3.
            - !Ref 'AWS::Region'
            - '.amazonaws.com" >> /etc/freshclam.conf

              systemctl enable clamav-freshclam.service

              systemctl start clamav-freshclam.service

              cat <<"EOF" | tee /opt/bucketav/bucketav.conf > /dev/null

              mode: consumer

              platform: aws

              delete: '
            - !Ref 'DeleteInfectedFiles'
            - '

              report_clean: '
            - !Ref 'ReportCleanFiles'
            - '

              tag_files: '
            - !Ref 'TagFiles'
            - '

              tag_key: '''
            - !Ref 'TagKey'
            - '''

              region: '''
            - !Ref 'AWS::Region'
            - '''

              queue: '''
            - !Ref 'ScanQueue'
            - '''

              topic: '''
            - !Ref 'FindingsTopic'
            - '''

              stack_name: '''
            - !Ref 'AWS::StackName'
            - '''

              core_stack_name: '''
            - !Ref 'AWS::StackName'
            - '''

              cross_account: '
            - !If [HasCrossAccount, true, false]
            - '

              debug: false

              EOF

              chown ec2-user:ec2-user /opt/bucketav/bucketav.conf

              sed -e ''s/__LOG_GROUP_NAME__/'
            - !Ref 'Logs'
            - '/g'' -i /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json

              sed -e ''s/__NAMESPACE__/'
            - !Ref 'AWS::StackName'
            - '/g'' -i /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json

              systemctl enable amazon-cloudwatch-agent

              systemctl start amazon-cloudwatch-agent

              systemctl enable bucketav

              systemctl start bucketav

              if [[ "'
            - !Ref 'SystemsManagerAccess'
            - "\" == \"true\" ]]; then\n  systemctl enable amazon-ssm-agent\n  systemctl\
              \ start amazon-ssm-agent\nfi\n/opt/aws/bin/cfn-signal -e 0 --stack "
            - !Ref 'AWS::StackName'
            - ' --resource FallbackAutoScalingGroup --region '
            - !Ref 'AWS::Region'
            - '

              '
    Condition: HasOnDemandFallback
  FallbackAutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      LaunchTemplate:
        LaunchTemplateId: !Ref 'FallbackLaunchTemplate'
        Version: !GetAtt [FallbackLaunchTemplate, LatestVersionNumber]
      LifecycleHookSpecificationList:
      - DefaultResult: CONTINUE
        HeartbeatTimeout: 432
        LifecycleHookName: bucketav_terminate_gracefully
        LifecycleTransition: autoscaling:EC2_INSTANCE_TERMINATING
      MaxSize: !Ref 'AutoScalingMaxSize'
      MetricsCollection:
      - Granularity: 1Minute
        Metrics:
        - GroupInServiceInstances
        - GroupDesiredCapacity
      MinSize: '0'
      Tags:
      - Key: Name
        PropagateAtLaunch: true
        Value: !Join ['', [!Ref 'AWS::StackName', -fallback]]
      VPCZoneIdentifier:
      - !Ref 'SubnetAPrivate'
      - !Ref 'SubnetBPrivate'
    DependsOn:
    - ScanAutoScalingGroup
    UpdatePolicy:
      AutoScalingRollingUpdate:
        PauseTime: PT10M
        SuspendProcesses:
        - HealthCheck
        - ReplaceUnhealthy
        - AZRebalance
        - AlarmNotification
        - ScheduledActions
        WaitOnResourceSignals: true
    Condition: HasOnDemandFallback
  SecurityHubIntegrationLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
      PermissionsBoundary: !If [HasPermissionsBoundary, !Ref 'PermissionsBoundary',
        !Ref 'AWS::NoValue']
      Policies:
      - PolicyDocument:
          Statement:
          - Effect: Allow
            Action: securityhub:BatchImportFindings
            Resource: '*'
            Condition:
              StringEquals:
                securityhub:TargetAccount: !Ref 'AWS::AccountId'
        PolicyName: securityhub
    Condition: HasSecurityHubIntegration
  SecurityHubIntegrationLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: "var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n\
          var __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp =\
          \ Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n\
          \  for (var name in all)\n    __defProp(target, name, { get: all[name],\
          \ enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) =>\
          \ {\n  if (from && typeof from === \"object\" || typeof from === \"function\"\
          ) {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to,\
          \ key) && key !== except)\n        __defProp(to, key, { get: () => from[key],\
          \ enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n\
          \  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({},\
          \ \"__esModule\", { value: true }), mod);\n\n// lambda/integration-security-hub.js\n\
          var integration_security_hub_exports = {};\n__export(integration_security_hub_exports,\
          \ {\n  handler: () => handler\n});\nmodule.exports = __toCommonJS(integration_security_hub_exports);\n\
          var import_client_securityhub = require(\"@aws-sdk/client-securityhub\"\
          );\nvar securityhub = new import_client_securityhub.SecurityHubClient({\
          \ apiVersion: \"2018-10-26\" });\nfunction generateTitle(record) {\n  if\
          \ (record.Sns.MessageAttributes.status.Value === \"no\") {\n    return \"\
          File scan failed\";\n  } else if (record.Sns.MessageAttributes.status.Value\
          \ === \"infected\") {\n    return \"Infected file found\";\n  } else {\n\
          \    throw new Error(`unsupported status: ${record.Sns.MessageAttributes.status.Value}`);\n\
          \  }\n}\nfunction generateDescription(record) {\n  if (record.Sns.MessageAttributes.status.Value\
          \ === \"no\") {\n    if (\"version\" in record.Sns.MessageAttributes) {\n\
          \      return `File in S3 bucket ${record.Sns.MessageAttributes.bucket.Value}\
          \ with key ${record.Sns.MessageAttributes.key.Value} and version ${record.Sns.MessageAttributes.version.Value}\
          \ could not be scanned, ${record.Sns.MessageAttributes.action.Value} action\
          \ executed`;\n    } else {\n      return `File in S3 bucket ${record.Sns.MessageAttributes.bucket.Value}\
          \ with key ${record.Sns.MessageAttributes.key.Value} could not be scanned,\
          \ ${record.Sns.MessageAttributes.action.Value} action executed`;\n    }\n\
          \  } else if (record.Sns.MessageAttributes.status.Value === \"infected\"\
          ) {\n    if (\"version\" in record.Sns.MessageAttributes) {\n      return\
          \ `Infected file found in S3 bucket ${record.Sns.MessageAttributes.bucket.Value}\
          \ with key ${record.Sns.MessageAttributes.key.Value} and version ${record.Sns.MessageAttributes.version.Value},\
          \ ${record.Sns.MessageAttributes.action.Value} action executed`;\n    }\
          \ else {\n      return `Infected file found in S3 bucket ${record.Sns.MessageAttributes.bucket.Value}\
          \ with key ${record.Sns.MessageAttributes.key.Value}, ${record.Sns.MessageAttributes.action.Value}\
          \ action executed`;\n    }\n  } else {\n    throw new Error(`unsupported\
          \ status: ${record.Sns.MessageAttributes.status.Value}`);\n  }\n}\nasync\
          \ function handler(event) {\n  console.log(`Invoke: ${JSON.stringify(event)}`);\n\
          \  try {\n    await securityhub.send(new import_client_securityhub.BatchImportFindingsCommand({\n\
          \      Findings: event.Records.map((record) => {\n        const finding\
          \ = {\n          SchemaVersion: \"2018-10-08\",\n          Id: record.Sns.MessageId,\n\
          \          ProductArn: `arn:${process.env.AWS_PARTITION}:securityhub:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:product/${process.env.AWS_ACCOUNT_ID}/default`,\n\
          \          GeneratorId: \"clamav\",\n          AwsAccountId: process.env.AWS_ACCOUNT_ID,\n\
          \          Types: [\"Unusual Behaviors/Data\"],\n          CreatedAt: record.Sns.Timestamp,\n\
          \          UpdatedAt: record.Sns.Timestamp,\n          Severity: {\n   \
          \         Label: \"HIGH\"\n          },\n          Confidence: 100,\n  \
          \        Title: generateTitle(record),\n          Description: generateDescription(record),\n\
          \          Resources: [{\n            Type: \"AwsS3Object\",\n         \
          \   Id: `arn:aws:s3:::${record.Sns.MessageAttributes.bucket.Value}/${record.Sns.MessageAttributes.key.Value}`\n\
          \          }, {\n            Type: \"AwsS3Bucket\",\n            Id: `arn:aws:s3:::${record.Sns.MessageAttributes.bucket.Value}`\n\
          \          }]\n        };\n        if (\"version\" in record.Sns.MessageAttributes)\
          \ {\n          finding.Resources[0].Details = {\n            AwsS3Object:\
          \ {\n              VersionId: record.Sns.MessageAttributes.version.Value\n\
          \            }\n          };\n        }\n        return finding;\n     \
          \ })\n    }));\n  } catch (err) {\n    if (err.name === \"AccessDeniedException\"\
          ) {\n      return false;\n    } else {\n      throw err;\n    }\n  }\n \
          \ return true;\n}\n// Annotate the CommonJS export names for ESM import\
          \ in node:\n0 && (module.exports = {\n  handler\n});\n"
      Environment:
        Variables:
          AWS_ACCOUNT_ID: !Ref 'AWS::AccountId'
          AWS_PARTITION: !Ref 'AWS::Partition'
      Handler: index.handler
      MemorySize: 1769
      Role: !GetAtt [SecurityHubIntegrationLambdaRole, Arn]
      Runtime: nodejs20.x
      Timeout: 60
    Condition: HasSecurityHubIntegration
  SecurityHubIntegrationLambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join ['', [/aws/lambda/, !Ref 'SecurityHubIntegrationLambdaFunction']]
      RetentionInDays: !Ref 'LogsRetentionInDays'
    Condition: HasSecurityHubIntegration
  SecurityHubIntegrationLambdaPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Statement:
        - Effect: Allow
          Action:
          - logs:CreateLogStream
          - logs:PutLogEvents
          Resource: !GetAtt [SecurityHubIntegrationLambdaLogGroup, Arn]
      PolicyName: logs
      Roles:
      - !Ref 'SecurityHubIntegrationLambdaRole'
    Condition: HasSecurityHubIntegration
  SecurityHubIntegrationLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref 'SecurityHubIntegrationLambdaFunction'
      Principal: sns.amazonaws.com
      SourceArn: !Ref 'FindingsTopic'
    Condition: HasSecurityHubIntegration
  SecurityHubIntegrationSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      Endpoint: !GetAtt [SecurityHubIntegrationLambdaFunction, Arn]
      FilterPolicy:
        status:
        - infected
        - 'no'
      Protocol: lambda
      TopicArn: !Ref 'FindingsTopic'
    DependsOn:
    - SecurityHubIntegrationLambdaPermission
    - SecurityHubIntegrationLambdaPolicy
    Condition: HasSecurityHubIntegration
  SecurityHubIntegrationLambdaErrorsAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmActions:
      - !Ref 'InfrastructureAlarmsTopic'
      AlarmDescription: !Join ['', ['AWS Security Hub integration failed. Check logs
            of AWS Lambda Function ', !Ref 'SecurityHubIntegrationLambdaFunction',
          '!']]
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
      - Name: FunctionName
        Value: !Ref 'SecurityHubIntegrationLambdaFunction'
      EvaluationPeriods: 1
      MetricName: Errors
      Namespace: AWS/Lambda
      Period: 60
      Statistic: Sum
      Threshold: 1
      TreatMissingData: notBreaching
    Condition: HasSecurityHubIntegration
  SecurityHubIntegrationLambdaThrottlesAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmActions:
      - !Ref 'InfrastructureAlarmsTopic'
      AlarmDescription: AWS Security Hub integration throttled.
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
      - Name: FunctionName
        Value: !Ref 'SecurityHubIntegrationLambdaFunction'
      EvaluationPeriods: 1
      MetricName: Throttles
      Namespace: AWS/Lambda
      Period: 60
      Statistic: Sum
      Threshold: 1
      TreatMissingData: notBreaching
    Condition: HasSecurityHubIntegration
  OpsCenterIntegrationLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
      PermissionsBoundary: !If [HasPermissionsBoundary, !Ref 'PermissionsBoundary',
        !Ref 'AWS::NoValue']
      Policies:
      - PolicyDocument:
          Statement:
          - Effect: Allow
            Action: ssm:CreateOpsItem
            Resource: '*'
        PolicyName: ssm
    Condition: HasOpsCenterIntegration
  OpsCenterIntegrationLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: "var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n\
          var __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp =\
          \ Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n\
          \  for (var name in all)\n    __defProp(target, name, { get: all[name],\
          \ enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) =>\
          \ {\n  if (from && typeof from === \"object\" || typeof from === \"function\"\
          ) {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to,\
          \ key) && key !== except)\n        __defProp(to, key, { get: () => from[key],\
          \ enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n\
          \  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({},\
          \ \"__esModule\", { value: true }), mod);\n\n// lambda/integration-ops-center.js\n\
          var integration_ops_center_exports = {};\n__export(integration_ops_center_exports,\
          \ {\n  handler: () => handler\n});\nmodule.exports = __toCommonJS(integration_ops_center_exports);\n\
          var import_client_ssm = require(\"@aws-sdk/client-ssm\");\nvar ssm = new\
          \ import_client_ssm.SSMClient({ apiVersion: \"2014-11-06\" });\nfunction\
          \ generateTitle(record) {\n  if (record.Sns.MessageAttributes.status.Value\
          \ === \"no\") {\n    return \"File scan failed\";\n  } else if (record.Sns.MessageAttributes.status.Value\
          \ === \"infected\") {\n    return \"Infected file found\";\n  } else {\n\
          \    throw new Error(`unsupported status: ${record.Sns.MessageAttributes.status.Value}`);\n\
          \  }\n}\nfunction generateDescription(record) {\n  if (record.Sns.MessageAttributes.status.Value\
          \ === \"no\") {\n    if (\"version\" in record.Sns.MessageAttributes) {\n\
          \      return `File in S3 bucket ${record.Sns.MessageAttributes.bucket.Value}\
          \ with key ${record.Sns.MessageAttributes.key.Value} and version ${record.Sns.MessageAttributes.version.Value}\
          \ could not be scanned, ${record.Sns.MessageAttributes.action.Value} action\
          \ executed`;\n    } else {\n      return `File in S3 bucket ${record.Sns.MessageAttributes.bucket.Value}\
          \ with key ${record.Sns.MessageAttributes.key.Value} could not be scanned,\
          \ ${record.Sns.MessageAttributes.action.Value} action executed`;\n    }\n\
          \  } else if (record.Sns.MessageAttributes.status.Value === \"infected\"\
          ) {\n    if (\"version\" in record.Sns.MessageAttributes) {\n      return\
          \ `Infected file found in S3 bucket ${record.Sns.MessageAttributes.bucket.Value}\
          \ with key ${record.Sns.MessageAttributes.key.Value} and version ${record.Sns.MessageAttributes.version.Value},\
          \ ${record.Sns.MessageAttributes.action.Value} action executed`;\n    }\
          \ else {\n      return `Infected file found in S3 bucket ${record.Sns.MessageAttributes.bucket.Value}\
          \ with key ${record.Sns.MessageAttributes.key.Value}, ${record.Sns.MessageAttributes.action.Value}\
          \ action executed`;\n    }\n  } else {\n    throw new Error(`unsupported\
          \ status: ${record.Sns.MessageAttributes.status.Value}`);\n  }\n}\nasync\
          \ function handler(event) {\n  console.log(`Invoke: ${JSON.stringify(event)}`);\n\
          \  await Promise.all(event.Records.map((record) => {\n    return ssm.send(new\
          \ import_client_ssm.CreateOpsItemCommand({\n      Description: generateDescription(record),\n\
          \      OperationalData: {\n        \"/aws/resources\": {\n          Value:\
          \ `[{\"arn\": \"arn:aws:s3:::${record.Sns.MessageAttributes.bucket.Value}\"\
          }]`,\n          Type: \"SearchableString\"\n        },\n        \"bucket\"\
          : {\n          Value: record.Sns.MessageAttributes.bucket.Value,\n     \
          \     Type: \"SearchableString\"\n        },\n        \"key\": {\n     \
          \     Value: record.Sns.MessageAttributes.key.Value,\n          Type: \"\
          SearchableString\"\n        }\n      },\n      Priority: 4,\n      Source:\
          \ \"bucketAV\",\n      Title: generateTitle(record)\n    }));\n  }));\n\
          \  return true;\n}\n// Annotate the CommonJS export names for ESM import\
          \ in node:\n0 && (module.exports = {\n  handler\n});\n"
      Handler: index.handler
      MemorySize: 1769
      Role: !GetAtt [OpsCenterIntegrationLambdaRole, Arn]
      Runtime: nodejs20.x
      Timeout: 60
    Condition: HasOpsCenterIntegration
  OpsCenterIntegrationLambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join ['', [/aws/lambda/, !Ref 'OpsCenterIntegrationLambdaFunction']]
      RetentionInDays: !Ref 'LogsRetentionInDays'
    Condition: HasOpsCenterIntegration
  OpsCenterIntegrationLambdaPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Statement:
        - Effect: Allow
          Action:
          - logs:CreateLogStream
          - logs:PutLogEvents
          Resource: !GetAtt [OpsCenterIntegrationLambdaLogGroup, Arn]
      PolicyName: logs
      Roles:
      - !Ref 'OpsCenterIntegrationLambdaRole'
    Condition: HasOpsCenterIntegration
  OpsCenterIntegrationLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref 'OpsCenterIntegrationLambdaFunction'
      Principal: sns.amazonaws.com
      SourceArn: !Ref 'FindingsTopic'
    Condition: HasOpsCenterIntegration
  OpsCenterIntegrationSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      Endpoint: !GetAtt [OpsCenterIntegrationLambdaFunction, Arn]
      FilterPolicy:
        status:
        - infected
        - 'no'
      Protocol: lambda
      TopicArn: !Ref 'FindingsTopic'
    DependsOn:
    - OpsCenterIntegrationLambdaPermission
    - OpsCenterIntegrationLambdaPolicy
    Condition: HasOpsCenterIntegration
  OpsCenterIntegrationLambdaErrorsAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmActions:
      - !Ref 'InfrastructureAlarmsTopic'
      AlarmDescription: !Join ['', ['AWS Systems Manager OpsCenter integration failed.
            Check logs of AWS Lambda Function ', !Ref 'OpsCenterIntegrationLambdaFunction',
          '!']]
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
      - Name: FunctionName
        Value: !Ref 'OpsCenterIntegrationLambdaFunction'
      EvaluationPeriods: 1
      MetricName: Errors
      Namespace: AWS/Lambda
      Period: 60
      Statistic: Sum
      Threshold: 1
      TreatMissingData: notBreaching
    Condition: HasOpsCenterIntegration
  OpsCenterIntegrationLambdaThrottlesAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmActions:
      - !Ref 'InfrastructureAlarmsTopic'
      AlarmDescription: AWS Systems Manager OpsCenter integration throttled.
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
      - Name: FunctionName
        Value: !Ref 'OpsCenterIntegrationLambdaFunction'
      EvaluationPeriods: 1
      MetricName: Throttles
      Namespace: AWS/Lambda
      Period: 60
      Statistic: Sum
      Threshold: 1
      TreatMissingData: notBreaching
    Condition: HasOpsCenterIntegration
  ScanScaleDown:
    Type: AWS::AutoScaling::ScalingPolicy
    Properties:
      AdjustmentType: PercentChangeInCapacity
      AutoScalingGroupName: !Ref 'ScanAutoScalingGroup'
      Cooldown: '300'
      MinAdjustmentMagnitude: 1
      PolicyType: SimpleScaling
      ScalingAdjustment: -25
  ScanQueueFullAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmActions:
      - !Ref 'ScanScaleUp'
      AlarmDescription: Don't be worried about this alarm. It is used to trigger auto-scaling
        policies. Please follow https://bucketav.com/help/operations/monitoring-alerting.html#scanqueuefullalarm
      ComparisonOperator: GreaterThanThreshold
      Dimensions:
      - Name: QueueName
        Value: !GetAtt [ScanQueue, QueueName]
      EvaluationPeriods: 1
      MetricName: ApproximateNumberOfMessagesVisible
      Namespace: AWS/SQS
      Period: 300
      Statistic: Maximum
      Threshold: 0
      TreatMissingData: notBreaching
  ScanQueueEmptyAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmActions:
      - !Ref 'ScanScaleDown'
      AlarmDescription: Don't be worried about this alarm. It is used to trigger auto-scaling
        policies. Please follow https://bucketav.com/help/operations/monitoring-alerting.html#scanqueueemptyalarm
      ComparisonOperator: LessThanOrEqualToThreshold
      EvaluationPeriods: 1
      Metrics:
      - Id: m1
        Label: ApproximateNumberOfMessagesVisible
        MetricStat:
          Metric:
            Dimensions:
            - Name: QueueName
              Value: !GetAtt [ScanQueue, QueueName]
            MetricName: ApproximateNumberOfMessagesVisible
            Namespace: AWS/SQS
          Period: 300
          Stat: Maximum
        ReturnData: false
      - Id: m2
        Label: ApproximateNumberOfMessagesNotVisible
        MetricStat:
          Metric:
            Dimensions:
            - Name: QueueName
              Value: !GetAtt [ScanQueue, QueueName]
            MetricName: ApproximateNumberOfMessagesNotVisible
            Namespace: AWS/SQS
          Period: 300
          Stat: Maximum
        ReturnData: false
      - Expression: m1+m2
        Id: e1
        Label: ApproximateNumberOfMessages
        ReturnData: true
      Threshold: 0
      TreatMissingData: notBreaching
  FallbackScaleUp:
    Type: AWS::AutoScaling::ScalingPolicy
    Properties:
      AdjustmentType: ChangeInCapacity
      AutoScalingGroupName: !Ref 'FallbackAutoScalingGroup'
      EstimatedInstanceWarmup: 300
      MetricAggregationType: Average
      PolicyType: StepScaling
      StepAdjustments:
      - MetricIntervalLowerBound: 0
        MetricIntervalUpperBound: 2
        ScalingAdjustment: 1
      - MetricIntervalLowerBound: 2
        MetricIntervalUpperBound: 3
        ScalingAdjustment: 2
      - MetricIntervalLowerBound: 3
        MetricIntervalUpperBound: 4
        ScalingAdjustment: 3
      - MetricIntervalLowerBound: 4
        MetricIntervalUpperBound: 5
        ScalingAdjustment: 4
      - MetricIntervalLowerBound: 5
        MetricIntervalUpperBound: 10
        ScalingAdjustment: 5
      - MetricIntervalLowerBound: 10
        MetricIntervalUpperBound: 25
        ScalingAdjustment: 10
      - MetricIntervalLowerBound: 25
        ScalingAdjustment: 25
    Condition: HasOnDemandFallback
  FallbackScaleDown:
    Type: AWS::AutoScaling::ScalingPolicy
    Properties:
      AdjustmentType: ChangeInCapacity
      AutoScalingGroupName: !Ref 'FallbackAutoScalingGroup'
      EstimatedInstanceWarmup: 300
      MetricAggregationType: Average
      PolicyType: StepScaling
      StepAdjustments:
      - MetricIntervalLowerBound: -2
        MetricIntervalUpperBound: 0
        ScalingAdjustment: -1
      - MetricIntervalLowerBound: -3
        MetricIntervalUpperBound: -2
        ScalingAdjustment: -2
      - MetricIntervalLowerBound: -4
        MetricIntervalUpperBound: -3
        ScalingAdjustment: -3
      - MetricIntervalLowerBound: -5
        MetricIntervalUpperBound: -4
        ScalingAdjustment: -4
      - MetricIntervalUpperBound: -5
        ScalingAdjustment: -5
    Condition: HasOnDemandFallback
  FallbackScaleUpAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmActions:
      - !Ref 'FallbackScaleUp'
      AlarmDescription: Don't be worried about this alarm. It is used to trigger auto-scaling
        policies. Please follow https://bucketav.com/help/operations/monitoring-alerting.html#fallbackscaleupalarm
      ComparisonOperator: GreaterThanThreshold
      EvaluationPeriods: 3
      Metrics:
      - Id: running
        Label: running
        MetricStat:
          Metric:
            Dimensions:
            - Name: AutoScalingGroupName
              Value: !Ref 'ScanAutoScalingGroup'
            MetricName: GroupInServiceInstances
            Namespace: AWS/AutoScaling
          Period: 60
          Stat: Maximum
        ReturnData: false
      - Id: desired
        Label: desired
        MetricStat:
          Metric:
            Dimensions:
            - Name: AutoScalingGroupName
              Value: !Ref 'ScanAutoScalingGroup'
            MetricName: GroupDesiredCapacity
            Namespace: AWS/AutoScaling
          Period: 60
          Stat: Maximum
        ReturnData: false
      - Id: desiredfallback
        Label: desiredfallback
        MetricStat:
          Metric:
            Dimensions:
            - Name: AutoScalingGroupName
              Value: !Ref 'FallbackAutoScalingGroup'
            MetricName: GroupDesiredCapacity
            Namespace: AWS/AutoScaling
          Period: 60
          Stat: Maximum
        ReturnData: false
      - Expression: desired-running-desiredfallback
        Id: e1
        Label: fallback
        ReturnData: true
      Threshold: 0
      TreatMissingData: notBreaching
    Condition: HasOnDemandFallback
  FallbackScaleDownAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmActions:
      - !Ref 'FallbackScaleDown'
      AlarmDescription: Don't be worried about this alarm. It is used to trigger auto-scaling
        policies. Please follow https://bucketav.com/help/operations/monitoring-alerting.html#fallbackscaledownalarm
      ComparisonOperator: LessThanThreshold
      EvaluationPeriods: 3
      Metrics:
      - Id: running
        Label: running
        MetricStat:
          Metric:
            Dimensions:
            - Name: AutoScalingGroupName
              Value: !Ref 'ScanAutoScalingGroup'
            MetricName: GroupInServiceInstances
            Namespace: AWS/AutoScaling
          Period: 60
          Stat: Maximum
        ReturnData: false
      - Id: desired
        Label: desired
        MetricStat:
          Metric:
            Dimensions:
            - Name: AutoScalingGroupName
              Value: !Ref 'ScanAutoScalingGroup'
            MetricName: GroupDesiredCapacity
            Namespace: AWS/AutoScaling
          Period: 60
          Stat: Maximum
        ReturnData: false
      - Id: desiredfallback
        Label: desiredfallback
        MetricStat:
          Metric:
            Dimensions:
            - Name: AutoScalingGroupName
              Value: !Ref 'FallbackAutoScalingGroup'
            MetricName: GroupDesiredCapacity
            Namespace: AWS/AutoScaling
          Period: 60
          Stat: Maximum
        ReturnData: false
      - Expression: desired-running-desiredfallback
        Id: e1
        Label: fallback
        ReturnData: true
      Threshold: 0
      TreatMissingData: notBreaching
    Condition: HasOnDemandFallback
  DashboardLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
      PermissionsBoundary: !If [HasPermissionsBoundary, !Ref 'PermissionsBoundary',
        !Ref 'AWS::NoValue']
      Policies:
      - PolicyDocument:
          Statement:
          - Effect: Allow
            Action: cloudformation:DescribeStacks
            Resource: !Ref 'AWS::StackId'
          - Effect: Allow
            Action:
            - cloudformation:DescribeStacks
            - s3:ListAllMyBuckets
            - s3:GetBucketLocation
            - s3:GetBucketNotification
            - sns:ListSubscriptionsByTopic
            - events:ListRuleNamesByTarget
            - events:DescribeRule
            Resource: '*'
          - !If [HasCrossAccount, {Effect: Allow, Action: 'ssm:GetParameter', Resource: !Join [
                '', ['arn:', !Ref 'AWS::Partition', ':ssm:', !Ref 'AWS::Region', ':',
                  !Ref 'AWS::AccountId', ':parameter', !Ref 'ServiceDiscoveryOrganizationId']]},
            !Ref 'AWS::NoValue']
          - Effect: Allow
            Action: events:DescribeEventBus
            Resource: !Join ['', ['arn:', !Ref 'AWS::Partition', ':events:', !Ref 'AWS::Region',
                ':', !Ref 'AWS::AccountId', ':event-bus/default']]
          - !If [HasCrossAccount, {Effect: Allow, Action: 'dynamodb:Scan', Resource: [
                !GetAtt [AccountConnectionTable, Arn], !GetAtt [BucketCacheTable,
                  Arn]]}, !Ref 'AWS::NoValue']
          - !If [HasCrossAccount, {Effect: Allow, Action: 'dynamodb:GetItem', Resource: !GetAtt [
                AccountConnectionTable, Arn]}, !Ref 'AWS::NoValue']
          - !If [HasCrossAccount, {Effect: Allow, Action: ['dynamodb:GetItem', 'dynamodb:PutItem'],
              Resource: !GetAtt [BucketCacheTable, Arn]}, !Ref 'AWS::NoValue']
          - !If [HasCrossAccount, {Effect: Allow, Action: 'sts:AssumeRole', Resource: !Join [
                '', ['arn:', !Ref 'AWS::Partition', ':iam::*:role/', !Ref 'AWS::StackName',
                  -AccountConnection]]}, !Ref 'AWS::NoValue']
          - !If [HasCrossAccount, {Effect: Allow, Action: 'states:StartExecution',
              Resource: !GetAtt [RefreshBucketCacheStateMachine, Arn]}, !Ref 'AWS::NoValue']
          - Effect: Allow
            Action: ssm:GetParametersByPath
            Resource: !Join ['', ['arn:', !Ref 'AWS::Partition', ':ssm:', !Ref 'AWS::Region',
                ':', !Ref 'AWS::AccountId', ':parameter/bucketAV/', !Ref 'AWS::StackName',
                /AddOn/*]]
          - Effect: Allow
            Action: s3:PutBucketNotification
            Resource: !Ref 'S3BucketRestriction'
        PolicyName: lambda
  DashboardLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: "var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n\
          var __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp =\
          \ Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n\
          \  for (var name in all)\n    __defProp(target, name, { get: all[name],\
          \ enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) =>\
          \ {\n  if (from && typeof from === \"object\" || typeof from === \"function\"\
          ) {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to,\
          \ key) && key !== except)\n        __defProp(to, key, { get: () => from[key],\
          \ enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n\
          \  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({},\
          \ \"__esModule\", { value: true }), mod);\n\n// lambda/dashboard.js\nvar\
          \ dashboard_exports = {};\n__export(dashboard_exports, {\n  handler: ()\
          \ => handler\n});\nmodule.exports = __toCommonJS(dashboard_exports);\nvar\
          \ import_client_cloudformation3 = require(\"@aws-sdk/client-cloudformation\"\
          );\nvar import_client_s34 = require(\"@aws-sdk/client-s3\");\nvar import_client_ssm3\
          \ = require(\"@aws-sdk/client-ssm\");\nvar import_client_dynamodb3 = require(\"\
          @aws-sdk/client-dynamodb\");\nvar import_client_sns3 = require(\"@aws-sdk/client-sns\"\
          );\nvar import_client_eventbridge3 = require(\"@aws-sdk/client-eventbridge\"\
          );\nvar import_client_sfn = require(\"@aws-sdk/client-sfn\");\n\n// lambda/node_modules/yocto-queue/index.js\n\
          var Node = class {\n  value;\n  next;\n  constructor(value) {\n    this.value\
          \ = value;\n  }\n};\nvar Queue = class {\n  #head;\n  #tail;\n  #size;\n\
          \  constructor() {\n    this.clear();\n  }\n  enqueue(value) {\n    const\
          \ node = new Node(value);\n    if (this.#head) {\n      this.#tail.next\
          \ = node;\n      this.#tail = node;\n    } else {\n      this.#head = node;\n\
          \      this.#tail = node;\n    }\n    this.#size++;\n  }\n  dequeue() {\n\
          \    const current = this.#head;\n    if (!current) {\n      return;\n \
          \   }\n    this.#head = this.#head.next;\n    this.#size--;\n    return\
          \ current.value;\n  }\n  clear() {\n    this.#head = void 0;\n    this.#tail\
          \ = void 0;\n    this.#size = 0;\n  }\n  get size() {\n    return this.#size;\n\
          \  }\n  *[Symbol.iterator]() {\n    let current = this.#head;\n    while\
          \ (current) {\n      yield current.value;\n      current = current.next;\n\
          \    }\n  }\n};\n\n// lambda/plimit.js\nvar import_node_async_hooks = require(\"\
          node:async_hooks\");\nfunction pLimit(concurrency) {\n  if (!((Number.isInteger(concurrency)\
          \ || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {\n\
          \    throw new TypeError(\"Expected `concurrency` to be a number from 1\
          \ and up\");\n  }\n  const queue = new Queue();\n  let activeCount = 0;\n\
          \  const next = () => {\n    activeCount--;\n    if (queue.size > 0) {\n\
          \      queue.dequeue()();\n    }\n  };\n  const run = async (function_,\
          \ resolve, arguments_) => {\n    activeCount++;\n    const result = (async\
          \ () => function_(...arguments_))();\n    resolve(result);\n    try {\n\
          \      await result;\n    } catch {\n    }\n    next();\n  };\n  const enqueue\
          \ = (function_, resolve, arguments_) => {\n    queue.enqueue(\n      import_node_async_hooks.AsyncResource.bind(run.bind(void\
          \ 0, function_, resolve, arguments_))\n    );\n    (async () => {\n    \
          \  await Promise.resolve();\n      if (activeCount < concurrency && queue.size\
          \ > 0) {\n        queue.dequeue()();\n      }\n    })();\n  };\n  const\
          \ generator = (function_, ...arguments_) => new Promise((resolve) => {\n\
          \    enqueue(function_, resolve, arguments_);\n  });\n  Object.defineProperties(generator,\
          \ {\n    activeCount: {\n      get: () => activeCount\n    },\n    pendingCount:\
          \ {\n      get: () => queue.size\n    },\n    clearQueue: {\n      value()\
          \ {\n        queue.clear();\n      }\n    }\n  });\n  return generator;\n\
          }\n\n// lambda/lib.js\nvar import_client_cloudformation = require(\"@aws-sdk/client-cloudformation\"\
          );\nvar import_client_s3 = require(\"@aws-sdk/client-s3\");\nvar import_client_sns\
          \ = require(\"@aws-sdk/client-sns\");\nvar import_client_eventbridge = require(\"\
          @aws-sdk/client-eventbridge\");\nvar import_client_dynamodb = require(\"\
          @aws-sdk/client-dynamodb\");\nvar import_client_s32 = require(\"@aws-sdk/client-s3\"\
          );\nvar import_client_ssm = require(\"@aws-sdk/client-ssm\");\nvar import_client_secrets_manager\
          \ = require(\"@aws-sdk/client-secrets-manager\");\nvar import_client_organizations\
          \ = require(\"@aws-sdk/client-organizations\");\nvar import_credential_providers\
          \ = require(\"@aws-sdk/credential-providers\");\n\n// lambda/node_modules/@smithy/types/dist-es/auth/auth.js\n\
          var HttpAuthLocation;\n(function(HttpAuthLocation2) {\n  HttpAuthLocation2[\"\
          HEADER\"] = \"header\";\n  HttpAuthLocation2[\"QUERY\"] = \"query\";\n})(HttpAuthLocation\
          \ || (HttpAuthLocation = {}));\n\n// lambda/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js\n\
          var HttpApiKeyAuthLocation;\n(function(HttpApiKeyAuthLocation2) {\n  HttpApiKeyAuthLocation2[\"\
          HEADER\"] = \"header\";\n  HttpApiKeyAuthLocation2[\"QUERY\"] = \"query\"\
          ;\n})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));\n\n// lambda/node_modules/@smithy/types/dist-es/endpoint.js\n\
          var EndpointURLScheme;\n(function(EndpointURLScheme2) {\n  EndpointURLScheme2[\"\
          HTTP\"] = \"http\";\n  EndpointURLScheme2[\"HTTPS\"] = \"https\";\n})(EndpointURLScheme\
          \ || (EndpointURLScheme = {}));\n\n// lambda/node_modules/@smithy/types/dist-es/extensions/checksum.js\n\
          var AlgorithmId;\n(function(AlgorithmId2) {\n  AlgorithmId2[\"MD5\"] = \"\
          md5\";\n  AlgorithmId2[\"CRC32\"] = \"crc32\";\n  AlgorithmId2[\"CRC32C\"\
          ] = \"crc32c\";\n  AlgorithmId2[\"SHA1\"] = \"sha1\";\n  AlgorithmId2[\"\
          SHA256\"] = \"sha256\";\n})(AlgorithmId || (AlgorithmId = {}));\n\n// lambda/node_modules/@smithy/types/dist-es/http.js\n\
          var FieldPosition;\n(function(FieldPosition2) {\n  FieldPosition2[FieldPosition2[\"\
          HEADER\"] = 0] = \"HEADER\";\n  FieldPosition2[FieldPosition2[\"TRAILER\"\
          ] = 1] = \"TRAILER\";\n})(FieldPosition || (FieldPosition = {}));\n\n//\
          \ lambda/node_modules/@smithy/types/dist-es/profile.js\nvar IniSectionType;\n\
          (function(IniSectionType2) {\n  IniSectionType2[\"PROFILE\"] = \"profile\"\
          ;\n  IniSectionType2[\"SSO_SESSION\"] = \"sso-session\";\n  IniSectionType2[\"\
          SERVICES\"] = \"services\";\n})(IniSectionType || (IniSectionType = {}));\n\
          \n// lambda/node_modules/@smithy/types/dist-es/transfer.js\nvar RequestHandlerProtocol;\n\
          (function(RequestHandlerProtocol2) {\n  RequestHandlerProtocol2[\"HTTP_0_9\"\
          ] = \"http/0.9\";\n  RequestHandlerProtocol2[\"HTTP_1_0\"] = \"http/1.0\"\
          ;\n  RequestHandlerProtocol2[\"TDS_8_0\"] = \"tds/8.0\";\n})(RequestHandlerProtocol\
          \ || (RequestHandlerProtocol = {}));\n\n// lambda/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js\n\
          var import_fs = require(\"fs\");\nvar { readFile } = import_fs.promises;\n\
          \n// lambda/node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js\n\
          var import_fs2 = require(\"fs\");\nvar { readFile: readFile2 } = import_fs2.promises;\n\
          \n// lambda/node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js\n\
          var serializerMiddlewareOption = {\n  name: \"serializerMiddleware\",\n\
          \  step: \"serialize\",\n  tags: [\"SERIALIZER\"],\n  override: true\n};\n\
          \n// lambda/node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js\n\
          var endpointMiddlewareOptions = {\n  step: \"serialize\",\n  tags: [\"ENDPOINT_PARAMETERS\"\
          , \"ENDPOINT_V2\", \"ENDPOINT\"],\n  name: \"endpointV2Middleware\",\n \
          \ override: true,\n  relation: \"before\",\n  toMiddleware: serializerMiddlewareOption.name\n\
          };\n\n// lambda/node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemeEndpointRuleSetPlugin.js\n\
          var httpAuthSchemeEndpointRuleSetMiddlewareOptions = {\n  step: \"serialize\"\
          ,\n  tags: [\"HTTP_AUTH_SCHEME\"],\n  name: \"httpAuthSchemeMiddleware\"\
          ,\n  override: true,\n  relation: \"before\",\n  toMiddleware: endpointMiddlewareOptions.name\n\
          };\n\n// lambda/node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemePlugin.js\n\
          var httpAuthSchemeMiddlewareOptions = {\n  step: \"serialize\",\n  tags:\
          \ [\"HTTP_AUTH_SCHEME\"],\n  name: \"httpAuthSchemeMiddleware\",\n  override:\
          \ true,\n  relation: \"before\",\n  toMiddleware: serializerMiddlewareOption.name\n\
          };\n\n// lambda/node_modules/@smithy/util-retry/dist-es/config.js\nvar RETRY_MODES;\n\
          (function(RETRY_MODES2) {\n  RETRY_MODES2[\"STANDARD\"] = \"standard\";\n\
          \  RETRY_MODES2[\"ADAPTIVE\"] = \"adaptive\";\n})(RETRY_MODES || (RETRY_MODES\
          \ = {}));\nvar DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;\n\n// lambda/node_modules/@smithy/util-retry/dist-es/constants.js\n\
          var MAXIMUM_RETRY_DELAY = 20 * 1e3;\n\n// lambda/node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-pool.js\n\
          var NodeHttp2ConnectionPool = class {\n  constructor(sessions) {\n    this.sessions\
          \ = [];\n    this.sessions = sessions ?? [];\n  }\n  poll() {\n    if (this.sessions.length\
          \ > 0) {\n      return this.sessions.shift();\n    }\n  }\n  offerLast(session)\
          \ {\n    this.sessions.push(session);\n  }\n  contains(session) {\n    return\
          \ this.sessions.includes(session);\n  }\n  remove(session) {\n    this.sessions\
          \ = this.sessions.filter((s) => s !== session);\n  }\n  [Symbol.iterator]()\
          \ {\n    return this.sessions[Symbol.iterator]();\n  }\n  destroy(connection)\
          \ {\n    for (const session of this.sessions) {\n      if (session === connection)\
          \ {\n        if (!session.destroyed) {\n          session.destroy();\n \
          \       }\n      }\n    }\n  }\n};\n\n// lambda/node_modules/@smithy/smithy-client/dist-es/parse-utils.js\n\
          var MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));\n\n// lambda/node_modules/@smithy/smithy-client/dist-es/date-utils.js\n\
          var RFC3339 = new RegExp(/^(\\d{4})-(\\d{2})-(\\d{2})[tT](\\d{2}):(\\d{2}):(\\\
          d{2})(?:\\.(\\d+))?[zZ]$/);\nvar RFC3339_WITH_OFFSET = new RegExp(/^(\\\
          d{4})-(\\d{2})-(\\d{2})[tT](\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))?(([-+]\\\
          d{2}\\:\\d{2})|[zZ])$/);\nvar IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),\
          \ (\\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\\d{4}) (\\\
          d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? GMT$/);\nvar RFC_850_DATE = new\
          \ RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday),\
          \ (\\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\\d{2}) (\\\
          d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? GMT$/);\nvar ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)\
          \ (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\\d{2}) (\\\
          d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? (\\d{4})$/);\nvar FIFTY_YEARS_IN_MILLIS\
          \ = 50 * 365 * 24 * 60 * 60 * 1e3;\n\n// lambda/node_modules/@smithy/smithy-client/dist-es/lazy-json.js\n\
          var StringWrapper = function() {\n  const Class = Object.getPrototypeOf(this).constructor;\n\
          \  const Constructor = Function.bind.apply(String, [null, ...arguments]);\n\
          \  const instance = new Constructor();\n  Object.setPrototypeOf(instance,\
          \ Class.prototype);\n  return instance;\n};\nStringWrapper.prototype = Object.create(String.prototype,\
          \ {\n  constructor: {\n    value: StringWrapper,\n    enumerable: false,\n\
          \    writable: true,\n    configurable: true\n  }\n});\nObject.setPrototypeOf(StringWrapper,\
          \ String);\n\n// lambda/node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js\n\
          var retryMiddlewareOptions = {\n  name: \"retryMiddleware\",\n  tags: [\"\
          RETRY\"],\n  step: \"finalizeRequest\",\n  priority: \"high\",\n  override:\
          \ true\n};\n\n// lambda/node_modules/@smithy/core/dist-es/middleware-http-signing/getHttpSigningMiddleware.js\n\
          var httpSigningMiddlewareOptions = {\n  step: \"finalizeRequest\",\n  tags:\
          \ [\"HTTP_SIGNING\"],\n  name: \"httpSigningMiddleware\",\n  aliases: [\"\
          apiKeyMiddleware\", \"tokenMiddleware\", \"awsAuthMiddleware\"],\n  override:\
          \ true,\n  relation: \"after\",\n  toMiddleware: retryMiddlewareOptions.name\n\
          };\n\n// lambda/node_modules/@smithy/core/dist-es/util-identity-and-auth/memoizeIdentityProvider.js\n\
          var createIsIdentityExpiredFunction = (expirationMs) => (identity) => doesIdentityRequireRefresh(identity)\
          \ && identity.expiration.getTime() - Date.now() < expirationMs;\nvar EXPIRATION_MS\
          \ = 3e5;\nvar isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);\n\
          var doesIdentityRequireRefresh = (identity) => identity.expiration !== void\
          \ 0;\n\n// lambda/node_modules/@smithy/core/dist-es/pagination/createPaginator.js\n\
          var makePagedClientRequest = async (CommandCtor, client, input, ...args)\
          \ => {\n  return await client.send(new CommandCtor(input), ...args);\n};\n\
          function createPaginator(ClientCtor, CommandCtor, inputTokenName, outputTokenName,\
          \ pageSizeTokenName) {\n  return async function* paginateOperation(config,\
          \ input, ...additionalArguments) {\n    let token = config.startingToken\
          \ || void 0;\n    let hasNext = true;\n    let page;\n    while (hasNext)\
          \ {\n      input[inputTokenName] = token;\n      if (pageSizeTokenName)\
          \ {\n        input[pageSizeTokenName] = input[pageSizeTokenName] ?? config.pageSize;\n\
          \      }\n      if (config.client instanceof ClientCtor) {\n        page\
          \ = await makePagedClientRequest(CommandCtor, config.client, input, ...additionalArguments);\n\
          \      } else {\n        throw new Error(`Invalid client, expected instance\
          \ of ${ClientCtor.name}`);\n      }\n      yield page;\n      const prevToken\
          \ = token;\n      token = get(page, outputTokenName);\n      hasNext = !!(token\
          \ && (!config.stopOnSameToken || token !== prevToken));\n    }\n    return\
          \ void 0;\n  };\n}\nvar get = (fromObject, path) => {\n  let cursor = fromObject;\n\
          \  const pathComponents = path.split(\".\");\n  for (const step of pathComponents)\
          \ {\n    if (!cursor || typeof cursor !== \"object\") {\n      return void\
          \ 0;\n    }\n    cursor = cursor[step];\n  }\n  return cursor;\n};\n\n//\
          \ lambda/lib.js\nasync function fetchCachedOrganizationId(ssm2, coreStackName)\
          \ {\n  const data = await ssm2.send(new import_client_ssm.GetParameterCommand({\n\
          \    Name: `/bucketAV/${coreStackName}/OrganizationId`\n  }));\n  if (data.Parameter.Value\
          \ === \"INIT\" || data.Parameter.Value === \"NONE\") {\n    return void\
          \ 0;\n  }\n  return data.Parameter.Value;\n}\nfunction mapBucketLocationData(data)\
          \ {\n  if (data.LocationConstraint === void 0 || data.LocationConstraint\
          \ === null || data.LocationConstraint === \"\") {\n    return \"us-east-1\"\
          ;\n  }\n  if (data.LocationConstraint === \"EU\") {\n    return \"eu-west-1\"\
          ;\n  }\n  return data.LocationConstraint;\n}\nfunction includesBucket(scheduledStack,\
          \ bucketName) {\n  let excludeFilterExpression = \"^$\";\n  if (scheduledStack.params.ExcludeBucketNameFilter)\
          \ {\n    excludeFilterExpression = \"^\" + scheduledStack.params.ExcludeBucketNameFilter.replaceAll(\"\
          .\", \".\").replaceAll(\"-\", \"-\").replaceAll(\"*\", \".*\").replaceAll(\"\
          ,\", \"$|^\") + \"$\";\n  }\n  if (bucketName.match(new RegExp(excludeFilterExpression)))\
          \ {\n    return false;\n  }\n  if (scheduledStack.params.BucketName.includes(\"\
          *\")) {\n    const filterExpression = \"^\" + scheduledStack.params.BucketName.replaceAll(\"\
          .\", \".\").replaceAll(\"-\", \"-\").replaceAll(\"*\", \".*\").replaceAll(\"\
          ,\", \"$|^\") + \"$\";\n    return bucketName.match(new RegExp(filterExpression))\
          \ !== null;\n  } else {\n    return scheduledStack.params.BucketName.split(\"\
          ,\").includes(bucketName);\n  }\n}\nfunction hasBucket(scheduledStack, bucketName)\
          \ {\n  if (scheduledStack.params.BucketName === bucketName && (scheduledStack.params.ExcludeBucketNameFilter\
          \ === \"\" || !(\"ExcludeBucketNameFilter\" in scheduledStack.params)))\
          \ {\n    return true;\n  }\n  return false;\n}\nfunction mapCachedBucketItem(item)\
          \ {\n  const bucket = {\n    name: item.bucket_name.S,\n    accountId: item.bucket_account_id.S,\n\
          \    realtimeEnabled: item.bucket_realtime_enabled.BOOL,\n    realtimeEventNotificationEnablePossible:\
          \ item.bucket_realtime_event_notification_enable_possible.BOOL,\n    realtimeEventNotificationDisablePossible:\
          \ item.bucket_realtime_event_notification_disable_possible.BOOL,\n    scheduledEnabled:\
          \ item.bucket_scheduled_enabled.BOOL,\n    scheduledStackDisablePossible:\
          \ item.bucket_scheduled_stack_disable_possible.BOOL\n  };\n  if (\"bucket_organization_id\"\
          \ in item) {\n    bucket.organizationId = item.bucket_organization_id.S;\n\
          \  }\n  if (\"bucket_region\" in item) {\n    bucket.region = item.bucket_region.S;\n\
          \  }\n  if (\"bucket_error_message\" in item) {\n    bucket.errorMessage\
          \ = item.bucket_error_message.S;\n  }\n  if (\"bucket_scheduled_stack_id\"\
          \ in item) {\n    bucket.scheduledStackId = item.bucket_scheduled_stack_id.S;\n\
          \  }\n  return bucket;\n}\nasync function listCachedBuckets(dynamodb3, coreStackName)\
          \ {\n  const paginatorScan = await (0, import_client_dynamodb.paginateScan)({\
          \ client: dynamodb3 }, { TableName: `${coreStackName}-BucketCache` });\n\
          \  const buckets = [];\n  for await (const page of paginatorScan) {\n  \
          \  for (const item of page.Items) {\n      buckets.push(mapCachedBucketItem(item));\n\
          \    }\n  }\n  return buckets;\n}\nvar paginateListRuleNamesByTarget = createPaginator(import_client_eventbridge.EventBridgeClient,\
          \ import_client_eventbridge.ListRuleNamesByTargetCommand, \"NextToken\"\
          , \"NextToken\", \"Limit\");\nasync function checkEventBridgeRules(eventbridge2,\
          \ ruleNames, bucketName) {\n  const rules = await Promise.all(ruleNames.map((ruleName)\
          \ => eventbridge2.send(new import_client_eventbridge.DescribeRuleCommand({\
          \ Name: ruleName }))));\n  return rules.filter((rule) => rule.State ===\
          \ \"ENABLED\" && rule.EventPattern).map((rule) => JSON.parse(rule.EventPattern)).find((pattern)\
          \ => pattern.source.includes(\"aws.s3\") && pattern[\"detail-type\"].includes(\"\
          Object Created\") && (pattern?.detail?.bucket?.name?.includes(bucketName)\
          \ || pattern?.detail?.bucket?.name === void 0)) !== void 0;\n}\nasync function\
          \ enrichBucket(s3, sns2, eventbridge2, coreEventbridge, partition, region,\
          \ accountId, organizationId, coreAccountId, coreStackName, scanQueueArn,\
          \ scheduledStacks, bucketName) {\n  const bucket = await s3.send(new import_client_s3.GetBucketLocationCommand({\
          \ Bucket: bucketName })).then((data) => ({\n    name: bucketName,\n    region:\
          \ mapBucketLocationData(data),\n    accountId,\n    organizationId\n  })).catch((err)\
          \ => ({\n    name: bucketName,\n    region: void 0,\n    accountId,\n  \
          \  organizationId,\n    errorMessage: `Can not get region for bucket ${bucketName}:\
          \ ${err.name}`\n  }));\n  if (bucket.region === region || bucket.region\
          \ === void 0) {\n    let realtimeEnabled = false;\n    let realtimeEventNotificationEnablePossible\
          \ = bucket.region !== void 0;\n    let realtimeEventNotificationDisablePossible\
          \ = false;\n    let scheduledEnabled = false;\n    let scheduledStackDisablePossible\
          \ = false;\n    let scheduledStackId = void 0;\n    try {\n      const notificationData\
          \ = await s3.send(new import_client_s3.GetBucketNotificationConfigurationCommand({\
          \ Bucket: bucket.name, ExpectedBucketOwner: accountId }));\n      if (notificationData?.QueueConfigurations?.find((config)\
          \ => config.QueueArn === scanQueueArn && config.Events.includes(\"s3:ObjectCreated:*\"\
          )) !== void 0) {\n        realtimeEnabled = true;\n        realtimeEventNotificationDisablePossible\
          \ = true;\n      }\n      if (Array.isArray(notificationData?.TopicConfigurations))\
          \ {\n        await Promise.all(notificationData.TopicConfigurations.filter((config)\
          \ => config.Events.includes(\"s3:ObjectCreated:*\")).map(async (config)\
          \ => {\n          const paginatorListSubscriptionsByTopic = await (0, import_client_sns.paginateListSubscriptionsByTopic)({\
          \ client: sns2, pageSize: 50 }, { TopicArn: config.TopicArn });\n      \
          \    for await (const page of paginatorListSubscriptionsByTopic) {\n   \
          \         if (page.Subscriptions.find((subscription) => subscription.Protocol\
          \ === \"sqs\" && subscription.Endpoint === scanQueueArn) !== void 0) {\n\
          \              realtimeEnabled = true;\n            }\n          }\n   \
          \     }));\n      }\n      if (notificationData?.EventBridgeConfiguration)\
          \ {\n        if (accountId !== coreAccountId) {\n          let crossAccoutRule\
          \ = false;\n          const paginatorListRuleNamesByTargetDefaultBus = await\
          \ paginateListRuleNamesByTarget({ client: eventbridge2, pageSize: 10 },\
          \ { TargetArn: `arn:${partition}:events:${region}:${coreAccountId}:event-bus/default`\
          \ });\n          for await (const page of paginatorListRuleNamesByTargetDefaultBus)\
          \ {\n            if (await checkEventBridgeRules(eventbridge2, page.RuleNames,\
          \ bucket.name) === true) {\n              crossAccoutRule = true;\n    \
          \        }\n          }\n          const { Policy: defaultBusPolicyJson\
          \ } = await coreEventbridge.send(new import_client_eventbridge.DescribeEventBusCommand({\n\
          \            Name: \"default\"\n          }));\n          if (defaultBusPolicyJson\
          \ !== void 0) {\n            const defaultBusPolicy = JSON.parse(defaultBusPolicyJson);\n\
          \            if (defaultBusPolicy.Statement.find((s) => s?.Effect === \"\
          Allow\" && s?.Action === \"events:PutEvents\" && (s?.Principal?.AWS ===\
          \ accountId || s?.Principal === \"*\" && s?.Condition?.StringEquals[\"aws:PrincipalOrgID\"\
          ] === organizationId)) !== void 0) {\n              if (crossAccoutRule\
          \ === true) {\n                realtimeEnabled = true;\n              }\n\
          \            }\n          }\n        }\n        const paginatorListRuleNamesByTargetScanQueue\
          \ = await paginateListRuleNamesByTarget({ client: coreEventbridge, pageSize:\
          \ 10 }, { TargetArn: scanQueueArn });\n        for await (const page of\
          \ paginatorListRuleNamesByTargetScanQueue) {\n          if (await checkEventBridgeRules(coreEventbridge,\
          \ page.RuleNames, bucket.name) === true) {\n            realtimeEnabled\
          \ = true;\n          }\n        }\n      }\n      if (notificationData?.TopicConfigurations?.find((config)\
          \ => config.Events.filter((event) => event.startsWith(\"s3:ObjectCreated:\"\
          )).length > 0)) {\n        realtimeEventNotificationEnablePossible = false;\n\
          \      }\n      if (notificationData?.QueueConfigurations?.find((config)\
          \ => config.Events.filter((event) => event.startsWith(\"s3:ObjectCreated:\"\
          )).length > 0)) {\n        realtimeEventNotificationEnablePossible = false;\n\
          \      }\n      if (notificationData?.LambdaFunctionConfigurations?.find((config)\
          \ => config.Events.filter((event) => event.startsWith(\"s3:ObjectCreated:\"\
          )).length > 0)) {\n        realtimeEventNotificationEnablePossible = false;\n\
          \      }\n      if (notificationData?.EventBridgeConfiguration !== void\
          \ 0) {\n        realtimeEventNotificationEnablePossible = false;\n     \
          \ }\n    } catch (err) {\n      console.log(err);\n      bucket.errorMessage\
          \ = `Can not get details for bucket ${bucket.name}: ${err.name}`;\n    \
          \  realtimeEventNotificationEnablePossible = false;\n    }\n    const scheduledStacksIncludesBucket\
          \ = scheduledStacks.stacks.filter((scheduledStack) => includesBucket(scheduledStack,\
          \ bucket.name));\n    if (scheduledStacksIncludesBucket.length > 0) {\n\
          \      scheduledEnabled = true;\n      scheduledStackId = scheduledStacksIncludesBucket[0].id;\n\
          \    }\n    const scheduledStacksHasBucket = scheduledStacks.stacks.filter((scheduledStack)\
          \ => hasBucket(scheduledStack, bucket.name));\n    if (scheduledStacksHasBucket.length\
          \ === 1) {\n      scheduledEnabled = true;\n      scheduledStackDisablePossible\
          \ = true;\n      scheduledStackId = scheduledStacksHasBucket[0].id;\n  \
          \  }\n    return {\n      ...bucket,\n      realtimeEnabled,\n      realtimeEventNotificationEnablePossible,\n\
          \      realtimeEventNotificationDisablePossible,\n      scheduledEnabled,\n\
          \      scheduledStackDisablePossible,\n      scheduledStackId\n    };\n\
          \  } else {\n    return null;\n  }\n}\nasync function getScheduledStacks(ssm2,\
          \ cloudformation2, coreStackName) {\n  const paginatorGetParametersByPath\
          \ = await (0, import_client_ssm.paginateGetParametersByPath)({ client: ssm2\
          \ }, { Recursive: true, Path: `/bucketAV/${coreStackName}/AddOn/scheduled-bucket-scan/`\
          \ });\n  const stacks = [];\n  for await (const page of paginatorGetParametersByPath)\
          \ {\n    const scheduledStackNames = page.Parameters.filter((p) => p.Name.endsWith(\"\
          /Version\")).map((p) => p.Name.split(\"/\")[5]);\n    const describeStacksDataList\
          \ = await Promise.all(scheduledStackNames.map((stackName) => cloudformation2.send(new\
          \ import_client_cloudformation.DescribeStacksCommand({ StackName: stackName\
          \ }))));\n    describeStacksDataList.forEach((describeStacksData) => {\n\
          \      const stack = {\n        name: describeStacksData.Stacks[0].StackName,\n\
          \        id: describeStacksData.Stacks[0].StackId,\n        params: describeStacksData.Stacks[0].Parameters?.reduce((acc,\
          \ param) => {\n          acc[param.ParameterKey] = param.ParameterValue;\n\
          \          return acc;\n        }, {}) || {},\n        outputs: describeStacksData.Stacks[0].Outputs?.reduce((acc,\
          \ output) => {\n          acc[output.OutputKey] = output.OutputValue;\n\
          \          return acc;\n        }, {}) || {}\n      };\n      if (stack.params.BucketAVStackName\
          \ === coreStackName && stack.outputs.AddOn === \"scheduled-bucket-scan\"\
          ) {\n        stacks.push(stack);\n      }\n    });\n  }\n  return {\n  \
          \  stacks\n  };\n}\nasync function getBucket(s3, ssm2, cloudformation2,\
          \ sns2, eventbridge2, coreEventbridge, partition, region, accountId, organizationId,\
          \ coreAccountId, coreStackName, scanQueueArn, bucketName) {\n  const scheduledStacks\
          \ = await getScheduledStacks(ssm2, cloudformation2, coreStackName);\n  const\
          \ bucket = await enrichBucket(s3, sns2, eventbridge2, coreEventbridge, partition,\
          \ region, accountId, organizationId, coreAccountId, coreStackName, scanQueueArn,\
          \ scheduledStacks, bucketName);\n  if (bucket === null) {\n    throw new\
          \ Error(\"bucket region does not match region\");\n  } else {\n    return\
          \ bucket;\n  }\n}\nasync function listBuckets(s3, ssm2, cloudformation2,\
          \ sns2, eventbridge2, coreEventbridge, partition, region, accountId, organizationId,\
          \ coreAccountId, coreStackName, scanQueueArn) {\n  const listBucketsData\
          \ = await s3.send(new import_client_s3.ListBucketsCommand({}));\n  const\
          \ scheduledStacks = await getScheduledStacks(ssm2, cloudformation2, coreStackName);\n\
          \  const buckets = await Promise.all(listBucketsData.Buckets.map((bucket)\
          \ => enrichBucket(s3, sns2, eventbridge2, coreEventbridge, partition, region,\
          \ accountId, organizationId, coreAccountId, coreStackName, scanQueueArn,\
          \ scheduledStacks, bucket.Name)));\n  return buckets.filter((bucket) =>\
          \ bucket !== null);\n}\nasync function fetchS3(defaultS32, dynamodb3, bucketCache,\
          \ isCrossAccount, bucketName, coreStackName) {\n  if (isCrossAccount ===\
          \ true) {\n    const cachedS3 = bucketCache.get(bucketName);\n    if (cachedS3\
          \ !== void 0) {\n      return cachedS3;\n    } else {\n      const bucketCacheData\
          \ = await dynamodb3.send(new import_client_dynamodb.GetItemCommand({\n \
          \       TableName: `${coreStackName}-BucketCache`,\n        Key: {\n   \
          \       bucket_name: { S: bucketName }\n        },\n        ConsistentRead:\
          \ true\n      }));\n      if (bucketCacheData.Item === void 0) {\n     \
          \   console.log(`uncached S3 bucket ${bucketName}`);\n        bucketCache.set(bucketName,\
          \ defaultS32);\n        return defaultS32;\n      } else {\n        if (\"\
          role_arn\" in bucketCacheData.Item && \"external_id\" in bucketCacheData.Item)\
          \ {\n          const configuration = {\n            apiVersion: \"2006-03-01\"\
          ,\n            credentials: (0, import_credential_providers.fromTemporaryCredentials)({\n\
          \              params: {\n                ExternalId: bucketCacheData.Item.external_id.S,\n\
          \                RoleArn: bucketCacheData.Item.role_arn.S,\n           \
          \     RoleSessionName: \"bucketav\"\n              }\n            })\n \
          \         };\n          if (\"bucket_region\" in bucketCacheData.Item) {\n\
          \            configuration.region = bucketCacheData.Item.bucket_region.S;\n\
          \          }\n          const s3 = new import_client_s32.S3Client(configuration);\n\
          \          bucketCache.set(bucketName, s3);\n          return s3;\n    \
          \    } else {\n          bucketCache.set(bucketName, defaultS32);\n    \
          \      return defaultS32;\n        }\n      }\n    }\n  } else {\n    return\
          \ defaultS32;\n  }\n}\nfunction generateAccountConnectionId(partition, region,\
          \ accountId) {\n  return `${partition}:${region}:${accountId}`;\n}\nvar\
          \ MAX_S3_COPY_SIZE = 5 * 1024 * 1024 * 1024;\nfunction generateRoleArn(partition,\
          \ accountId, roleName) {\n  return `arn:${partition}:iam::${accountId}:role/${roleName}`;\n\
          }\nfunction generateRoleArnFromItem(accountConnectionItem) {\n  return generateRoleArn(accountConnectionItem.partition.S,\
          \ accountConnectionItem.account_id.S, accountConnectionItem.role_name.S);\n\
          }\nfunction generateExternalId(stackId) {\n  return stackId.split(\"/\"\
          )[2];\n}\nfunction generateExternalIdFromItem(accountConnectionItem) {\n\
          \  return generateExternalId(accountConnectionItem.stack_id.S);\n}\n\n//\
          \ lambda/refresh-bucket-cache.js\nvar import_client_dynamodb2 = require(\"\
          @aws-sdk/client-dynamodb\");\nvar import_client_cloudformation2 = require(\"\
          @aws-sdk/client-cloudformation\");\nvar import_client_ssm2 = require(\"\
          @aws-sdk/client-ssm\");\nvar import_client_sns2 = require(\"@aws-sdk/client-sns\"\
          );\nvar import_client_eventbridge2 = require(\"@aws-sdk/client-eventbridge\"\
          );\nvar import_client_s33 = require(\"@aws-sdk/client-s3\");\nvar import_credential_providers2\
          \ = require(\"@aws-sdk/credential-providers\");\nvar TTL_IN_SECONDS = 3600;\n\
          var ssm = new import_client_ssm2.SSMClient({ apiVersion: \"2014-11-06\"\
          \ });\nvar cloudformation = new import_client_cloudformation2.CloudFormationClient({\
          \ apiVersion: \"2006-03-01\", maxAttempts: 10 });\nvar dynamodb = new import_client_dynamodb2.DynamoDBClient({\
          \ apiVersion: \"2012-08-10\" });\nasync function cacheBucket(partition,\
          \ region, accountId, { accountConnectionId, roleArn, externalId }, ttl,\
          \ bucket) {\n  const bucketCacheItem = {\n    bucket_name: { S: bucket.name\
          \ },\n    bucket_account_id: { S: bucket.accountId },\n    bucket_realtime_enabled:\
          \ { BOOL: bucket.realtimeEnabled },\n    bucket_realtime_event_notification_disable_possible:\
          \ { BOOL: bucket.realtimeEventNotificationDisablePossible },\n    bucket_realtime_event_notification_enable_possible:\
          \ { BOOL: bucket.realtimeEventNotificationEnablePossible },\n    bucket_scheduled_enabled:\
          \ { BOOL: bucket.scheduledEnabled },\n    bucket_scheduled_stack_disable_possible:\
          \ { BOOL: bucket.scheduledStackDisablePossible },\n    partition: { S: partition\
          \ },\n    region: { S: region },\n    account_id: { S: accountId },\n  \
          \  ttl: { N: ttl.toString() }\n  };\n  if (bucket.organizationId !== void\
          \ 0) {\n    bucketCacheItem.bucket_organization_id = { S: bucket.organizationId\
          \ };\n  }\n  if (accountConnectionId !== void 0) {\n    bucketCacheItem.account_connection_id\
          \ = { S: accountConnectionId };\n    bucketCacheItem.role_arn = { S: roleArn\
          \ };\n    bucketCacheItem.external_id = { S: externalId };\n  }\n  if (bucket.errorMessage\
          \ !== void 0) {\n    bucketCacheItem.bucket_error_message = { S: bucket.errorMessage\
          \ };\n  }\n  if (bucket.region !== void 0) {\n    bucketCacheItem.bucket_region\
          \ = { S: bucket.region };\n  }\n  if (bucket.scheduledStackId !== void 0)\
          \ {\n    bucketCacheItem.bucket_scheduled_stack_id = { S: bucket.scheduledStackId\
          \ };\n  }\n  await dynamodb.send(new import_client_dynamodb2.PutItemCommand({\n\
          \    TableName: `${process.env.CORE_STACK_NAME}-BucketCache`,\n    Item:\
          \ bucketCacheItem\n  }));\n}\nfunction getCredentials(accountConnectionId,\
          \ roleArn, externalId) {\n  if (accountConnectionId !== void 0 && roleArn\
          \ !== void 0 && externalId !== void 0) {\n    return (0, import_credential_providers2.fromTemporaryCredentials)({\n\
          \      params: {\n        RoleArn: roleArn,\n        ExternalId: externalId,\n\
          \        RoleSessionName: \"bucketav\",\n        DurationSeconds: 3600\n\
          \      }\n    });\n  } else {\n    return (0, import_credential_providers2.fromNodeProviderChain)();\n\
          \  }\n}\nfunction generateTtl() {\n  return Math.floor(Date.now() / 1e3)\
          \ + TTL_IN_SECONDS;\n}\nasync function refreshBucket(partition, region,\
          \ accountId, coreAccountId, coreStackName, scanQueueArn, bucketName) {\n\
          \  const accountConnectionId = generateAccountConnectionId(partition, region,\
          \ accountId);\n  const accountConnectionData = await dynamodb.send(new import_client_dynamodb2.GetItemCommand({\n\
          \    TableName: `${coreStackName}-AccountConnection`,\n    Key: {\n    \
          \  account_connection_id: { S: accountConnectionId }\n    },\n    ConsistentRead:\
          \ true\n  }));\n  let accountConnection = {};\n  let credentials;\n  if\
          \ (accountConnectionData.Item !== void 0) {\n    const roleArn = generateRoleArnFromItem(accountConnectionData.Item);\n\
          \    const externalId = generateExternalIdFromItem(accountConnectionData.Item);\n\
          \    credentials = getCredentials(accountConnectionId, roleArn, externalId);\n\
          \    accountConnection.accountConnectionId = accountConnectionId;\n    accountConnection.roleArn\
          \ = roleArn;\n    accountConnection.externalId = externalId;\n    accountConnection.organizationId\
          \ = accountConnectionData.Item.organization_id?.S;\n  } else {\n    accountConnection.organizationId\
          \ = await fetchCachedOrganizationId(ssm, coreStackName);\n    credentials\
          \ = getCredentials(void 0, void 0, void 0);\n  }\n  const s3 = new import_client_s33.S3Client({\
          \ apiVersion: \"2006-03-01\", credentials });\n  const sns2 = new import_client_sns2.SNSClient({\
          \ apiVersion: \"2010-03-31\", credentials });\n  const eventbridge2 = new\
          \ import_client_eventbridge2.EventBridgeClient({ apiVersion: \"2015-10-07\"\
          , credentials });\n  const coreEventbridge = new import_client_eventbridge2.EventBridgeClient({\
          \ apiVersion: \"2015-10-07\" });\n  const bucket = await getBucket(s3, ssm,\
          \ cloudformation, sns2, eventbridge2, coreEventbridge, partition, region,\
          \ accountId, accountConnection.organizationId, coreAccountId, coreStackName,\
          \ scanQueueArn, bucketName);\n  await cacheBucket(partition, region, accountId,\
          \ accountConnection, generateTtl(), bucket);\n}\n\n// lambda/dashboard.js\n\
          var import_credential_providers3 = require(\"@aws-sdk/credential-providers\"\
          );\nvar defaultCloudformation = new import_client_cloudformation3.CloudFormationClient({\
          \ apiVersion: \"2006-03-01\", maxAttempts: 10 });\nvar defaultS3 = new import_client_s34.S3Client({\
          \ apiVersion: \"2006-03-01\" });\nvar defaultSsm = new import_client_ssm3.SSMClient({\
          \ apiVersion: \"2014-11-06\" });\nvar dynamodb2 = new import_client_dynamodb3.DynamoDBClient({\
          \ apiVersion: \"2012-08-10\" });\nvar sns = new import_client_sns3.SNSClient({\
          \ apiVersion: \"2010-03-31\" });\nvar eventbridge = new import_client_eventbridge3.EventBridgeClient({\
          \ apiVersion: \"2015-10-07\" });\nvar sfn = new import_client_sfn.SFNClient({\
          \ apiVersion: \"2016-11-23\" });\nfunction createUrl(region, templateUrl,\
          \ stackName, params) {\n  let url = `https://console.aws.amazon.com/cloudformation/home?region=${region}#/stacks/create/review?templateURL=${encodeURIComponent(templateUrl)}&stackName=${encodeURIComponent(stackName)}`;\n\
          \  Object.keys(params).forEach((key) => {\n    url += `&param_${key}=${encodeURIComponent(params[key])}`;\n\
          \  });\n  return url;\n}\nfunction updateUrl(region, stackId, optionalTemplateUrl)\
          \ {\n  if (optionalTemplateUrl !== void 0) {\n    return `https://console.aws.amazon.com/cloudformation/home?region=${region}#/stacks/update?stackId=${encodeURIComponent(stackId)}&templateURL=${optionalTemplateUrl}`;\n\
          \  } else {\n    return `https://console.aws.amazon.com/cloudformation/home?region=${region}#/stacks/update?stackId=${encodeURIComponent(stackId)}`;\n\
          \  }\n}\nfunction detailsUrl(region, stackId) {\n  return `https://console.aws.amazon.com/cloudformation/home?region=${region}#/stacks/parameters?stackId=${encodeURIComponent(stackId)}`;\n\
          }\nfunction createInstructions(coreAccountId, region, optionalAccountId,\
          \ templateUrl, stackName, params) {\n  let html = \"<ol>\";\n  if (optionalAccountId\
          \ !== coreAccountId) {\n    if (optionalAccountId === void 0) {\n      html\
          \ += \"<li>Login to the new AWS account in a fresh browser session.</li>\"\
          ;\n    } else {\n      html += `<li>Login to AWS account ${optionalAccountId}\
          \ in a fresh browser session.</li>`;\n    }\n  }\n  html += `<li><a href=\"\
          ${createUrl(region, templateUrl, stackName, params)}\" target=\"_blank\"\
          >Open AWS CloudFormation</a>.</li>`;\n  html += \"<li>Review the parameters.</li>\"\
          ;\n  html += \"<li>Scroll to the bottom of the page.</li>\";\n  html +=\
          \ \"<li>Enable <strong>I acknowledge that AWS CloudFormation might create\
          \ IAM resources</strong>.</li>\";\n  html += \"<li>Click <strong>Create\
          \ stack</strong>.</li>\";\n  html += \"</ol>\";\n  return html;\n}\nfunction\
          \ updateInstructions(coreAccountId, region, accountId, stackId, optionalTemplateUrl,\
          \ optionalParameterInstructions) {\n  let html = \"<ol>\";\n  if (accountId\
          \ !== coreAccountId) {\n    html += `<li>Login to AWS account ${accountId}\
          \ in fresh browser session.</li>`;\n  }\n  html += `<li><a href=\"${updateUrl(region,\
          \ stackId, optionalTemplateUrl)}\" target=\"_blank\">Open AWS CloudFormation</a>.</li>`;\n\
          \  html += \"<li>Click <strong>Next</strong>.</li>\";\n  if (optionalParameterInstructions\
          \ !== void 0) {\n    html += `<li>${optionalParameterInstructions}</li>`;\n\
          \  }\n  html += \"<li>Click <strong>Next</strong>.</li>\";\n  html += \"\
          <li>Click <strong>Next</strong>.</li>\";\n  html += \"<li>Select <strong>I\
          \ acknowledge that AWS CloudFormation might create IAM resources</strong>.</li>\"\
          ;\n  html += \"<li>Click <strong>Submit</strong>.</li>\";\n  html += \"\
          </ol>\";\n  return html;\n}\nfunction deleteInstructions(coreAccountId,\
          \ region, accountId, stackId) {\n  let html = \"<ol>\";\n  if (accountId\
          \ !== coreAccountId) {\n    html += `<li>Login to AWS account ${accountId}\
          \ in fresh browser session.</li>`;\n  }\n  html += `<li><a href=\"${detailsUrl(region,\
          \ stackId)}\" target=\"_blank\">Open AWS CloudFormation</a>.</li>`;\n  html\
          \ += \"<li>Click <strong>Delete</strong>.</li>\";\n  html += \"</ol>\";\n\
          \  return html;\n}\nfunction htmlRealtime(bucket, lambdaArn) {\n  if (\"\
          errorMessage\" in bucket) {\n    return `\\u26A0\\uFE0F Error (<a>Details</a>)<cwdb-action\
          \ display=\"popup\"><h1>Real-time file scan</h1>An error occurred: ${bucket.errorMessage}.</cwdb-action>`;\n\
          \  } else if (bucket.realtimeEnabled === true) {\n    if (bucket.realtimeEventNotificationDisablePossible\
          \ === true) {\n      return `\\u2705 <a class=\"btn\">Disable</a><cwdb-action\
          \ action=\"call\" endpoint=\"${lambdaArn}\">{\"action\": \"disableEventNotification\"\
          , \"bucketName\": \"${bucket.name}\", \"bucketRegion\": \"${bucket.region}\"\
          , \"bucketAccountId\": \"${bucket.accountId}\"}</cwdb-action>`;\n    } else\
          \ {\n      return '\\u2705 <a class=\"btn\">Disable</a><cwdb-action display=\"\
          popup\"><h1>Real-time file scan</h1>It is not possible to disable real-time\
          \ file scanning automatically. To manually disable real-time file scanning,\
          \ please follow our <a href=\"https://bucketav.com/help/scan-modes/real-time-file-scan.html\"\
          \ target=\"_blank\">documentation</a>.</cwdb-action>';\n    }\n  } else\
          \ {\n    if (bucket.realtimeEventNotificationEnablePossible === true) {\n\
          \      return `\\u274C <a class=\"btn btn-primary\">Enable</a><cwdb-action\
          \ action=\"call\" endpoint=\"${lambdaArn}\">{\"action\": \"enableEventNotification\"\
          , \"bucketName\": \"${bucket.name}\", \"bucketRegion\": \"${bucket.region}\"\
          , \"bucketAccountId\": \"${bucket.accountId}\"}</cwdb-action>`;\n    } else\
          \ {\n      return '\\u274C <a class=\"btn btn-primary\">Enable</a><cwdb-action\
          \ display=\"popup\"><h1>Real-time file scan</h1>It is not possible to enable\
          \ real-time file scanning automatically because of an existing S3 Event\
          \ Notification or EventBridge configuration. To manually enable real-time\
          \ file scanning, please follow our <a href=\"https://bucketav.com/help/scan-modes/real-time-file-scan.html\"\
          \ target=\"_blank\">documentation</a>.</cwdb-action>';\n    }\n  }\n}\n\
          function htmlScheduled(bucket, region, coreAccountId, coreStackName, scheduledTemplateUrl)\
          \ {\n  let scheduledStackName = \"bucketav-scheduled-bucket-scan-\";\n \
          \ scheduledStackName += bucket.name.replaceAll(\".\", \"D\");\n  if (\"\
          errorMessage\" in bucket) {\n    return `\\u26A0\\uFE0F Error (<a>Details</a>)<cwdb-action\
          \ display=\"popup\"><h1>Scheduled bucket scan</h1>An error occurred: ${bucket.errorMessage}.</cwdb-action>`;\n\
          \  } else if (bucket.scheduledEnabled === true) {\n    if (bucket.scheduledStackDisablePossible\
          \ === true) {\n      let html = '\\u2705 <a class=\"btn\">Disable</a>';\n\
          \      html += '<cwdb-action display=\"popup\">';\n      html += \"<h1>Scheduled\
          \ bucket scan</h1>\";\n      html += `<p>To disable scheduled bucket scanning\
          \ for bucket ${bucket.name}:</p>`;\n      html += deleteInstructions(coreAccountId,\
          \ region, coreAccountId, bucket.scheduledStackId);\n      html += \"</cwdb-action>\"\
          ;\n      return html;\n    } else {\n      let html = '\\u2705 <a class=\"\
          btn\">Disable</a>';\n      html += '<cwdb-action display=\"popup\">';\n\
          \      html += \"<h1>Scheduled bucket scan</h1>\";\n      html += `<p>It\
          \ is not yet possible to disable scheduled bucket scanning for bucket ${bucket.name}\
          \ automatically. `;\n      if (bucket.scheduledStackId) {\n        html\
          \ += `The CloudFormation stack ${bucket.scheduledStackId} scans this bucket.`;\n\
          \      }\n      html += 'To manually disable scheduled bucket scanning,\
          \ please follow our <a href=\"https://bucketav.com/help/scan-modes/scheduled-bucket-scan.html\"\
          \ target=\"_blank\">documentation</a>.</p>';\n      html += \"</cwdb-action>\"\
          ;\n      return html;\n    }\n  } else {\n    let html = '\\u274C <a class=\"\
          btn btn-primary\">Enable</a>';\n    html += '<cwdb-action display=\"popup\"\
          >';\n    html += \"<h1>Scheduled bucket scan</h1>\";\n    html += `<p>To\
          \ enable scheduled bucket scanning for bucket ${bucket.name}:</p>`;\n  \
          \  html += createInstructions(coreAccountId, region, coreAccountId, scheduledTemplateUrl,\
          \ scheduledStackName, { BucketAVStackName: coreStackName, BucketName: bucket.name\
          \ });\n    html += \"</cwdb-action>\";\n    return html;\n  }\n}\nasync\
          \ function fetchLatest() {\n  const url = \"https://bucketav.com/data/latest.json\"\
          ;\n  const res = await fetch(url);\n  if (res.status !== 200) {\n    console.log(\"\
          request\", url);\n    console.log(\"response status\", res.status);\n  \
          \  console.log(\"response\", await res.text());\n    throw new Error(\"\
          unexpected status code\");\n  }\n  return res.json();\n}\nasync function\
          \ fetchOutdatedAddons(coreStackname, latest, isCrossAccount, corePartition,\
          \ coreRegion, coreAccountId) {\n  const outdatedAddons = [];\n  const fn\
          \ = async (ssm2, cloudformation2, partition, region, accountId) => {\n \
          \   const cloudformaionDescribeStacksLimit = pLimit(8);\n    const paginatorGetParametersByPath\
          \ = await (0, import_client_ssm3.paginateGetParametersByPath)({ client:\
          \ ssm2 }, { Recursive: true, Path: `/bucketAV/${coreStackname}/AddOn/` });\n\
          \    for await (const page of paginatorGetParametersByPath) {\n      const\
          \ addons = page.Parameters.filter((p) => p.Name.endsWith(\"/Version\")).map((p)\
          \ => {\n        const [, , , , addonType, addonStackName] = p.Name.split(\"\
          /\");\n        const addonVersion = p.Value;\n        const addon = {\n\
          \          type: addonType,\n          partition,\n          region,\n \
          \         accountId,\n          stackName: addonStackName,\n          version:\
          \ addonVersion,\n          latestVersion: latest[addonType].version.substr(1),\n\
          \          releaseNotesPageUrl: latest[addonType].releaseNotesPageUrl\n\
          \        };\n        if (\"template\" in latest[addonType]) {\n        \
          \  addon.latestTemplateUrl = latest[addonType].template;\n        }\n  \
          \      if (\"templates\" in latest[addonType]) {\n          addon.latestTemplateUrls\
          \ = latest[addonType].templates;\n        }\n        return addon;\n   \
          \   });\n      const innerOutdatedAddons = await Promise.all(addons.filter((addon)\
          \ => addon.version !== addon.latestVersion).map((addon) => {\n        return\
          \ cloudformaionDescribeStacksLimit(async () => {\n          const data =\
          \ await cloudformation2.send(new import_client_cloudformation3.DescribeStacksCommand({\
          \ StackName: addon.stackName })).then((data2) => data2.Stacks[0]);\n   \
          \       addon.stackId = data.StackId;\n          if (!(\"latestTemplateUrl\"\
          \ in addon)) {\n            if (\"latestTemplateUrls\" in addon) {\n   \
          \           const engine = data?.Outputs?.find((output) => output.OutputKey\
          \ === \"Engine\")?.OutputValue;\n              const fulfillmentOption =\
          \ data?.Outputs?.find((output) => output.OutputKey === \"FulfillmentOption\"\
          )?.OutputValue;\n              addon.latestTemplateUrl = addon.latestTemplateUrls?.[engine]?.[fulfillmentOption];\n\
          \              delete addon.latestTemplateUrls;\n            } else {\n\
          \              throw new Error(\"missing latestTemplateUrl and latestTemplateUrls\"\
          );\n            }\n          }\n          return addon;\n        });\n \
          \     }));\n      outdatedAddons.push(...innerOutdatedAddons);\n    }\n\
          \  };\n  if (isCrossAccount === true) {\n    await fn(defaultSsm, defaultCloudformation,\
          \ corePartition, coreRegion, coreAccountId);\n    const paginatorScan =\
          \ await (0, import_client_dynamodb3.paginateScan)({ client: dynamodb2 },\
          \ { TableName: `${coreStackname}-AccountConnection` });\n    for await (const\
          \ page of paginatorScan) {\n      await Promise.all(page.Items.map((item)\
          \ => {\n        const externalId = generateExternalIdFromItem(item);\n \
          \       const roleArn = generateRoleArnFromItem(item);\n        const credentials\
          \ = (0, import_credential_providers3.fromTemporaryCredentials)({\n     \
          \     params: {\n            ExternalId: externalId,\n            RoleArn:\
          \ roleArn,\n            RoleSessionName: \"bucketav\"\n          }\n   \
          \     });\n        const ssm2 = new import_client_ssm3.SSMClient({ apiVersion:\
          \ \"2014-11-06\", credentials });\n        const cloudformation2 = new import_client_cloudformation3.CloudFormationClient({\
          \ apiVersion: \"2006-03-01\", credentials, maxAttempts: 10 });\n       \
          \ return fn(ssm2, cloudformation2, item.partition.S, item.region.S, item.account_id.S);\n\
          \      }));\n    }\n  } else {\n    await fn(defaultSsm, defaultCloudformation,\
          \ corePartition, coreRegion, coreAccountId);\n  }\n  return outdatedAddons;\n\
          }\nasync function handler(event, context) {\n  console.log(`Invoke: ${JSON.stringify(event)}\
          \ ${JSON.stringify(context)}`);\n  const latest = await fetchLatest();\n\
          \  const scheduledTemplateUrl = latest[\"scheduled-bucket-scan\"].template;\n\
          \  if (event.widgetContext.params.view === \"update\") {\n    const describeStacksData\
          \ = await defaultCloudformation.send(new import_client_cloudformation3.DescribeStacksCommand({\
          \ StackName: process.env.CORE_STACK_NAME }));\n    const runningEngine =\
          \ describeStacksData.Stacks[0].Outputs.find((output) => output.OutputKey\
          \ === \"Engine\").OutputValue;\n    const runningVersion = describeStacksData.Stacks[0].Outputs.find((output)\
          \ => output.OutputKey === \"Version\").OutputValue;\n    const runningFulfillmentOption\
          \ = describeStacksData.Stacks[0].Outputs.find((output) => output.OutputKey\
          \ === \"FulfillmentOption\").OutputValue;\n    const outdatedAddons = await\
          \ fetchOutdatedAddons(process.env.CORE_STACK_NAME, latest, process.env.CROSS_ACCOUNT\
          \ === \"true\", process.env.AWS_PARTITION, process.env.AWS_REGION, process.env.AWS_ACCOUNT_ID);\n\
          \    const latestVersion = latest[runningEngine].version.substr(1);\n  \
          \  let html = 'Monthly digest of security updates, new capabilities, and\
          \ best practices: <a href=\"https://bucketav.com/newsletter/\" target=\"\
          _blank\">Subscribe to the bucketAV newsletter!</a>';\n    html += \"<hr>\"\
          ;\n    if (latestVersion !== runningVersion) {\n      const templateUrl\
          \ = latest[runningEngine].templates[runningFulfillmentOption];\n      html\
          \ += \"<p>\\u26A0\\uFE0F bucketAV requires an update.</p>\";\n      html\
          \ += '<table style=\"width:100%\">';\n      html += \"<thead>\";\n     \
          \ html += \"<tr>\";\n      html += \"<th>CloudFormation<br>Stack&nbsp;Name</th>\"\
          ;\n      html += \"<th>Version</th>\";\n      html += \"<th>&nbsp;</th>\"\
          ;\n      html += \"</tr>\";\n      html += \"</thead>\";\n      html +=\
          \ \"<tbody>\";\n      html += \"<tr>\";\n      html += `<td>${process.env.CORE_STACK_NAME}</td>`;\n\
          \      html += `<td>Running:&nbsp;${runningVersion}<br>Latest:&nbsp;${latestVersion}</td>`;\n\
          \      html += '<td><a class=\"btn btn-primary\">Update</a>';\n      html\
          \ += '<cwdb-action display=\"popup\">';\n      html += \"<h1>Update bucketAV</h1>\"\
          ;\n      html += \"<p>bucketAV supports updates without downtime. You don\\\
          u2019t need to be afraid of updating bucketAV, even when files are scanned.</p>\"\
          ;\n      html += updateInstructions(process.env.AWS_ACCOUNT_ID, process.env.AWS_REGION,\
          \ process.env.AWS_ACCOUNT_ID, process.env.CORE_STACK_ID, templateUrl);\n\
          \      html += `</cwdb-action><br><a href=\"https://bucketav.com/help/release-notes/#${process.env.ENGINE}\"\
          \ target=\"_blank\">Release&nbsp;Notes</a>`;\n      html += \"</td>\";\n\
          \      html += \"</tr>\";\n      html += \"</tbody>\";\n      html += \"\
          </table>\";\n    } else {\n      html += \"<p>\\u2705 bucketAV is up-to-date.</p>\"\
          ;\n    }\n    if (latestVersion !== runningVersion && outdatedAddons.length\
          \ > 0) {\n      html += \"<hr>\";\n    }\n    if (outdatedAddons.length\
          \ > 0) {\n      html += \"<p>\\u26A0\\uFE0F Add-Ons require updates*.</p>\"\
          ;\n      html += '<table style=\"width:100%\">';\n      html += \"<thead>\"\
          ;\n      html += \"<tr>\";\n      html += \"<th>Add-On</th>\";\n      html\
          \ += \"<th>AWS Account</th>\";\n      html += \"<th>CloudFormation<br>Stack&nbsp;Name</th>\"\
          ;\n      html += \"<th>Version</th>\";\n      html += \"<th>&nbsp;</th>\"\
          ;\n      html += \"</tr>\";\n      html += \"</thead>\";\n      html +=\
          \ \"<tbody>\";\n      for (const outdatedAddon of outdatedAddons) {\n  \
          \      html += \"<tr>\";\n        html += `<td>${outdatedAddon.type}</td>`;\n\
          \        html += `<td>${outdatedAddon.accountId}</td>`;\n        html +=\
          \ `<td>${outdatedAddon.stackName}</td>`;\n        html += `<td>Running:&nbsp;${outdatedAddon.version}<br>Latest:&nbsp;${outdatedAddon.latestVersion}</td>`;\n\
          \        html += '<td><a class=\"btn btn-primary\">Update</a>';\n      \
          \  html += '<cwdb-action display=\"popup\">';\n        html += \"<h1>Update\
          \ Add-On</h1>\";\n        html += `<p>To update Add-On ${outdatedAddon.type}\
          \ (stack name ${outdatedAddon.stackName}) in AWS account ${outdatedAddon.accountId}:</p>`;\n\
          \        html += updateInstructions(process.env.AWS_ACCOUNT_ID, outdatedAddon.region,\
          \ outdatedAddon.accountId, outdatedAddon.stackId, outdatedAddon.latestTemplateUrl);\n\
          \        html += `</cwdb-action><br><a href=\"${outdatedAddon.releaseNotesPageUrl}\"\
          \ target=\"_blank\">Release&nbsp;Notes</a>`;\n        html += \"</td>\"\
          ;\n        html += \"</tr>\";\n      }\n      html += \"</tbody>\";\n  \
          \    html += \"</table>\";\n    } else {\n      html += \"<p>\\u2705 Add-Ons\
          \ are up-to-date*.</p>\";\n    }\n    html += '<p><small>* Add-Ons with\
          \ <a href=\"https://bucketav.com/add-ons/#service-discovery\" target=\"\
          _blank\">service discovery</a> are included in the out-of-date check. Please\
          \ update older Add-Ons manually.</small></p>';\n    return html;\n  } else\
          \ if (event.widgetContext.params.view === \"buckets\") {\n    if (event.action\
          \ === \"enableEventNotification\") {\n      const s3 = await fetchS3(defaultS3,\
          \ dynamodb2, /* @__PURE__ */ new Map(), process.env.CROSS_ACCOUNT === \"\
          true\", event.bucketName, process.env.CORE_STACK_NAME);\n      const notificationConfiguration\
          \ = await s3.send(new import_client_s34.GetBucketNotificationConfigurationCommand({\
          \ Bucket: event.bucketName, ExpectedBucketOwner: event.bucketAccountId }));\n\
          \      if (!(\"QueueConfigurations\" in notificationConfiguration)) {\n\
          \        notificationConfiguration.QueueConfigurations = [];\n      }\n\
          \      notificationConfiguration.QueueConfigurations.push({\n        Id:\
          \ \"bucketav\",\n        Events: [\"s3:ObjectCreated:*\"],\n        QueueArn:\
          \ process.env.SCAN_QUEUE_ARN\n      });\n      await s3.send(new import_client_s34.PutBucketNotificationConfigurationCommand({\
          \ Bucket: event.bucketName, NotificationConfiguration: notificationConfiguration,\
          \ ExpectedBucketOwner: event.bucketAccountId }));\n      if (process.env.CROSS_ACCOUNT\
          \ === \"true\") {\n        await refreshBucket(process.env.AWS_PARTITION,\
          \ event.bucketRegion, event.bucketAccountId, process.env.AWS_ACCOUNT_ID,\
          \ process.env.CORE_STACK_NAME, process.env.SCAN_QUEUE_ARN, event.bucketName);\n\
          \      }\n    } else if (event.action === \"disableEventNotification\")\
          \ {\n      const s3 = await fetchS3(defaultS3, dynamodb2, /* @__PURE__ */\
          \ new Map(), process.env.CROSS_ACCOUNT === \"true\", event.bucketName, process.env.CORE_STACK_NAME);\n\
          \      const notificationConfiguration = await s3.send(new import_client_s34.GetBucketNotificationConfigurationCommand({\
          \ Bucket: event.bucketName, ExpectedBucketOwner: event.bucketAccountId }));\n\
          \      notificationConfiguration.QueueConfigurations = notificationConfiguration.QueueConfigurations.filter((config)\
          \ => !(config.QueueArn === process.env.SCAN_QUEUE_ARN && config.Events.includes(\"\
          s3:ObjectCreated:*\")));\n      await s3.send(new import_client_s34.PutBucketNotificationConfigurationCommand({\
          \ Bucket: event.bucketName, NotificationConfiguration: notificationConfiguration,\
          \ ExpectedBucketOwner: event.bucketAccountId }));\n      if (process.env.CROSS_ACCOUNT\
          \ === \"true\") {\n        await refreshBucket(process.env.AWS_PARTITION,\
          \ event.bucketRegion, event.bucketAccountId, process.env.AWS_ACCOUNT_ID,\
          \ process.env.CORE_STACK_NAME, process.env.SCAN_QUEUE_ARN, event.bucketName);\n\
          \      }\n    } else if (event.action === \"refreshBucketCache\" && process.env.CROSS_ACCOUNT\
          \ === \"true\") {\n      await sfn.send(new import_client_sfn.StartExecutionCommand({\n\
          \        stateMachineArn: process.env.REFRESH_BUCKET_CACHE_STATE_MACHINE_ARN\n\
          \      }));\n      return `<p>\\u{1F504} Bucket cache refresh initiated.\
          \ Please wait a minute and then <a>reload</a>.<cwdb-action action=\"call\"\
          \ endpoint=\"${context.invokedFunctionArn}\">{}</cwdb-action></p>`;\n  \
          \  }\n    let buckets = process.env.CROSS_ACCOUNT === \"true\" ? await listCachedBuckets(dynamodb2,\
          \ process.env.CORE_STACK_NAME) : await listBuckets(defaultS3, defaultSsm,\
          \ defaultCloudformation, sns, eventbridge, eventbridge, process.env.AWS_PARTITION,\
          \ process.env.AWS_REGION, process.env.AWS_ACCOUNT_ID, void 0, process.env.AWS_ACCOUNT_ID,\
          \ process.env.CORE_STACK_NAME, process.env.SCAN_QUEUE_ARN);\n    const bucketSearch\
          \ = event?.widgetContext?.forms?.all?.bucketSearch || event.bucketSearch\
          \ || \"\";\n    if (bucketSearch !== \"\") {\n      buckets = buckets.filter((bucket)\
          \ => bucket.name.includes(bucketSearch));\n    }\n    const accountSearch\
          \ = event?.widgetContext?.forms?.all?.accountSearch || event.accountSearch\
          \ || \"\";\n    if (accountSearch !== \"\") {\n      buckets = buckets.filter((bucket)\
          \ => bucket.accountId.includes(accountSearch));\n    }\n    buckets.sort((bucket1,\
          \ bucket2) => bucket1.name.localeCompare(bucket2.name));\n    const page\
          \ = \"page\" in event ? event.page : 0;\n    const limit = 100;\n    const\
          \ pageStartInclusive = page * limit;\n    const pageEndExclusive = pageStartInclusive\
          \ + limit;\n    const tbody = buckets.slice(pageStartInclusive, pageEndExclusive).map((bucket)\
          \ => {\n      let html2 = \"<tr>\";\n      html2 += `<td>${bucket.name}</td>`;\n\
          \      html2 += `<td>${bucket.accountId}</td>`;\n      html2 += `<td>${htmlRealtime(bucket,\
          \ context.invokedFunctionArn)}</td>`;\n      html2 += `<td>${htmlScheduled(bucket,\
          \ process.env.AWS_REGION, process.env.AWS_ACCOUNT_ID, process.env.CORE_STACK_NAME,\
          \ scheduledTemplateUrl)}</td>`;\n      html2 += \"</tr>\";\n      return\
          \ html2;\n    }).join(\"\");\n    let html = \"<form>\";\n    html += '<table\
          \ style=\"width:100%\">';\n    if (process.env.CROSS_ACCOUNT === \"true\"\
          ) {\n      html += `<caption>Includes buckets from AWS region ${process.env.AWS_REGION}.<br>Buckets\
          \ are cached and may be stale (<a>Refresh bucket cache</a>).<cwdb-action\
          \ action=\"call\" endpoint=\"${context.invokedFunctionArn}\">{\"action\"\
          : \"refreshBucketCache\"}</cwdb-action></caption>`;\n    } else {\n    \
          \  html += `<caption>Includes buckets from AWS region ${process.env.AWS_REGION}.</caption>`;\n\
          \    }\n    html += \"<thead>\";\n    html += \"<tr>\";\n    html += `<th><input\
          \ type=\"text\" name=\"bucketSearch\" placeholder=\"Bucket\" value=\"${bucketSearch}\"\
          \ style=\"width:90%;margin-bottom:0\">&nbsp;<a>\\u{1F50D}</a><cwdb-action\
          \ action=\"call\" endpoint=\"${context.invokedFunctionArn}\">{}</cwdb-action></th>`;\n\
          \    html += `<th><input type=\"text\" name=\"accountSearch\" placeholder=\"\
          AWS Account\" value=\"${accountSearch}\" style=\"width:90%;margin-bottom:0\"\
          >&nbsp;<a>\\u{1F50D}</a><cwdb-action action=\"call\" endpoint=\"${context.invokedFunctionArn}\"\
          >{}</cwdb-action></th>`;\n    html += \"<th>Real-time file scan</th>\";\n\
          \    html += \"<th>Scheduled bucket scan</th>\";\n    html += \"</tr>\"\
          ;\n    html += \"</thead>\";\n    html += `<tbody>${tbody}</tbody>`;\n \
          \   if (process.env.CROSS_ACCOUNT === \"true\") {\n      html += \"<tfoot>\"\
          ;\n      html += \"<tr>\";\n      html += '<th colspan=\"4\" style=\"text-align:center;\"\
          >';\n      if (pageStartInclusive > 0) {\n        html += `<a>Previous</a><cwdb-action\
          \ action=\"call\" endpoint=\"${context.invokedFunctionArn}\">{\"page\":\
          \ ${page - 1}}</cwdb-action>`;\n      }\n      if (pageStartInclusive >\
          \ 0 && pageEndExclusive < buckets.length) {\n        html += \"&nbsp;|&nbsp;\"\
          ;\n      }\n      if (pageEndExclusive < buckets.length) {\n        html\
          \ += `<a>Next</a><cwdb-action action=\"call\" endpoint=\"${context.invokedFunctionArn}\"\
          >{\"page\": ${page + 1}}</cwdb-action>`;\n      }\n      html += \"</th>\"\
          ;\n      html += \"</tr>\";\n      html += \"</tfoot>\";\n    }\n    html\
          \ += \"</table>\";\n    html += \"</form>\";\n    return html;\n  } else\
          \ if (event.widgetContext.params.view === \"accounts\") {\n    if (process.env.CROSS_ACCOUNT\
          \ === \"true\") {\n      const accountConnectionTemplateUrl = latest[\"\
          account-connection\"].template;\n      const paginatorScan = await (0, import_client_dynamodb3.paginateScan)({\
          \ client: dynamodb2 }, { TableName: `${process.env.CORE_STACK_NAME}-AccountConnection`\
          \ });\n      const accounts = [];\n      for await (const page of paginatorScan)\
          \ {\n        page.Items.forEach((item) => {\n          accounts.push({\n\
          \            accountId: item.account_id.S,\n            region: item.region.S,\n\
          \            stackId: item.stack_id.S\n          });\n        });\n    \
          \  }\n      accounts.sort((account1, account2) => account1.accountId.localeCompare(account2.accountId));\n\
          \      const tbody = accounts.map((account) => {\n        let html2 = \"\
          <tr>\";\n        html2 += `<td>${account.accountId}</td>`;\n        html2\
          \ += '<td><a class=\"btn\">Disconnect</a>';\n        html2 += '<cwdb-action\
          \ display=\"popup\">';\n        html2 += \"<h1>Disconnect</h1>\";\n    \
          \    html2 += `<p>To disconnect AWS account ${account.accountId}:</p>`;\n\
          \        html2 += deleteInstructions(process.env.AWS_ACCOUNT_ID, account.region,\
          \ account.accountId, account.stackId);\n        html2 += \"</cwdb-action>\"\
          ;\n        html2 += \"</td>\";\n        html2 += \"</tr>\";\n        return\
          \ html2;\n      }).join(\"\");\n      let html = '<table style=\"width:100%\"\
          >';\n      html += \"<thead>\";\n      html += \"<tr>\";\n      html +=\
          \ \"<th>AWS account</th>\";\n      html += \"<th>&nbsp;</th>\";\n      html\
          \ += \"</tr>\";\n      html += \"</thead>\";\n      html += \"<tbody>\"\
          ;\n      html += \"<tr>\";\n      html += `<td>${process.env.AWS_ACCOUNT_ID}</td>`;\n\
          \      html += \"<td>Runs bucketAV, always connected;</td>\";\n      html\
          \ += \"</tr>\";\n      html += tbody;\n      html += \"</tbody>\";\n   \
          \   html += \"<tfoot>\";\n      html += \"<tr>\";\n      html += \"<th>&nbsp;</th>\"\
          ;\n      html += '<th><a class=\"btn btn-primary\">Connect AWS account</a>';\n\
          \      html += '<cwdb-action display=\"popup\">';\n      html += \"<h1>Connect</h1>\"\
          ;\n      html += \"<p>Connecting a new AWS account with bucketAV is a two-step\
          \ process:</p>\";\n      html += \"<ol>\";\n      html += \"<li>Configure\
          \ bucketAV to trust the new AWS account.</li>\";\n      html += \"<li>Connect\
          \ the new AWS account to bucketAV.</li>\";\n      html += \"</ol>\";\n \
          \     html += \"<h2>Trust AWS account</h2>\";\n      html += \"<p>To trust\
          \ the new AWS account, in this AWS account:</p>\";\n      html += \"<ol>\"\
          ;\n      html += updateInstructions(process.env.AWS_ACCOUNT_ID, process.env.AWS_REGION,\
          \ process.env.AWS_ACCOUNT_ID, process.env.CORE_STACK_ID, void 0, 'Modify\
          \ the <strong>AWSOrganizationRestriction</strong> or <strong>AWSAccountRestriction</strong>\
          \ parameter. <a href=\"https://bucketav.com/help/operations/multi-account-setup.html#prepare-bucketav\"\
          \ target=\"_blank\">Learn more</a>!</li>');\n      html += \"</ol>\";\n\
          \      html += \"<h2>Connect AWS account</h2>\";\n      html += '<p><small>If\
          \ you plan to connect many AWS accounts we recommend to use AWS CloudFormation\
          \ StackSets. <a href=\"https://bucketav.com/help/operations/multi-account-setup.html#connect-iam-stacksets\"\
          \ target=\"_blank\">Learn more</a>!</small></p>';\n      html += \"<p>To\
          \ connect the new AWS account:</p>\";\n      html += createInstructions(process.env.AWS_ACCOUNT_ID,\
          \ process.env.AWS_REGION, void 0, accountConnectionTemplateUrl, \"bucketav-account-connection\"\
          , { BucketAVStackName: process.env.CORE_STACK_NAME, BucketAVAccountId: process.env.AWS_ACCOUNT_ID\
          \ });\n      html += \"</cwdb-action>\";\n      html += \"</th>\";\n   \
          \   html += \"</tr>\";\n      html += \"</tfoot>\";\n      html += \"</table>\"\
          ;\n      return html;\n    } else {\n      return 'You can use bucketAV\
          \ with multiple AWS accounts. <a href=\"https://bucketav.com/help/operations/multi-account-setup.html\"\
          \ target=\"_blank\">Learn more</a>!';\n    }\n  }\n}\n// Annotate the CommonJS\
          \ export names for ESM import in node:\n0 && (module.exports = {\n  handler\n\
          });\n"
      Environment:
        Variables:
          CORE_STACK_NAME: !Ref 'AWS::StackName'
          CORE_STACK_ID: !Ref 'AWS::StackId'
          ENGINE: clamav
          AWS_PARTITION: !Ref 'AWS::Partition'
          AWS_ACCOUNT_ID: !Ref 'AWS::AccountId'
          SCAN_QUEUE_ARN: !GetAtt [ScanQueue, Arn]
          CROSS_ACCOUNT: !If [HasCrossAccount, 'true', 'false']
          REFRESH_BUCKET_CACHE_STATE_MACHINE_ARN: !If [HasCrossAccount, !GetAtt [
              RefreshBucketCacheStateMachine, Arn], !Ref 'AWS::NoValue']
      Handler: index.handler
      MemorySize: 1769
      Role: !GetAtt [DashboardLambdaRole, Arn]
      Runtime: nodejs20.x
      Timeout: 300
  DashboardLambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join ['', [/aws/lambda/, !Ref 'DashboardLambdaFunction']]
      RetentionInDays: !Ref 'LogsRetentionInDays'
  DashboardLambdaPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Statement:
        - Effect: Allow
          Action:
          - logs:CreateLogStream
          - logs:PutLogEvents
          Resource: !GetAtt [DashboardLambdaLogGroup, Arn]
      PolicyName: logs
      Roles:
      - !Ref 'DashboardLambdaRole'
  Dashboard:
    Type: AWS::CloudWatch::Dashboard
    Properties:
      DashboardBody: !Join ['', ['{"start":"-PT24H","widgets":[{"type":"metric","x":0,"y":0,"height":3,"width":16,"properties":{"sparkline":false,"view":"singleValue","metrics":[["AWS/SQS","NumberOfMessagesSent","QueueName","',
          !GetAtt [ScanQueue, QueueName], '",{"yAxis":"right","stat":"Sum","label":"Files
            enqueued"}],[".","NumberOfMessagesDeleted",".",".",{"yAxis":"right","stat":"Sum","label":"Files
            processed"}],["', !Ref 'AWS::StackName', '","clean",{"stat":"Sum","label":"Clean"}],[".","infected",{"stat":"Sum","color":"#d62728","label":"Infected"}],[".","no",{"stat":"Sum","color":"#ff7f0e","label":"Unscannable
            (too big, access denied)"}],[".","scanned_data",{"stat":"Sum","label":"Scanned
            data (GB)"}]],"region":"', !Ref 'AWS::Region', '","title":"bucketAV powered
            by ClamAV (dedicated-private-vpc) - Overview","liveData":true,"setPeriodToTimeRange":true,"trend":false,"singleValueFullPrecision":false}},{"type":"custom","x":16,"y":0,"width":8,"height":8,"properties":{"endpoint":"',
          !GetAtt [DashboardLambdaFunction, Arn], '","updateOn":{"refresh":true,"resize":false,"timeRange":false},"params":{"view":"update"},"title":"Update"}},{"type":"metric","x":0,"y":3,"width":4,"height":5,"properties":{"metrics":[["',
          !Ref 'AWS::StackName', '","clean",{"stat":"Sum","label":"Clean"}],[".","infected",{"stat":"Sum","color":"#d62728","label":"Infected"}],[".","no",{"stat":"Sum","color":"#ff7f0e","label":"Unscannable
            (too big, access denied)"}]],"view":"timeSeries","stacked":true,"region":"',
          !Ref 'AWS::Region', '","title":"Scan Results","period":60,"liveData":true}},{"type":"metric","x":4,"y":3,"width":4,"height":5,"properties":{"metrics":[["AWS/SQS","ApproximateNumberOfMessagesVisible","QueueName","',
          !GetAtt [ScanQueue, QueueName], '",{"stat":"Maximum","label":"Queue Length"}],[".","NumberOfMessagesSent",".",".",{"yAxis":"right","stat":"Sum","label":"Files
            enqueued"}],[".","NumberOfMessagesDeleted",".",".",{"yAxis":"right","stat":"Sum","label":"Files
            processed"}]],"view":"timeSeries","stacked":false,"region":"', !Ref 'AWS::Region',
          '","title":"Scan Queue","period":60,"liveData":true}},{"type":"metric","x":8,"y":3,"width":4,"height":5,"properties":{"metrics":[["AWS/AutoScaling","GroupInServiceInstances","AutoScalingGroupName","',
          !Ref 'ScanAutoScalingGroup', '",{"stat":"Average","label":"Running Instances"}]],"view":"timeSeries","stacked":false,"region":"',
          !Ref 'AWS::Region', '","title":"Scan Fleet","period":60,"liveData":true,"annotations":{"horizontal":[{"label":"AutoScalingMinSize","value":',
          !Ref 'AutoScalingMinSize', '},{"label":"AutoScalingMaxSize","value":', !Ref 'AutoScalingMaxSize',
          '}]}}},{"type":"alarm","x":12,"y":3,"width":4,"height":5,"properties":{"title":"Infrastructure
            Alarms","alarms":["', !GetAtt [DeadLetterQueueAlarm, Arn], '","', !GetAtt [
            ScanQueueOldMessagesAlarm, Arn], '","', !GetAtt [SignaturesAgeAlarm, Arn],
          '"]}},{"type":"log","x":0,"y":8,"width":8,"height":8,"properties":{"query":"SOURCE
            ''', !Ref 'Logs', ''' | fields @message | filter @logStream like \"/var/log/messages\"
            and @message like \"bucketav[\" | sort @timestamp desc | limit 1000","region":"',
          !Ref 'AWS::Region', '","stacked":false,"title":"Scan Logs","view":"table"}},{"type":"log","x":8,"y":8,"width":8,"height":8,"properties":{"query":"SOURCE
            ''', !Ref 'Logs', ''' | fields @message | filter not(@logStream like \"/var/log/messages\"
            and @message like \"bucketav[\") | sort @timestamp desc | limit 1000","region":"',
          !Ref 'AWS::Region', '","stacked":false,"title":"System Logs","view":"table"}},{"type":"custom","x":16,"y":8,"width":8,"height":8,"properties":{"endpoint":"',
          !GetAtt [DashboardLambdaFunction, Arn], '","updateOn":{"refresh":true,"resize":false,"timeRange":false},"params":{"view":"buckets"},"title":"Buckets"}},{"type":"metric","x":0,"y":16,"width":4,"height":8,"properties":{"view":"timeSeries","stacked":false,"metrics":[["AWS/EC2","CPUUtilization","AutoScalingGroupName","',
          !Ref 'ScanAutoScalingGroup', '",{"label":"Utilization"}]],"region":"', !Ref 'AWS::Region',
          '","title":"CPU","period":300,"liveData":true,"yAxis":{"left":{"min":0,"max":100}}}},{"type":"metric","x":4,"y":16,"width":4,"height":8,"properties":{"view":"timeSeries","stacked":false,"metrics":[["',
          !Ref 'AWS::StackName', '","mem_used_percent",{"label":"Memory utilization"}],["',
          !Ref 'AWS::StackName', '","swap_used_percent",{"label":"Swap utilization"}]],"region":"',
          !Ref 'AWS::Region', '","title":"Memory","period":300,"liveData":true,"yAxis":{"left":{"min":0,"max":100}}}},{"type":"metric","x":8,"y":16,"width":4,"height":8,"properties":{"view":"timeSeries","stacked":false,"metrics":[["',
          !Ref 'AWS::StackName', '","disk_used_percent","path","/","fstype","xfs",{"label":"Storage
            utilization"}],[{"expression":"(wops+rops)/300","label":"IOPS","id":"e1","yAxis":"right"}],["AWS/EC2","EBSWriteOps","AutoScalingGroupName","',
          !Ref 'ScanAutoScalingGroup', '",{"id":"wops","stat":"Sum","visible":false}],["AWS/EC2","EBSReadOps","AutoScalingGroupName","',
          !Ref 'ScanAutoScalingGroup', '",{"id":"rops","stat":"Sum","visible":false}],[{"expression":"(w+r)/300/1024/1024","label":"Throughput
            (MiB/s)","id":"e2","yAxis":"right"}],["AWS/EC2","EBSWriteBytes","AutoScalingGroupName","',
          !Ref 'ScanAutoScalingGroup', '",{"id":"w","stat":"Sum","visible":false}],["AWS/EC2","EBSReadBytes","AutoScalingGroupName","',
          !Ref 'ScanAutoScalingGroup', '",{"id":"r","stat":"Sum","visible":false}]],"region":"',
          !Ref 'AWS::Region', '","title":"Disk","period":300,"liveData":true,"yAxis":{"left":{"min":0,"max":100}}}},{"type":"metric","x":12,"y":16,"width":4,"height":8,"properties":{"view":"timeSeries","stacked":true,"metrics":[[{"expression":"(in+out)/300*8/1000/1000/1000","label":"Throughput
            (Gbit/s)","id":"e1"}],["AWS/EC2","NetworkIn","AutoScalingGroupName","',
          !Ref 'ScanAutoScalingGroup', '",{"id":"in","stat":"Sum","visible":false}],["AWS/EC2","NetworkOut","AutoScalingGroupName","',
          !Ref 'ScanAutoScalingGroup', '",{"id":"out","stat":"Sum","visible":false}]],"region":"',
          !Ref 'AWS::Region', '","title":"Network","period":300,"liveData":true,"yAxis":{"left":{"showUnits":false}}}},{"type":"custom","x":16,"y":16,"width":8,"height":8,"properties":{"endpoint":"',
          !GetAtt [DashboardLambdaFunction, Arn], '","updateOn":{"refresh":true,"resize":false,"timeRange":false},"params":{"view":"accounts"},"title":"AWS
            accounts"}}]}']]
      DashboardName: !Join ['', [!Ref 'AWS::StackName', '-', !Ref 'AWS::Region']]
    DependsOn:
    - DashboardLambdaPolicy
  GovernanceFindingTable:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
      - AttributeName: finding_id
        AttributeType: S
      BillingMode: PAY_PER_REQUEST
      KeySchema:
      - AttributeName: finding_id
        KeyType: HASH
      SSESpecification:
        SSEEnabled: true
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
    Condition: HasGovernance
  GovernanceLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
      PermissionsBoundary: !If [HasPermissionsBoundary, !Ref 'PermissionsBoundary',
        !Ref 'AWS::NoValue']
      Policies:
      - PolicyDocument:
          Statement:
          - !If [HasCrossAccount, {Effect: Allow, Action: 'dynamodb:Scan', Resource: !GetAtt [
                BucketCacheTable, Arn]}, {Effect: Allow, Action: ['cloudformation:DescribeStacks',
                's3:ListAllMyBuckets', 's3:GetBucketLocation', 's3:GetBucketNotification',
                'sns:ListSubscriptionsByTopic', 'events:ListRuleNamesByTarget', 'events:DescribeRule'],
              Resource: '*'}]
          - Effect: Allow
            Action: ssm:GetParametersByPath
            Resource: !Join ['', ['arn:', !Ref 'AWS::Partition', ':ssm:', !Ref 'AWS::Region',
                ':', !Ref 'AWS::AccountId', ':parameter/bucketAV/', !Ref 'AWS::StackName',
                /AddOn/scheduled-bucket-scan/*]]
          - Effect: Allow
            Action: events:DescribeEventBus
            Resource: !Join ['', ['arn:', !Ref 'AWS::Partition', ':events:', !Ref 'AWS::Region',
                ':', !Ref 'AWS::AccountId', ':event-bus/default']]
          - Effect: Allow
            Action: cloudwatch:GetMetricStatistics
            Resource: '*'
          - Effect: Allow
            Action: sns:Publish
            Resource: !GetAtt [InfrastructureAlarmsTopic, TopicArn]
          - Effect: Allow
            Action:
            - dynamodb:PutItem
            - dynamodb:DeleteItem
            - dynamodb:Scan
            Resource: !GetAtt [GovernanceFindingTable, Arn]
        PolicyName: lambda
    Condition: HasGovernance
  GovernanceLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: "var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n\
          var __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp =\
          \ Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n\
          \  for (var name in all)\n    __defProp(target, name, { get: all[name],\
          \ enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) =>\
          \ {\n  if (from && typeof from === \"object\" || typeof from === \"function\"\
          ) {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to,\
          \ key) && key !== except)\n        __defProp(to, key, { get: () => from[key],\
          \ enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n\
          \  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({},\
          \ \"__esModule\", { value: true }), mod);\n\n// lambda/governance.js\nvar\
          \ governance_exports = {};\n__export(governance_exports, {\n  FINDING_DATA:\
          \ () => FINDING_DATA,\n  handler: () => handler\n});\nmodule.exports = __toCommonJS(governance_exports);\n\
          var import_client_cloudformation2 = require(\"@aws-sdk/client-cloudformation\"\
          );\nvar import_client_s33 = require(\"@aws-sdk/client-s3\");\nvar import_client_ssm2\
          \ = require(\"@aws-sdk/client-ssm\");\nvar import_client_sns2 = require(\"\
          @aws-sdk/client-sns\");\nvar import_client_eventbridge2 = require(\"@aws-sdk/client-eventbridge\"\
          );\nvar import_client_dynamodb2 = require(\"@aws-sdk/client-dynamodb\");\n\
          var import_client_cloudwatch = require(\"@aws-sdk/client-cloudwatch\");\n\
          \n// lambda/lib.js\nvar import_client_cloudformation = require(\"@aws-sdk/client-cloudformation\"\
          );\nvar import_client_s3 = require(\"@aws-sdk/client-s3\");\nvar import_client_sns\
          \ = require(\"@aws-sdk/client-sns\");\nvar import_client_eventbridge = require(\"\
          @aws-sdk/client-eventbridge\");\nvar import_client_dynamodb = require(\"\
          @aws-sdk/client-dynamodb\");\nvar import_client_s32 = require(\"@aws-sdk/client-s3\"\
          );\nvar import_client_ssm = require(\"@aws-sdk/client-ssm\");\nvar import_client_secrets_manager\
          \ = require(\"@aws-sdk/client-secrets-manager\");\nvar import_client_organizations\
          \ = require(\"@aws-sdk/client-organizations\");\nvar import_credential_providers\
          \ = require(\"@aws-sdk/credential-providers\");\n\n// lambda/node_modules/@smithy/types/dist-es/auth/auth.js\n\
          var HttpAuthLocation;\n(function(HttpAuthLocation2) {\n  HttpAuthLocation2[\"\
          HEADER\"] = \"header\";\n  HttpAuthLocation2[\"QUERY\"] = \"query\";\n})(HttpAuthLocation\
          \ || (HttpAuthLocation = {}));\n\n// lambda/node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js\n\
          var HttpApiKeyAuthLocation;\n(function(HttpApiKeyAuthLocation2) {\n  HttpApiKeyAuthLocation2[\"\
          HEADER\"] = \"header\";\n  HttpApiKeyAuthLocation2[\"QUERY\"] = \"query\"\
          ;\n})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));\n\n// lambda/node_modules/@smithy/types/dist-es/endpoint.js\n\
          var EndpointURLScheme;\n(function(EndpointURLScheme2) {\n  EndpointURLScheme2[\"\
          HTTP\"] = \"http\";\n  EndpointURLScheme2[\"HTTPS\"] = \"https\";\n})(EndpointURLScheme\
          \ || (EndpointURLScheme = {}));\n\n// lambda/node_modules/@smithy/types/dist-es/extensions/checksum.js\n\
          var AlgorithmId;\n(function(AlgorithmId2) {\n  AlgorithmId2[\"MD5\"] = \"\
          md5\";\n  AlgorithmId2[\"CRC32\"] = \"crc32\";\n  AlgorithmId2[\"CRC32C\"\
          ] = \"crc32c\";\n  AlgorithmId2[\"SHA1\"] = \"sha1\";\n  AlgorithmId2[\"\
          SHA256\"] = \"sha256\";\n})(AlgorithmId || (AlgorithmId = {}));\n\n// lambda/node_modules/@smithy/types/dist-es/http.js\n\
          var FieldPosition;\n(function(FieldPosition2) {\n  FieldPosition2[FieldPosition2[\"\
          HEADER\"] = 0] = \"HEADER\";\n  FieldPosition2[FieldPosition2[\"TRAILER\"\
          ] = 1] = \"TRAILER\";\n})(FieldPosition || (FieldPosition = {}));\n\n//\
          \ lambda/node_modules/@smithy/types/dist-es/profile.js\nvar IniSectionType;\n\
          (function(IniSectionType2) {\n  IniSectionType2[\"PROFILE\"] = \"profile\"\
          ;\n  IniSectionType2[\"SSO_SESSION\"] = \"sso-session\";\n  IniSectionType2[\"\
          SERVICES\"] = \"services\";\n})(IniSectionType || (IniSectionType = {}));\n\
          \n// lambda/node_modules/@smithy/types/dist-es/transfer.js\nvar RequestHandlerProtocol;\n\
          (function(RequestHandlerProtocol2) {\n  RequestHandlerProtocol2[\"HTTP_0_9\"\
          ] = \"http/0.9\";\n  RequestHandlerProtocol2[\"HTTP_1_0\"] = \"http/1.0\"\
          ;\n  RequestHandlerProtocol2[\"TDS_8_0\"] = \"tds/8.0\";\n})(RequestHandlerProtocol\
          \ || (RequestHandlerProtocol = {}));\n\n// lambda/node_modules/@smithy/shared-ini-file-loader/dist-es/getSSOTokenFromFile.js\n\
          var import_fs = require(\"fs\");\nvar { readFile } = import_fs.promises;\n\
          \n// lambda/node_modules/@smithy/shared-ini-file-loader/dist-es/slurpFile.js\n\
          var import_fs2 = require(\"fs\");\nvar { readFile: readFile2 } = import_fs2.promises;\n\
          \n// lambda/node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js\n\
          var serializerMiddlewareOption = {\n  name: \"serializerMiddleware\",\n\
          \  step: \"serialize\",\n  tags: [\"SERIALIZER\"],\n  override: true\n};\n\
          \n// lambda/node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js\n\
          var endpointMiddlewareOptions = {\n  step: \"serialize\",\n  tags: [\"ENDPOINT_PARAMETERS\"\
          , \"ENDPOINT_V2\", \"ENDPOINT\"],\n  name: \"endpointV2Middleware\",\n \
          \ override: true,\n  relation: \"before\",\n  toMiddleware: serializerMiddlewareOption.name\n\
          };\n\n// lambda/node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemeEndpointRuleSetPlugin.js\n\
          var httpAuthSchemeEndpointRuleSetMiddlewareOptions = {\n  step: \"serialize\"\
          ,\n  tags: [\"HTTP_AUTH_SCHEME\"],\n  name: \"httpAuthSchemeMiddleware\"\
          ,\n  override: true,\n  relation: \"before\",\n  toMiddleware: endpointMiddlewareOptions.name\n\
          };\n\n// lambda/node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemePlugin.js\n\
          var httpAuthSchemeMiddlewareOptions = {\n  step: \"serialize\",\n  tags:\
          \ [\"HTTP_AUTH_SCHEME\"],\n  name: \"httpAuthSchemeMiddleware\",\n  override:\
          \ true,\n  relation: \"before\",\n  toMiddleware: serializerMiddlewareOption.name\n\
          };\n\n// lambda/node_modules/@smithy/util-retry/dist-es/config.js\nvar RETRY_MODES;\n\
          (function(RETRY_MODES2) {\n  RETRY_MODES2[\"STANDARD\"] = \"standard\";\n\
          \  RETRY_MODES2[\"ADAPTIVE\"] = \"adaptive\";\n})(RETRY_MODES || (RETRY_MODES\
          \ = {}));\nvar DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;\n\n// lambda/node_modules/@smithy/util-retry/dist-es/constants.js\n\
          var MAXIMUM_RETRY_DELAY = 20 * 1e3;\n\n// lambda/node_modules/@smithy/node-http-handler/dist-es/node-http2-connection-pool.js\n\
          var NodeHttp2ConnectionPool = class {\n  constructor(sessions) {\n    this.sessions\
          \ = [];\n    this.sessions = sessions ?? [];\n  }\n  poll() {\n    if (this.sessions.length\
          \ > 0) {\n      return this.sessions.shift();\n    }\n  }\n  offerLast(session)\
          \ {\n    this.sessions.push(session);\n  }\n  contains(session) {\n    return\
          \ this.sessions.includes(session);\n  }\n  remove(session) {\n    this.sessions\
          \ = this.sessions.filter((s) => s !== session);\n  }\n  [Symbol.iterator]()\
          \ {\n    return this.sessions[Symbol.iterator]();\n  }\n  destroy(connection)\
          \ {\n    for (const session of this.sessions) {\n      if (session === connection)\
          \ {\n        if (!session.destroyed) {\n          session.destroy();\n \
          \       }\n      }\n    }\n  }\n};\n\n// lambda/node_modules/@smithy/smithy-client/dist-es/parse-utils.js\n\
          var MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));\n\n// lambda/node_modules/@smithy/smithy-client/dist-es/date-utils.js\n\
          var RFC3339 = new RegExp(/^(\\d{4})-(\\d{2})-(\\d{2})[tT](\\d{2}):(\\d{2}):(\\\
          d{2})(?:\\.(\\d+))?[zZ]$/);\nvar RFC3339_WITH_OFFSET = new RegExp(/^(\\\
          d{4})-(\\d{2})-(\\d{2})[tT](\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))?(([-+]\\\
          d{2}\\:\\d{2})|[zZ])$/);\nvar IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),\
          \ (\\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\\d{4}) (\\\
          d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? GMT$/);\nvar RFC_850_DATE = new\
          \ RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday),\
          \ (\\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\\d{2}) (\\\
          d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? GMT$/);\nvar ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)\
          \ (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\\d{2}) (\\\
          d{1,2}):(\\d{2}):(\\d{2})(?:\\.(\\d+))? (\\d{4})$/);\nvar FIFTY_YEARS_IN_MILLIS\
          \ = 50 * 365 * 24 * 60 * 60 * 1e3;\n\n// lambda/node_modules/@smithy/smithy-client/dist-es/lazy-json.js\n\
          var StringWrapper = function() {\n  const Class = Object.getPrototypeOf(this).constructor;\n\
          \  const Constructor = Function.bind.apply(String, [null, ...arguments]);\n\
          \  const instance = new Constructor();\n  Object.setPrototypeOf(instance,\
          \ Class.prototype);\n  return instance;\n};\nStringWrapper.prototype = Object.create(String.prototype,\
          \ {\n  constructor: {\n    value: StringWrapper,\n    enumerable: false,\n\
          \    writable: true,\n    configurable: true\n  }\n});\nObject.setPrototypeOf(StringWrapper,\
          \ String);\n\n// lambda/node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js\n\
          var retryMiddlewareOptions = {\n  name: \"retryMiddleware\",\n  tags: [\"\
          RETRY\"],\n  step: \"finalizeRequest\",\n  priority: \"high\",\n  override:\
          \ true\n};\n\n// lambda/node_modules/@smithy/core/dist-es/middleware-http-signing/getHttpSigningMiddleware.js\n\
          var httpSigningMiddlewareOptions = {\n  step: \"finalizeRequest\",\n  tags:\
          \ [\"HTTP_SIGNING\"],\n  name: \"httpSigningMiddleware\",\n  aliases: [\"\
          apiKeyMiddleware\", \"tokenMiddleware\", \"awsAuthMiddleware\"],\n  override:\
          \ true,\n  relation: \"after\",\n  toMiddleware: retryMiddlewareOptions.name\n\
          };\n\n// lambda/node_modules/@smithy/core/dist-es/util-identity-and-auth/memoizeIdentityProvider.js\n\
          var createIsIdentityExpiredFunction = (expirationMs) => (identity) => doesIdentityRequireRefresh(identity)\
          \ && identity.expiration.getTime() - Date.now() < expirationMs;\nvar EXPIRATION_MS\
          \ = 3e5;\nvar isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);\n\
          var doesIdentityRequireRefresh = (identity) => identity.expiration !== void\
          \ 0;\n\n// lambda/node_modules/@smithy/core/dist-es/pagination/createPaginator.js\n\
          var makePagedClientRequest = async (CommandCtor, client, input, ...args)\
          \ => {\n  return await client.send(new CommandCtor(input), ...args);\n};\n\
          function createPaginator(ClientCtor, CommandCtor, inputTokenName, outputTokenName,\
          \ pageSizeTokenName) {\n  return async function* paginateOperation(config,\
          \ input, ...additionalArguments) {\n    let token = config.startingToken\
          \ || void 0;\n    let hasNext = true;\n    let page;\n    while (hasNext)\
          \ {\n      input[inputTokenName] = token;\n      if (pageSizeTokenName)\
          \ {\n        input[pageSizeTokenName] = input[pageSizeTokenName] ?? config.pageSize;\n\
          \      }\n      if (config.client instanceof ClientCtor) {\n        page\
          \ = await makePagedClientRequest(CommandCtor, config.client, input, ...additionalArguments);\n\
          \      } else {\n        throw new Error(`Invalid client, expected instance\
          \ of ${ClientCtor.name}`);\n      }\n      yield page;\n      const prevToken\
          \ = token;\n      token = get(page, outputTokenName);\n      hasNext = !!(token\
          \ && (!config.stopOnSameToken || token !== prevToken));\n    }\n    return\
          \ void 0;\n  };\n}\nvar get = (fromObject, path) => {\n  let cursor = fromObject;\n\
          \  const pathComponents = path.split(\".\");\n  for (const step of pathComponents)\
          \ {\n    if (!cursor || typeof cursor !== \"object\") {\n      return void\
          \ 0;\n    }\n    cursor = cursor[step];\n  }\n  return cursor;\n};\n\n//\
          \ lambda/lib.js\nfunction mapBucketLocationData(data) {\n  if (data.LocationConstraint\
          \ === void 0 || data.LocationConstraint === null || data.LocationConstraint\
          \ === \"\") {\n    return \"us-east-1\";\n  }\n  if (data.LocationConstraint\
          \ === \"EU\") {\n    return \"eu-west-1\";\n  }\n  return data.LocationConstraint;\n\
          }\nfunction includesBucket(scheduledStack, bucketName) {\n  let excludeFilterExpression\
          \ = \"^$\";\n  if (scheduledStack.params.ExcludeBucketNameFilter) {\n  \
          \  excludeFilterExpression = \"^\" + scheduledStack.params.ExcludeBucketNameFilter.replaceAll(\"\
          .\", \".\").replaceAll(\"-\", \"-\").replaceAll(\"*\", \".*\").replaceAll(\"\
          ,\", \"$|^\") + \"$\";\n  }\n  if (bucketName.match(new RegExp(excludeFilterExpression)))\
          \ {\n    return false;\n  }\n  if (scheduledStack.params.BucketName.includes(\"\
          *\")) {\n    const filterExpression = \"^\" + scheduledStack.params.BucketName.replaceAll(\"\
          .\", \".\").replaceAll(\"-\", \"-\").replaceAll(\"*\", \".*\").replaceAll(\"\
          ,\", \"$|^\") + \"$\";\n    return bucketName.match(new RegExp(filterExpression))\
          \ !== null;\n  } else {\n    return scheduledStack.params.BucketName.split(\"\
          ,\").includes(bucketName);\n  }\n}\nfunction hasBucket(scheduledStack, bucketName)\
          \ {\n  if (scheduledStack.params.BucketName === bucketName && (scheduledStack.params.ExcludeBucketNameFilter\
          \ === \"\" || !(\"ExcludeBucketNameFilter\" in scheduledStack.params)))\
          \ {\n    return true;\n  }\n  return false;\n}\nfunction mapCachedBucketItem(item)\
          \ {\n  const bucket = {\n    name: item.bucket_name.S,\n    accountId: item.bucket_account_id.S,\n\
          \    realtimeEnabled: item.bucket_realtime_enabled.BOOL,\n    realtimeEventNotificationEnablePossible:\
          \ item.bucket_realtime_event_notification_enable_possible.BOOL,\n    realtimeEventNotificationDisablePossible:\
          \ item.bucket_realtime_event_notification_disable_possible.BOOL,\n    scheduledEnabled:\
          \ item.bucket_scheduled_enabled.BOOL,\n    scheduledStackDisablePossible:\
          \ item.bucket_scheduled_stack_disable_possible.BOOL\n  };\n  if (\"bucket_organization_id\"\
          \ in item) {\n    bucket.organizationId = item.bucket_organization_id.S;\n\
          \  }\n  if (\"bucket_region\" in item) {\n    bucket.region = item.bucket_region.S;\n\
          \  }\n  if (\"bucket_error_message\" in item) {\n    bucket.errorMessage\
          \ = item.bucket_error_message.S;\n  }\n  if (\"bucket_scheduled_stack_id\"\
          \ in item) {\n    bucket.scheduledStackId = item.bucket_scheduled_stack_id.S;\n\
          \  }\n  return bucket;\n}\nasync function listCachedBuckets(dynamodb2, coreStackName)\
          \ {\n  const paginatorScan = await (0, import_client_dynamodb.paginateScan)({\
          \ client: dynamodb2 }, { TableName: `${coreStackName}-BucketCache` });\n\
          \  const buckets = [];\n  for await (const page of paginatorScan) {\n  \
          \  for (const item of page.Items) {\n      buckets.push(mapCachedBucketItem(item));\n\
          \    }\n  }\n  return buckets;\n}\nvar paginateListRuleNamesByTarget = createPaginator(import_client_eventbridge.EventBridgeClient,\
          \ import_client_eventbridge.ListRuleNamesByTargetCommand, \"NextToken\"\
          , \"NextToken\", \"Limit\");\nasync function checkEventBridgeRules(eventbridge2,\
          \ ruleNames, bucketName) {\n  const rules = await Promise.all(ruleNames.map((ruleName)\
          \ => eventbridge2.send(new import_client_eventbridge.DescribeRuleCommand({\
          \ Name: ruleName }))));\n  return rules.filter((rule) => rule.State ===\
          \ \"ENABLED\" && rule.EventPattern).map((rule) => JSON.parse(rule.EventPattern)).find((pattern)\
          \ => pattern.source.includes(\"aws.s3\") && pattern[\"detail-type\"].includes(\"\
          Object Created\") && (pattern?.detail?.bucket?.name?.includes(bucketName)\
          \ || pattern?.detail?.bucket?.name === void 0)) !== void 0;\n}\nasync function\
          \ enrichBucket(s32, sns2, eventbridge2, coreEventbridge, partition, region,\
          \ accountId, organizationId, coreAccountId, coreStackName, scanQueueArn,\
          \ scheduledStacks, bucketName) {\n  const bucket = await s32.send(new import_client_s3.GetBucketLocationCommand({\
          \ Bucket: bucketName })).then((data) => ({\n    name: bucketName,\n    region:\
          \ mapBucketLocationData(data),\n    accountId,\n    organizationId\n  })).catch((err)\
          \ => ({\n    name: bucketName,\n    region: void 0,\n    accountId,\n  \
          \  organizationId,\n    errorMessage: `Can not get region for bucket ${bucketName}:\
          \ ${err.name}`\n  }));\n  if (bucket.region === region || bucket.region\
          \ === void 0) {\n    let realtimeEnabled = false;\n    let realtimeEventNotificationEnablePossible\
          \ = bucket.region !== void 0;\n    let realtimeEventNotificationDisablePossible\
          \ = false;\n    let scheduledEnabled = false;\n    let scheduledStackDisablePossible\
          \ = false;\n    let scheduledStackId = void 0;\n    try {\n      const notificationData\
          \ = await s32.send(new import_client_s3.GetBucketNotificationConfigurationCommand({\
          \ Bucket: bucket.name, ExpectedBucketOwner: accountId }));\n      if (notificationData?.QueueConfigurations?.find((config)\
          \ => config.QueueArn === scanQueueArn && config.Events.includes(\"s3:ObjectCreated:*\"\
          )) !== void 0) {\n        realtimeEnabled = true;\n        realtimeEventNotificationDisablePossible\
          \ = true;\n      }\n      if (Array.isArray(notificationData?.TopicConfigurations))\
          \ {\n        await Promise.all(notificationData.TopicConfigurations.filter((config)\
          \ => config.Events.includes(\"s3:ObjectCreated:*\")).map(async (config)\
          \ => {\n          const paginatorListSubscriptionsByTopic = await (0, import_client_sns.paginateListSubscriptionsByTopic)({\
          \ client: sns2, pageSize: 50 }, { TopicArn: config.TopicArn });\n      \
          \    for await (const page of paginatorListSubscriptionsByTopic) {\n   \
          \         if (page.Subscriptions.find((subscription) => subscription.Protocol\
          \ === \"sqs\" && subscription.Endpoint === scanQueueArn) !== void 0) {\n\
          \              realtimeEnabled = true;\n            }\n          }\n   \
          \     }));\n      }\n      if (notificationData?.EventBridgeConfiguration)\
          \ {\n        if (accountId !== coreAccountId) {\n          let crossAccoutRule\
          \ = false;\n          const paginatorListRuleNamesByTargetDefaultBus = await\
          \ paginateListRuleNamesByTarget({ client: eventbridge2, pageSize: 10 },\
          \ { TargetArn: `arn:${partition}:events:${region}:${coreAccountId}:event-bus/default`\
          \ });\n          for await (const page of paginatorListRuleNamesByTargetDefaultBus)\
          \ {\n            if (await checkEventBridgeRules(eventbridge2, page.RuleNames,\
          \ bucket.name) === true) {\n              crossAccoutRule = true;\n    \
          \        }\n          }\n          const { Policy: defaultBusPolicyJson\
          \ } = await coreEventbridge.send(new import_client_eventbridge.DescribeEventBusCommand({\n\
          \            Name: \"default\"\n          }));\n          if (defaultBusPolicyJson\
          \ !== void 0) {\n            const defaultBusPolicy = JSON.parse(defaultBusPolicyJson);\n\
          \            if (defaultBusPolicy.Statement.find((s) => s?.Effect === \"\
          Allow\" && s?.Action === \"events:PutEvents\" && (s?.Principal?.AWS ===\
          \ accountId || s?.Principal === \"*\" && s?.Condition?.StringEquals[\"aws:PrincipalOrgID\"\
          ] === organizationId)) !== void 0) {\n              if (crossAccoutRule\
          \ === true) {\n                realtimeEnabled = true;\n              }\n\
          \            }\n          }\n        }\n        const paginatorListRuleNamesByTargetScanQueue\
          \ = await paginateListRuleNamesByTarget({ client: coreEventbridge, pageSize:\
          \ 10 }, { TargetArn: scanQueueArn });\n        for await (const page of\
          \ paginatorListRuleNamesByTargetScanQueue) {\n          if (await checkEventBridgeRules(coreEventbridge,\
          \ page.RuleNames, bucket.name) === true) {\n            realtimeEnabled\
          \ = true;\n          }\n        }\n      }\n      if (notificationData?.TopicConfigurations?.find((config)\
          \ => config.Events.filter((event) => event.startsWith(\"s3:ObjectCreated:\"\
          )).length > 0)) {\n        realtimeEventNotificationEnablePossible = false;\n\
          \      }\n      if (notificationData?.QueueConfigurations?.find((config)\
          \ => config.Events.filter((event) => event.startsWith(\"s3:ObjectCreated:\"\
          )).length > 0)) {\n        realtimeEventNotificationEnablePossible = false;\n\
          \      }\n      if (notificationData?.LambdaFunctionConfigurations?.find((config)\
          \ => config.Events.filter((event) => event.startsWith(\"s3:ObjectCreated:\"\
          )).length > 0)) {\n        realtimeEventNotificationEnablePossible = false;\n\
          \      }\n      if (notificationData?.EventBridgeConfiguration !== void\
          \ 0) {\n        realtimeEventNotificationEnablePossible = false;\n     \
          \ }\n    } catch (err) {\n      console.log(err);\n      bucket.errorMessage\
          \ = `Can not get details for bucket ${bucket.name}: ${err.name}`;\n    \
          \  realtimeEventNotificationEnablePossible = false;\n    }\n    const scheduledStacksIncludesBucket\
          \ = scheduledStacks.stacks.filter((scheduledStack) => includesBucket(scheduledStack,\
          \ bucket.name));\n    if (scheduledStacksIncludesBucket.length > 0) {\n\
          \      scheduledEnabled = true;\n      scheduledStackId = scheduledStacksIncludesBucket[0].id;\n\
          \    }\n    const scheduledStacksHasBucket = scheduledStacks.stacks.filter((scheduledStack)\
          \ => hasBucket(scheduledStack, bucket.name));\n    if (scheduledStacksHasBucket.length\
          \ === 1) {\n      scheduledEnabled = true;\n      scheduledStackDisablePossible\
          \ = true;\n      scheduledStackId = scheduledStacksHasBucket[0].id;\n  \
          \  }\n    return {\n      ...bucket,\n      realtimeEnabled,\n      realtimeEventNotificationEnablePossible,\n\
          \      realtimeEventNotificationDisablePossible,\n      scheduledEnabled,\n\
          \      scheduledStackDisablePossible,\n      scheduledStackId\n    };\n\
          \  } else {\n    return null;\n  }\n}\nasync function getScheduledStacks(ssm2,\
          \ cloudformation2, coreStackName) {\n  const paginatorGetParametersByPath\
          \ = await (0, import_client_ssm.paginateGetParametersByPath)({ client: ssm2\
          \ }, { Recursive: true, Path: `/bucketAV/${coreStackName}/AddOn/scheduled-bucket-scan/`\
          \ });\n  const stacks = [];\n  for await (const page of paginatorGetParametersByPath)\
          \ {\n    const scheduledStackNames = page.Parameters.filter((p) => p.Name.endsWith(\"\
          /Version\")).map((p) => p.Name.split(\"/\")[5]);\n    const describeStacksDataList\
          \ = await Promise.all(scheduledStackNames.map((stackName) => cloudformation2.send(new\
          \ import_client_cloudformation.DescribeStacksCommand({ StackName: stackName\
          \ }))));\n    describeStacksDataList.forEach((describeStacksData) => {\n\
          \      const stack = {\n        name: describeStacksData.Stacks[0].StackName,\n\
          \        id: describeStacksData.Stacks[0].StackId,\n        params: describeStacksData.Stacks[0].Parameters?.reduce((acc,\
          \ param) => {\n          acc[param.ParameterKey] = param.ParameterValue;\n\
          \          return acc;\n        }, {}) || {},\n        outputs: describeStacksData.Stacks[0].Outputs?.reduce((acc,\
          \ output) => {\n          acc[output.OutputKey] = output.OutputValue;\n\
          \          return acc;\n        }, {}) || {}\n      };\n      if (stack.params.BucketAVStackName\
          \ === coreStackName && stack.outputs.AddOn === \"scheduled-bucket-scan\"\
          ) {\n        stacks.push(stack);\n      }\n    });\n  }\n  return {\n  \
          \  stacks\n  };\n}\nasync function listBuckets(s32, ssm2, cloudformation2,\
          \ sns2, eventbridge2, coreEventbridge, partition, region, accountId, organizationId,\
          \ coreAccountId, coreStackName, scanQueueArn) {\n  const listBucketsData\
          \ = await s32.send(new import_client_s3.ListBucketsCommand({}));\n  const\
          \ scheduledStacks = await getScheduledStacks(ssm2, cloudformation2, coreStackName);\n\
          \  const buckets = await Promise.all(listBucketsData.Buckets.map((bucket)\
          \ => enrichBucket(s32, sns2, eventbridge2, coreEventbridge, partition, region,\
          \ accountId, organizationId, coreAccountId, coreStackName, scanQueueArn,\
          \ scheduledStacks, bucket.Name)));\n  return buckets.filter((bucket) =>\
          \ bucket !== null);\n}\nvar MAX_S3_COPY_SIZE = 5 * 1024 * 1024 * 1024;\n\
          \n// lambda/governance.js\nvar ONE_DAY_IN_SECONDS = 60 * 60 * 24;\nvar FINDING_TYPE_REAL_TIME_FILE_SCAN_MISSING\
          \ = \"bucketav:real-time-file-scan-missing\";\nvar FINDING_TYPE_SCHEDULED_BUCKET_SCAN_MISSING\
          \ = \"bucketav:scheduled-bucket-scan-missing\";\nvar FINDING_TYPE_NO_SCAN_ACTIVITY\
          \ = \"bucketav:no-scan-activity\";\nvar FINDING_TYPE_NO_SCAN_ACTIVITY_DAYS\
          \ = 14;\nvar FINDING_DATA = {\n  [FINDING_TYPE_REAL_TIME_FILE_SCAN_MISSING]:\
          \ {\n    findingTitle: \"Real-time file scan not enabled\",\n    findingDescription:\
          \ \"The bucket is not protected by real-time file scanning.\",\n    remediationDescription:\
          \ \"To enable real-time file scanning, please follow\",\n    remediationUrl:\
          \ \"https://bucketav.com/help/scan-modes/real-time-file-scan.html\"\n  },\n\
          \  [FINDING_TYPE_SCHEDULED_BUCKET_SCAN_MISSING]: {\n    findingTitle: \"\
          Scheduled bucket scan not enabled\",\n    findingDescription: \"The bucket\
          \ is not protected by scheduled bucket scanning.\",\n    remediationDescription:\
          \ \"To enable scheduled-bucket scanning, please follow\",\n    remediationUrl:\
          \ \"https://bucketav.com/help/scan-modes/scheduled-bucket-scan.html\"\n\
          \  },\n  [FINDING_TYPE_NO_SCAN_ACTIVITY]: {\n    findingTitle: \"No scan\
          \ activity\",\n    findingDescription: `Your bucketAV setup is likely incomplete\\\
          u2014no scan activity has been found in the past ${FINDING_TYPE_NO_SCAN_ACTIVITY_DAYS}\
          \ days.`,\n    remediationDescription: \"To complete your bucketAV setup,\
          \ please follow\",\n    remediationUrl: \"https://bucketav.com/help/setup-guide/\"\
          ,\n    ttlInSeconds: ONE_DAY_IN_SECONDS * FINDING_TYPE_NO_SCAN_ACTIVITY_DAYS\n\
          \  }\n};\nvar cloudformation = new import_client_cloudformation2.CloudFormationClient({\
          \ apiVersion: \"2006-03-01\", maxAttempts: 10 });\nvar s3 = new import_client_s33.S3Client({\
          \ apiVersion: \"2006-03-01\" });\nvar ssm = new import_client_ssm2.SSMClient({\
          \ apiVersion: \"2014-11-06\" });\nvar sns = new import_client_sns2.SNSClient({\
          \ apiVersion: \"2010-03-31\" });\nvar eventbridge = new import_client_eventbridge2.EventBridgeClient({\
          \ apiVersion: \"2015-10-07\" });\nvar dynamodb = new import_client_dynamodb2.DynamoDBClient({\
          \ apiVersion: \"2012-08-10\" });\nvar cloudwatch = new import_client_cloudwatch.CloudWatchClient({\
          \ apiVersion: \"2010-08-01\" });\nfunction generateFindingId(findingType,\
          \ bucket = null) {\n  if (bucket === null) {\n    return `bucketav:${process.env.CORE_STACK_NAME}:core:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:finding/${findingType}`;\n\
          \  }\n  return `bucketav:${process.env.CORE_STACK_NAME}:core:${process.env.AWS_REGION}:${process.env.AWS_ACCOUNT_ID}:finding/${findingType}/${bucket.name}`;\n\
          }\nfunction toString(bucketName, bucketAccountId) {\n  if (process.env.CROSS_ACCOUNT\
          \ === \"true\") {\n    return `${bucketName} (${bucketAccountId})`;\n  }\
          \ else {\n    return bucketName;\n  }\n}\nfunction truncateValue(input,\
          \ maxLength) {\n  const suffix = \"...\";\n  const str = String(input);\n\
          \  const maxLengthWithoutSuffix = maxLength - suffix.length;\n  if (str.length\
          \ > maxLength) {\n    return str.substr(0, maxLengthWithoutSuffix) + suffix;\n\
          \  }\n  return str;\n}\nasync function publish(subject, message, data) {\n\
          \  await sns.send(new import_client_sns2.PublishCommand({\n    TopicArn:\
          \ process.env.INFRASTRUCTURE_ALARMS_TOPIC_ARN,\n    Subject: subject,\n\
          \    // max 100 chars long\n    Message: JSON.stringify({\n      default:\
          \ JSON.stringify(data),\n      email: message\n    }),\n    MessageStructure:\
          \ \"json\",\n    MessageAttributes: {\n      action: {\n        DataType:\
          \ \"String\",\n        StringValue: data.action\n      }\n    }\n  }));\n\
          }\nfunction toActionLabel(action) {\n  switch (action) {\n    case \"report\"\
          :\n      return \"created\";\n    case \"close\":\n      return \"closed\"\
          ;\n    case \"archive\":\n      return \"archived\";\n    default:\n   \
          \   throw new Error(\"unsupported action\");\n  }\n}\nfunction generateSubject(data)\
          \ {\n  let subject = \"bucketAV Governance finding \";\n  subject += truncateValue(toActionLabel(data.action),\
          \ 8);\n  subject += \": \";\n  subject += truncateValue(process.env.CORE_STACK_NAME,\
          \ 35);\n  subject += \" (\";\n  subject += truncateValue(process.env.AWS_REGION,\
          \ 10);\n  subject += \", \";\n  subject += truncateValue(process.env.AWS_ACCOUNT_ID,\
          \ 12);\n  subject += \")\";\n  return truncateValue(subject, 100);\n}\n\
          async function reportFinding(now, findingType) {\n  const createdAt = now.toISOString();\n\
          \  const findingId = generateFindingId(findingType);\n  const {\n    findingTitle,\n\
          \    findingDescription,\n    remediationDescription,\n    remediationUrl,\n\
          \    ttlInSeconds = null\n  } = FINDING_DATA[findingType];\n  const data\
          \ = {\n    action: \"report\",\n    findings: [{\n      id: findingId,\n\
          \      type: findingType,\n      createdAt,\n      updatedAt: createdAt\n\
          \    }]\n  };\n  let message = `AWS Region: ${process.env.AWS_REGION}\\\
          r\n`;\n  message += `AWS Account ID: ${process.env.AWS_ACCOUNT_ID}\\r\n\
          `;\n  message += `bucketAV Stack Name: ${process.env.CORE_STACK_NAME}\\\
          r\n`;\n  message += \"\\r\\n\\r\\n\";\n  message += \"==================================================\\\
          r\\n\";\n  message += `Finding created: ${findingTitle}\\r\n`;\n  message\
          \ += \"==================================================\\r\\n\\r\\n\"\
          ;\n  message += `${findingDescription}\\r\n`;\n  message += \"\\r\\n\\r\\\
          n\";\n  message += `${remediationDescription} <${remediationUrl}>\\r\n`;\n\
          \  message += \"\\r\\n\\r\\n\";\n  message += \"Do you need help with this\
          \ email? Reach out to us <hello@bucketav.com>\\r\\n\";\n  message += \"\
          Warmly, The bucketAV Team.\\r\\n\";\n  await publish(generateSubject(data),\
          \ message, data);\n  const item = {\n    finding_id: { S: findingId },\n\
          \    finding_type: { S: findingType },\n    created_at: { S: createdAt }\n\
          \  };\n  if (ttlInSeconds !== null) {\n    item.ttl = { N: (now.getTime()\
          \ / 1e3 + ttlInSeconds).toFixed(0) };\n  }\n  await dynamodb.send(new import_client_dynamodb2.PutItemCommand({\n\
          \    TableName: process.env.TABLE_NAME,\n    Item: item\n  }));\n}\nasync\
          \ function reportFindings(now, buckets, findingType) {\n  const createdAt\
          \ = now.toISOString();\n  const {\n    findingTitle,\n    remediationDescription,\n\
          \    remediationUrl,\n    ttlInSeconds = null\n  } = FINDING_DATA[findingType];\n\
          \  if (buckets.length > 0) {\n    const data = {\n      action: \"report\"\
          ,\n      findings: buckets.slice(0, 500).map((bucket) => ({\n        id:\
          \ generateFindingId(findingType, bucket),\n        type: findingType,\n\
          \        bucketName: bucket.name,\n        bucketAccountId: bucket.accountId,\n\
          \        createdAt,\n        updatedAt: createdAt\n      })),\n      truncated:\
          \ buckets.length > 500\n    };\n    let message = `AWS Region: ${process.env.AWS_REGION}\\\
          r\n`;\n    message += `AWS Account ID: ${process.env.AWS_ACCOUNT_ID}\\r\n\
          `;\n    message += `bucketAV Stack Name: ${process.env.CORE_STACK_NAME}\\\
          r\n`;\n    message += \"\\r\\n\\r\\n\";\n    message += \"==================================================\\\
          r\\n\";\n    message += `Finding created: ${findingTitle}\\r\n`;\n    message\
          \ += \"==================================================\\r\\n\\r\\n\"\
          ;\n    message += \"The following buckets are not protected:\\r\\n\\r\\\
          n\";\n    message += buckets.slice(0, 500).map((bucket) => toString(bucket.name,\
          \ bucket.accountId)).join(\"\\r\\n\");\n    if (buckets.length > 500) {\n\
          \      message += \"...\\r\\n\";\n    }\n    message += \"\\r\\n\\r\\n\"\
          ;\n    message += `${remediationDescription} <${remediationUrl}>\\r\n`;\n\
          \    message += \"\\r\\n\\r\\n\";\n    message += \"Do you need help with\
          \ this email? Reach out to us <hello@bucketav.com>\\r\\n\";\n    message\
          \ += \"Warmly, The bucketAV Team.\\r\\n\";\n    await publish(generateSubject(data),\
          \ message, data);\n  }\n  for (const bucket of buckets) {\n    const item\
          \ = {\n      finding_id: { S: generateFindingId(findingType, bucket) },\n\
          \      finding_type: { S: findingType },\n      bucket_name: { S: bucket.name\
          \ },\n      bucket_account_id: { S: bucket.accountId },\n      created_at:\
          \ { S: createdAt }\n    };\n    if (ttlInSeconds !== null) {\n      item.ttl\
          \ = { N: (now.getTime() / 1e3 + ttlInSeconds).toFixed(0) };\n    }\n   \
          \ await dynamodb.send(new import_client_dynamodb2.PutItemCommand({\n   \
          \   TableName: process.env.TABLE_NAME,\n      Item: item\n    }));\n  }\n\
          }\nasync function closeFindings(now, reportedFindingsById, buckets, findingType)\
          \ {\n  const updatedAt = now.toISOString();\n  if (buckets.length > 0) {\n\
          \    const { findingTitle } = FINDING_DATA[findingType];\n    const data\
          \ = {\n      action: \"close\",\n      findings: buckets.map((bucket) =>\
          \ {\n        const id = generateFindingId(findingType, bucket);\n      \
          \  return {\n          id,\n          type: findingType,\n          bucketName:\
          \ bucket.name,\n          bucketAccountId: bucket.accountId,\n         \
          \ createdAt: reportedFindingsById[id].createdAt,\n          updatedAt\n\
          \        };\n      })\n    };\n    let message = `AWS Region: ${process.env.AWS_REGION}\\\
          r\n`;\n    message += `AWS Account ID: ${process.env.AWS_ACCOUNT_ID}\\r\n\
          `;\n    message += `bucketAV Stack Name: ${process.env.CORE_STACK_NAME}\\\
          r\n`;\n    message += \"\\r\\n\\r\\n\";\n    message += \"==================================================\\\
          r\\n\";\n    message += `Finding closed: ${findingTitle}\\r\n`;\n    message\
          \ += \"==================================================\\r\\n\\r\\n\"\
          ;\n    message += \"The following buckets are protected:\\r\\n\\r\\n\";\n\
          \    message += buckets.map((bucket) => toString(bucket.name, bucket.accountId)).join(\"\
          \\r\\n\");\n    message += \"\\r\\n\\r\\n\";\n    message += \"Do you need\
          \ help with this email? Reach out to us <hello@bucketav.com>\\r\\n\";\n\
          \    message += \"Warmly, The bucketAV Team.\\r\\n\";\n    await publish(generateSubject(data),\
          \ message, data);\n  }\n  for (const bucket of buckets) {\n    await dynamodb.send(new\
          \ import_client_dynamodb2.DeleteItemCommand({\n      TableName: process.env.TABLE_NAME,\n\
          \      Key: {\n        finding_id: { S: generateFindingId(findingType, bucket)\
          \ }\n      }\n    }));\n  }\n}\nasync function archiveFindings(now, reportedFindings,\
          \ findingType) {\n  const updatedAt = now.toISOString();\n  if (reportedFindings.length\
          \ > 0) {\n    const { findingTitle } = FINDING_DATA[findingType];\n    const\
          \ data = {\n      action: \"archive\",\n      findings: reportedFindings.map((reportedFinding)\
          \ => ({\n        id: reportedFinding.findingId,\n        type: findingType,\n\
          \        bucketName: reportedFinding.bucketName,\n        bucketAccountId:\
          \ reportedFinding.bucketAccountId,\n        createdAt: reportedFinding.createdAt,\n\
          \        updatedAt\n      }))\n    };\n    let message = `AWS Region: ${process.env.AWS_REGION}\\\
          r\n`;\n    message += `AWS Account ID: ${process.env.AWS_ACCOUNT_ID}\\r\n\
          `;\n    message += `bucketAV Stack Name: ${process.env.CORE_STACK_NAME}\\\
          r\n`;\n    message += \"\\r\\n\\r\\n\";\n    message += \"==================================================\\\
          r\\n\";\n    message += `Finding archived: ${findingTitle}\\r\n`;\n    message\
          \ += \"==================================================\\r\\n\\r\\n\"\
          ;\n    message += \"The following buckets are deleted:\\r\\n\\r\\n\";\n\
          \    message += reportedFindings.map((reportedFinding) => toString(reportedFinding.bucketName,\
          \ reportedFinding.bucketAccountId)).join(\"\\r\\n\");\n    message += \"\
          \\r\\n\\r\\n\";\n    message += \"Do you need help with this email? Reach\
          \ out to us <hello@bucketav.com>\\r\\n\";\n    message += \"Warmly, The\
          \ bucketAV Team.\\r\\n\";\n    await publish(generateSubject(data), message,\
          \ data);\n  }\n  for (const reportedFinding of reportedFindings) {\n   \
          \ await dynamodb.send(new import_client_dynamodb2.DeleteItemCommand({\n\
          \      TableName: process.env.TABLE_NAME,\n      Key: {\n        finding_id:\
          \ { S: reportedFinding.findingId }\n      }\n    }));\n  }\n}\nasync function\
          \ reportRealTimeFileScanMissingFindings(now, buckets) {\n  await reportFindings(now,\
          \ buckets, FINDING_TYPE_REAL_TIME_FILE_SCAN_MISSING);\n}\nasync function\
          \ closeRealTimeFileScanMissingFindings(now, reportedFindingsById, buckets)\
          \ {\n  await closeFindings(now, reportedFindingsById, buckets, FINDING_TYPE_REAL_TIME_FILE_SCAN_MISSING);\n\
          }\nasync function archiveRealTimeFileScanMissingFindings(now, reportedFindings)\
          \ {\n  await archiveFindings(now, reportedFindings, FINDING_TYPE_REAL_TIME_FILE_SCAN_MISSING);\n\
          }\nasync function reportScheduledBucketScanMissingFindings(now, buckets)\
          \ {\n  await reportFindings(now, buckets, FINDING_TYPE_SCHEDULED_BUCKET_SCAN_MISSING);\n\
          }\nasync function closeScheduledBucketScanMissingFindings(now, reportedFindingsById,\
          \ buckets) {\n  await closeFindings(now, reportedFindingsById, buckets,\
          \ FINDING_TYPE_SCHEDULED_BUCKET_SCAN_MISSING);\n}\nasync function archiveScheduledBucketScanMissingFindings(now,\
          \ reportedFindings) {\n  await archiveFindings(now, reportedFindings, FINDING_TYPE_SCHEDULED_BUCKET_SCAN_MISSING);\n\
          }\nasync function getMetricSum(metricName, start, end) {\n  const { Datapoints:\
          \ datapoints } = await cloudwatch.send(new import_client_cloudwatch.GetMetricStatisticsCommand({\n\
          \    Namespace: process.env.CORE_STACK_NAME,\n    MetricName: metricName,\n\
          \    Statistics: [\"Sum\"],\n    StartTime: start,\n    EndTime: end,\n\
          \    Period: ONE_DAY_IN_SECONDS\n  }));\n  return datapoints?.reduce((acc,\
          \ datapoint) => acc + datapoint.Sum, 0) || 0;\n}\nasync function checkScanHistory(now,\
          \ days) {\n  const start = new Date(now.getTime() - 1e3 * ONE_DAY_IN_SECONDS\
          \ * days);\n  const clean = await getMetricSum(\"clean\", start, now);\n\
          \  const infected = await getMetricSum(\"infected\", start, now);\n  const\
          \ no = await getMetricSum(\"no\", start, now);\n  if (clean + infected +\
          \ no === 0) {\n    await reportFinding(now, FINDING_TYPE_NO_SCAN_ACTIVITY);\n\
          \  }\n}\nasync function handler(event, context) {\n  console.log(`Invoke:\
          \ ${JSON.stringify(event)} ${JSON.stringify(context)}`);\n  const buckets\
          \ = process.env.CROSS_ACCOUNT === \"true\" ? await listCachedBuckets(dynamodb,\
          \ process.env.CORE_STACK_NAME) : await listBuckets(s3, ssm, cloudformation,\
          \ sns, eventbridge, eventbridge, process.env.AWS_PARTITION, process.env.AWS_REGION,\
          \ process.env.AWS_ACCOUNT_ID, void 0, process.env.AWS_ACCOUNT_ID, process.env.CORE_STACK_NAME,\
          \ process.env.SCAN_QUEUE_ARN);\n  const bucketsByName = buckets?.reduce((acc,\
          \ bucket) => {\n    acc[bucket.name] = bucket;\n    return acc;\n  }, {})\
          \ || {};\n  const now = \"time\" in event ? new Date(event.time) : /* @__PURE__\
          \ */ new Date();\n  const reportedFindings = [];\n  const reportedFindingsById\
          \ = {};\n  const paginator = (0, import_client_dynamodb2.paginateScan)({\n\
          \    client: dynamodb\n  }, {\n    TableName: process.env.TABLE_NAME\n \
          \ });\n  for await (const page of paginator) {\n    for (const item of page.Items)\
          \ {\n      const finding = {\n        findingId: item.finding_id.S,\n  \
          \      findingType: item.finding_type.S,\n        bucketName: null,\n  \
          \      bucketAccountId: null,\n        createdAt: item.created_at.S\n  \
          \    };\n      if (\"bucket_name\" in item) {\n        finding.bucketName\
          \ = item.bucket_name.S;\n        if (\"bucket_account_id\" in item) {\n\
          \          finding.bucketAccountId = item.bucket_account_id.S;\n       \
          \ } else {\n          finding.bucketAccountId = process.env.AWS_ACCOUNT_ID;\n\
          \        }\n      }\n      reportedFindings.push(finding);\n      reportedFindingsById[item.finding_id.S]\
          \ = finding;\n    }\n  }\n  await reportRealTimeFileScanMissingFindings(now,\
          \ buckets.filter((bucket) => bucket.realtimeEnabled === false).filter((bucket)\
          \ => !(generateFindingId(FINDING_TYPE_REAL_TIME_FILE_SCAN_MISSING, bucket)\
          \ in reportedFindingsById)));\n  await closeRealTimeFileScanMissingFindings(now,\
          \ reportedFindingsById, buckets.filter((bucket) => bucket.realtimeEnabled\
          \ === true).filter((bucket) => generateFindingId(FINDING_TYPE_REAL_TIME_FILE_SCAN_MISSING,\
          \ bucket) in reportedFindingsById));\n  await archiveRealTimeFileScanMissingFindings(now,\
          \ reportedFindings.filter((finding) => finding.findingType === FINDING_TYPE_REAL_TIME_FILE_SCAN_MISSING).filter((finding)\
          \ => !(finding.bucketName in bucketsByName)));\n  await reportScheduledBucketScanMissingFindings(now,\
          \ buckets.filter((bucket) => bucket.scheduledEnabled === false).filter((bucket)\
          \ => !(generateFindingId(FINDING_TYPE_SCHEDULED_BUCKET_SCAN_MISSING, bucket)\
          \ in reportedFindingsById)));\n  await closeScheduledBucketScanMissingFindings(now,\
          \ reportedFindingsById, buckets.filter((bucket) => bucket.scheduledEnabled\
          \ === true).filter((bucket) => generateFindingId(FINDING_TYPE_SCHEDULED_BUCKET_SCAN_MISSING,\
          \ bucket) in reportedFindingsById));\n  await archiveScheduledBucketScanMissingFindings(now,\
          \ reportedFindings.filter((finding) => finding.findingType === FINDING_TYPE_SCHEDULED_BUCKET_SCAN_MISSING).filter((finding)\
          \ => !(finding.bucketName in bucketsByName)));\n  if (!(generateFindingId(FINDING_TYPE_NO_SCAN_ACTIVITY)\
          \ in reportedFindingsById)) {\n    await checkScanHistory(now, FINDING_TYPE_NO_SCAN_ACTIVITY_DAYS);\n\
          \  }\n}\n// Annotate the CommonJS export names for ESM import in node:\n\
          0 && (module.exports = {\n  FINDING_DATA,\n  handler\n});\n"
      Environment:
        Variables:
          CORE_STACK_NAME: !Ref 'AWS::StackName'
          AWS_PARTITION: !Ref 'AWS::Partition'
          AWS_ACCOUNT_ID: !Ref 'AWS::AccountId'
          SCAN_QUEUE_ARN: !GetAtt [ScanQueue, Arn]
          INFRASTRUCTURE_ALARMS_TOPIC_ARN: !GetAtt [InfrastructureAlarmsTopic, TopicArn]
          TABLE_NAME: !Ref 'GovernanceFindingTable'
          CROSS_ACCOUNT: !If [HasCrossAccount, 'true', 'false']
      Handler: index.handler
      MemorySize: 1769
      Role: !GetAtt [GovernanceLambdaRole, Arn]
      Runtime: nodejs20.x
      Timeout: 300
    Condition: HasGovernance
  GovernanceLambdaErrorsAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmActions:
      - !Ref 'InfrastructureAlarmsTopic'
      AlarmDescription: !Join ['', ['bucketAV Governance check failed. Check logs
            of AWS Lambda Function ', !Ref 'GovernanceLambdaFunction', '!']]
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
      - Name: FunctionName
        Value: !Ref 'GovernanceLambdaFunction'
      EvaluationPeriods: 1
      MetricName: Errors
      Namespace: AWS/Lambda
      Period: 60
      Statistic: Sum
      Threshold: 1
      TreatMissingData: notBreaching
    Condition: HasGovernance
  GovernanceLambdaThrottlesAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmActions:
      - !Ref 'InfrastructureAlarmsTopic'
      AlarmDescription: bucketAV Governance check throttled.
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
      - Name: FunctionName
        Value: !Ref 'GovernanceLambdaFunction'
      EvaluationPeriods: 1
      MetricName: Throttles
      Namespace: AWS/Lambda
      Period: 60
      Statistic: Sum
      Threshold: 1
      TreatMissingData: notBreaching
    Condition: HasGovernance
  GovernanceLambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join ['', [/aws/lambda/, !Ref 'GovernanceLambdaFunction']]
      RetentionInDays: !Ref 'LogsRetentionInDays'
    Condition: HasGovernance
  GovernanceLambdaPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Statement:
        - Effect: Allow
          Action:
          - logs:CreateLogStream
          - logs:PutLogEvents
          Resource: !GetAtt [GovernanceLambdaLogGroup, Arn]
      PolicyName: logs
      Roles:
      - !Ref 'GovernanceLambdaRole'
    Condition: HasGovernance
  GovernanceLambdaCron:
    Type: AWS::Events::Rule
    Properties:
      ScheduleExpression: rate(1 day)
      Targets:
      - Arn: !GetAtt [GovernanceLambdaFunction, Arn]
        Id: lambda
    DependsOn:
    - GovernanceLambdaPolicy
    Condition: HasGovernance
  GovernanceLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref 'GovernanceLambdaFunction'
      Principal: events.amazonaws.com
      SourceArn: !GetAtt [GovernanceLambdaCron, Arn]
    Condition: HasGovernance
  ServiceDiscoveryVersion:
    Type: AWS::SSM::Parameter
    Properties:
      Description: bucketAV managed value. DO NOT CHANGE!
      Name: !Join ['', [/bucketAV/, !Ref 'AWS::StackName', /Version]]
      Type: String
      Value: 2.19.3
  ServiceDiscoveryFulfillmentOption:
    Type: AWS::SSM::Parameter
    Properties:
      Description: bucketAV managed value. DO NOT CHANGE!
      Name: !Join ['', [/bucketAV/, !Ref 'AWS::StackName', /FulfillmentOption]]
      Type: String
      Value: dedicated-private-vpc
  ServiceDiscoveryEngine:
    Type: AWS::SSM::Parameter
    Properties:
      Description: bucketAV managed value. DO NOT CHANGE!
      Name: !Join ['', [/bucketAV/, !Ref 'AWS::StackName', /Engine]]
      Type: String
      Value: clamav
  ServiceDiscoveryScanQueueArn:
    Type: AWS::SSM::Parameter
    Properties:
      Description: bucketAV managed value. DO NOT CHANGE!
      Name: !Join ['', [/bucketAV/, !Ref 'AWS::StackName', /ScanQueueArn]]
      Type: String
      Value: !GetAtt [ScanQueue, Arn]
  ServiceDiscoveryScanQueueUrl:
    Type: AWS::SSM::Parameter
    Properties:
      Description: bucketAV managed value. DO NOT CHANGE!
      Name: !Join ['', [/bucketAV/, !Ref 'AWS::StackName', /ScanQueueUrl]]
      Type: String
      Value: !Ref 'ScanQueue'
  ServiceDiscoveryFindingsTopicArn:
    Type: AWS::SSM::Parameter
    Properties:
      Description: bucketAV managed value. DO NOT CHANGE!
      Name: !Join ['', [/bucketAV/, !Ref 'AWS::StackName', /FindingsTopicArn]]
      Type: String
      Value: !Ref 'FindingsTopic'
  ServiceDiscoveryCrossAccount:
    Type: AWS::SSM::Parameter
    Properties:
      Description: bucketAV managed value. DO NOT CHANGE!
      Name: !Join ['', [/bucketAV/, !Ref 'AWS::StackName', /CrossAccount]]
      Type: String
      Value: !If [HasCrossAccount, 'true', 'false']
Outputs:
  InfrastructureAlarmsTopicArn:
    Description: The ARN of the Infrastructure Alarms Topic.
    Value: !Ref 'InfrastructureAlarmsTopic'
    Export:
      Name: !Join ['', [!Ref 'AWS::StackName', -InfrastructureAlarmsTopicArn]]
  InfrastructureAlarmsTopicName:
    Description: The name of the Infrastructure Alarms Topic.
    Value: !GetAtt [InfrastructureAlarmsTopic, TopicName]
    Export:
      Name: !Join ['', [!Ref 'AWS::StackName', -InfrastructureAlarmsTopicName]]
  FindingsTopicArn:
    Description: The ARN of the Findings Topic.
    Value: !Ref 'FindingsTopic'
    Export:
      Name: !Join ['', [!Ref 'AWS::StackName', -FindingsTopicArn]]
  FindingsTopicName:
    Description: The name of the Findings Topic.
    Value: !GetAtt [FindingsTopic, TopicName]
    Export:
      Name: !Join ['', [!Ref 'AWS::StackName', -FindingsTopicName]]
  FulfillmentOption:
    Description: Fulfillment option.
    Value: dedicated-private-vpc
  Version:
    Description: bucketAV version.
    Value: 2.19.3
  Engine:
    Description: bucketAV engine.
    Value: clamav
  StackName:
    Description: Stack name.
    Value: !Ref 'AWS::StackName'
  ScanRoleArn:
    Description: The ARN of the Scan Role.
    Value: !GetAtt [ScanIAMRole, Arn]
    Export:
      Name: !Join ['', [!Ref 'AWS::StackName', -ScanRoleArn]]
  ScanQueueArn:
    Description: The ARN of the Scan Queue.
    Value: !GetAtt [ScanQueue, Arn]
    Export:
      Name: !Join ['', [!Ref 'AWS::StackName', -ScanQueueArn]]
  ScanQueueName:
    Description: The name of the Scan Queue.
    Value: !GetAtt [ScanQueue, QueueName]
    Export:
      Name: !Join ['', [!Ref 'AWS::StackName', -ScanQueueName]]
  ScanQueueUrl:
    Description: The URL of the Scan Queue.
    Value: !Ref 'ScanQueue'
    Export:
      Name: !Join ['', [!Ref 'AWS::StackName', -ScanQueueUrl]]
  ScanAutoScalingGroupName:
    Description: Name of the scan ASG.
    Value: !Ref 'ScanAutoScalingGroup'
  FallbackAutoScalingGroupName:
    Description: Name of the fallback ASG.
    Value: !Ref 'FallbackAutoScalingGroup'
    Condition: HasOnDemandFallback
  DeadLetterQueueArn:
    Description: The ARN of the Dead Letter Queue.
    Value: !GetAtt [DeadLetterQueue, Arn]
  DeadLetterQueueName:
    Description: The name of the Dead Letter Queue.
    Value: !GetAtt [DeadLetterQueue, QueueName]
  DeadLetterQueueUrl:
    Description: The URL of the Dead Letter Queue.
    Value: !Ref 'DeadLetterQueue'
